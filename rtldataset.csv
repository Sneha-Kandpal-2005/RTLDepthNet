num_wires,num_cells,num_memories,has_warnings,has_errors,RTL Code,num_lines,sample_id
317,434,0,True,False,"module axi_protocol_converter_v2_1_b2s_simple_fifo #
(
  parameter C_WIDTH  = 8,
  parameter C_AWIDTH = 4,
  parameter C_DEPTH  = 16
)
(
  input  wire               clk,       // Main System Clock  (Sync FIFO)
  input  wire               rst,       // FIFO Counter Reset (Clk
  input  wire               wr_en,     // FIFO Write Enable  (Clk)
  input  wire               rd_en,     // FIFO Read Enable   (Clk)
  input  wire [C_WIDTH-1:0] din,       // FIFO Data Input    (Clk)
  output wire [C_WIDTH-1:0] dout,      // FIFO Data Output   (Clk)
  output wire               a_full,
  output wire               full,      // FIFO FULL Status   (Clk)
  output wire               a_empty,
  output wire               empty      // FIFO EMPTY Status  (Clk)
);

///////////////////////////////////////
// FIFO Local Parameters
///////////////////////////////////////
localparam [C_AWIDTH-1:0] C_EMPTY = ~(0);
localparam [C_AWIDTH-1:0] C_EMPTY_PRE =  (0);
localparam [C_AWIDTH-1:0] C_FULL  = C_EMPTY-1;
localparam [C_AWIDTH-1:0] C_FULL_PRE  = (C_DEPTH < 8) ? C_FULL-1 : C_FULL-(C_DEPTH/8);
 
///////////////////////////////////////
// FIFO Internal Signals
///////////////////////////////////////
reg [C_WIDTH-1:0]  memory [C_DEPTH-1:0];
reg [C_AWIDTH-1:0] cnt_read;
  // synthesis attribute MAX_FANOUT of cnt_read is 10; 

///////////////////////////////////////
// Main simple FIFO Array
///////////////////////////////////////
always @(posedge clk) begin : BLKSRL
integer i;
  if (wr_en) begin
    for (i = 0; i < C_DEPTH-1; i = i + 1) begin
      memory[i+1] <= memory[i];
    end
    memory[0] <= din;
  end
end

///////////////////////////////////////
// Read Index Counter
// Up/Down Counter
//  *** Notice that there is no ***
//  *** OVERRUN protection.     ***
///////////////////////////////////////
always @(posedge clk) begin
  if (rst) cnt_read <= C_EMPTY;
  else if ( wr_en & !rd_en) cnt_read <= cnt_read + 1'b1;
  else if (!wr_en &  rd_en) cnt_read <= cnt_read - 1'b1;
end

///////////////////////////////////////
// Status Flags / Outputs
// These could be registered, but would
// increase logic in order to pre-decode
// FULL/EMPTY status.
///////////////////////////////////////
assign full  = (cnt_read == C_FULL);
assign empty = (cnt_read == C_EMPTY);
assign a_full  = ((cnt_read >= C_FULL_PRE) && (cnt_read != C_EMPTY));
assign a_empty = (cnt_read == C_EMPTY_PRE);

assign dout  = (C_DEPTH == 1) ? memory[0] : memory[cnt_read];

endmodule",73,0
252,365,0,False,False,"module altera_avalon_sc_fifo
#(
    // --------------------------------------------------
    // Parameters
    // --------------------------------------------------
    parameter SYMBOLS_PER_BEAT  = 1,
    parameter BITS_PER_SYMBOL   = 8,
    parameter FIFO_DEPTH        = 16,
    parameter CHANNEL_WIDTH     = 0,
    parameter ERROR_WIDTH       = 0,
    parameter USE_PACKETS       = 0,
    parameter USE_FILL_LEVEL    = 0,
    parameter USE_STORE_FORWARD = 0,
    parameter USE_ALMOST_FULL_IF = 0,
    parameter USE_ALMOST_EMPTY_IF = 0,

    // --------------------------------------------------
    // Empty latency is defined as the number of cycles
    // required for a write to deassert the empty flag.
    // For example, a latency of 1 means that the empty
    // flag is deasserted on the cycle after a write.
    //
    // Another way to think of it is the latency for a
    // write to propagate to the output. 
    // 
    // An empty latency of 0 implies lookahead, which is
    // only implemented for the register-based FIFO.
    // --------------------------------------------------
    parameter EMPTY_LATENCY     = 3,
    parameter USE_MEMORY_BLOCKS = 1,

    // --------------------------------------------------
    // Internal Parameters
    // --------------------------------------------------
    parameter DATA_WIDTH  = SYMBOLS_PER_BEAT * BITS_PER_SYMBOL,
    parameter EMPTY_WIDTH = log2ceil(SYMBOLS_PER_BEAT)
)
(
    // --------------------------------------------------
    // Ports
    // --------------------------------------------------
    input                       clk,
    input                       reset,

    input [DATA_WIDTH-1: 0]     in_data,
    input                       in_valid,
    input                       in_startofpacket,
    input                       in_endofpacket,
    input [((EMPTY_WIDTH>0) ? (EMPTY_WIDTH-1):0) : 0]     in_empty,
    input [((ERROR_WIDTH>0) ? (ERROR_WIDTH-1):0) : 0]     in_error,
    input [((CHANNEL_WIDTH>0) ? (CHANNEL_WIDTH-1):0): 0]  in_channel,
    output                      in_ready,

    output [DATA_WIDTH-1 : 0]   out_data,
    output reg                  out_valid,
    output                      out_startofpacket,
    output                      out_endofpacket,
    output [((EMPTY_WIDTH>0) ? (EMPTY_WIDTH-1):0) : 0]    out_empty,
    output [((ERROR_WIDTH>0) ? (ERROR_WIDTH-1):0) : 0]    out_error,
    output [((CHANNEL_WIDTH>0) ? (CHANNEL_WIDTH-1):0): 0] out_channel,
    input                       out_ready,

    input [(USE_STORE_FORWARD ? 2 : 1) : 0]   csr_address,
    input                       csr_write,
    input                       csr_read,
    input [31 : 0]              csr_writedata,
    output reg [31 : 0]         csr_readdata,

    output  wire                almost_full_data,
    output  wire                almost_empty_data
);

    // --------------------------------------------------
    // Local Parameters
    // --------------------------------------------------
    localparam ADDR_WIDTH   = log2ceil(FIFO_DEPTH);
    localparam DEPTH        = FIFO_DEPTH;
    localparam PKT_SIGNALS_WIDTH = 2 + EMPTY_WIDTH;
    localparam PAYLOAD_WIDTH     = (USE_PACKETS == 1) ? 
                   2 + EMPTY_WIDTH + DATA_WIDTH + ERROR_WIDTH + CHANNEL_WIDTH:
                   DATA_WIDTH + ERROR_WIDTH + CHANNEL_WIDTH;

    // --------------------------------------------------
    // Internal Signals
    // --------------------------------------------------
    genvar i;

    reg [PAYLOAD_WIDTH-1 : 0] mem [DEPTH-1 : 0];
    reg [ADDR_WIDTH-1 : 0]  wr_ptr;
    reg [ADDR_WIDTH-1 : 0]  rd_ptr;
    reg [DEPTH-1      : 0]  mem_used;

    wire [ADDR_WIDTH-1 : 0] next_wr_ptr;
    wire [ADDR_WIDTH-1 : 0] next_rd_ptr;
    wire [ADDR_WIDTH-1 : 0] incremented_wr_ptr;
    wire [ADDR_WIDTH-1 : 0] incremented_rd_ptr;

    wire [ADDR_WIDTH-1 : 0] mem_rd_ptr;

    wire read;
    wire write;

    reg empty;
    reg next_empty;
    reg full;
    reg next_full;

    wire [PKT_SIGNALS_WIDTH-1 : 0] in_packet_signals;
    wire [PKT_SIGNALS_WIDTH-1 : 0] out_packet_signals;
    wire [PAYLOAD_WIDTH-1 : 0] in_payload;
    reg  [PAYLOAD_WIDTH-1 : 0] internal_out_payload;
    reg  [PAYLOAD_WIDTH-1 : 0] out_payload;

    reg  internal_out_valid;
    wire internal_out_ready;

    reg  [ADDR_WIDTH : 0] fifo_fill_level;
    reg  [ADDR_WIDTH : 0] fill_level;

    reg  [ADDR_WIDTH-1 : 0]   sop_ptr = 0;
    wire [ADDR_WIDTH-1 : 0]   curr_sop_ptr;
    reg  [23:0]   almost_full_threshold;
    reg  [23:0]   almost_empty_threshold;
    reg  [23:0]   cut_through_threshold;
    reg  [15:0]   pkt_cnt;
    reg           drop_on_error_en;
    reg           error_in_pkt;
    reg           pkt_has_started;
    reg           sop_has_left_fifo;
    reg           fifo_too_small_r;
    reg           pkt_cnt_eq_zero;
    reg           pkt_cnt_eq_one;

    wire          wait_for_threshold;
    reg           pkt_mode;
    wire          wait_for_pkt;
    wire          ok_to_forward;
    wire          in_pkt_eop_arrive;
    wire          out_pkt_leave;
    wire          in_pkt_start;
    wire          in_pkt_error;
    wire          drop_on_error;
    wire          fifo_too_small;
    wire          out_pkt_sop_leave;
    wire [31:0]   max_fifo_size;
    reg           fifo_fill_level_lt_cut_through_threshold;

    // --------------------------------------------------
    // Define Payload
    //
    // Icky part where we decide which signals form the
    // payload to the FIFO with generate blocks.
    // --------------------------------------------------
    generate
        if (EMPTY_WIDTH > 0) begin : gen_blk1
            assign in_packet_signals = {in_startofpacket, in_endofpacket, in_empty};
            assign {out_startofpacket, out_endofpacket, out_empty} = out_packet_signals;
        end 
        else begin : gen_blk1_else
            assign out_empty = in_error;
            assign in_packet_signals = {in_startofpacket, in_endofpacket};
            assign {out_startofpacket, out_endofpacket} = out_packet_signals;
        end
    endgenerate

    generate
        if (USE_PACKETS) begin : gen_blk2
            if (ERROR_WIDTH > 0) begin : gen_blk3
                if (CHANNEL_WIDTH > 0) begin : gen_blk4
                    assign in_payload = {in_packet_signals, in_data, in_error, in_channel};
                    assign {out_packet_signals, out_data, out_error, out_channel} = out_payload;
                end
                else begin : gen_blk4_else
                    assign out_channel = in_channel;
                    assign in_payload = {in_packet_signals, in_data, in_error};
                    assign {out_packet_signals, out_data, out_error} = out_payload;
                end
            end
            else begin : gen_blk3_else
                assign out_error = in_error;
                if (CHANNEL_WIDTH > 0) begin : gen_blk5
                    assign in_payload = {in_packet_signals, in_data, in_channel};
                    assign {out_packet_signals, out_data, out_channel} = out_payload;
                end
                else begin : gen_blk5_else
                    assign out_channel = in_channel;
                    assign in_payload = {in_packet_signals, in_data};
                    assign {out_packet_signals, out_data} = out_payload;
                end
            end
        end
        else begin : gen_blk2_else
            assign out_packet_signals = 0;
            if (ERROR_WIDTH > 0) begin : gen_blk6
                if (CHANNEL_WIDTH > 0) begin : gen_blk7
                    assign in_payload = {in_data, in_error, in_channel};
                    assign {out_data, out_error, out_channel} = out_payload;
                end
                else begin : gen_blk7_else
                    assign out_channel = in_channel;
                    assign in_payload = {in_data, in_error};
                    assign {out_data, out_error} = out_payload;
                end
            end
            else begin : gen_blk6_else
                assign out_error = in_error;
                if (CHANNEL_WIDTH > 0) begin : gen_blk8
                    assign in_payload = {in_data, in_channel};
                    assign {out_data, out_channel} = out_payload;
                end
                else begin : gen_blk8_else
                    assign out_channel = in_channel;
                    assign in_payload = in_data;
                    assign out_data = out_payload;
                end
            end
        end
    endgenerate

    // --------------------------------------------------
    // Memory-based FIFO storage
    //
    // To allow a ready latency of 0, the read index is 
    // obtained from the next read pointer and memory 
    // outputs are unregistered.
    //
    // If the empty latency is 1, we infer bypass logic
    // around the memory so writes propagate to the
    // outputs on the next cycle.
    //
    // Do not change the way this is coded: Quartus needs
    // a perfect match to the template, and any attempt to 
    // refactor the two always blocks into one will break
    // memory inference.
    // --------------------------------------------------
    generate if (USE_MEMORY_BLOCKS == 1) begin  : gen_blk9

        if (EMPTY_LATENCY == 1) begin : gen_blk10

            always @(posedge clk) begin
                if (in_valid && in_ready)
                    mem[wr_ptr] = in_payload;

                internal_out_payload = mem[mem_rd_ptr];
            end

        end else begin : gen_blk10_else

            always @(posedge clk) begin
                if (in_valid && in_ready)
                    mem[wr_ptr] <= in_payload;

                internal_out_payload <= mem[mem_rd_ptr];
            end

        end

        assign mem_rd_ptr = next_rd_ptr;
    
    end else begin : gen_blk9_else

    // --------------------------------------------------
    // Register-based FIFO storage
    //
    // Uses a shift register as the storage element. Each
    // shift register slot has a bit which indicates if
    // the slot is occupied (credit to Sam H for the idea).
    // The occupancy bits are contiguous and start from the
    // lsb, so 0000, 0001, 0011, 0111, 1111 for a 4-deep
    // FIFO.
    // 
    // Each slot is enabled during a read or when it
    // is unoccupied. New data is always written to every
    // going-to-be-empty slot (we keep track of which ones
    // are actually useful with the occupancy bits). On a
    // read we shift occupied slots.
    // 
    // The exception is the last slot, which always gets 
    // new data when it is unoccupied.
    // --------------------------------------------------
        for (i = 0; i < DEPTH-1; i = i + 1) begin : shift_reg
            always @(posedge clk or posedge reset) begin
                if (reset) begin
                    mem[i] <= 0;
                end 
                else if (read || !mem_used[i]) begin
                    if (!mem_used[i+1])
                        mem[i] <= in_payload;
                    else
                        mem[i] <= mem[i+1];
                end
            end
        end

        always @(posedge clk, posedge reset) begin
            if (reset) begin
                mem[DEPTH-1] <= 0;
            end 
            else begin
                if (DEPTH == 1) begin
                    if (write)
                        mem[DEPTH-1] <= in_payload;
                end
                else if (!mem_used[DEPTH-1])
                    mem[DEPTH-1] <= in_payload;    
            end
        end

    end
    endgenerate

    assign read  = internal_out_ready && internal_out_valid  && ok_to_forward;
    assign write = in_ready && in_valid;

    // --------------------------------------------------
    // Pointer Management
    // --------------------------------------------------
    generate if (USE_MEMORY_BLOCKS == 1) begin : gen_blk11

        assign incremented_wr_ptr = wr_ptr + 1'b1;
        assign incremented_rd_ptr = rd_ptr + 1'b1;
        assign next_wr_ptr =  drop_on_error ? curr_sop_ptr : write ?  incremented_wr_ptr : wr_ptr;
        assign next_rd_ptr = (read) ? incremented_rd_ptr : rd_ptr;

        always @(posedge clk or posedge reset) begin
            if (reset) begin
                wr_ptr <= 0;
                rd_ptr <= 0;
            end
            else begin
                wr_ptr <= next_wr_ptr;
                rd_ptr <= next_rd_ptr;
            end
        end

    end else begin : gen_blk11_else

    // --------------------------------------------------
    // Shift Register Occupancy Bits
    //
    // Consider a 4-deep FIFO with 2 entries: 0011
    // On a read and write, do not modify the bits.
    // On a write, left-shift the bits to get 0111.
    // On a read, right-shift the bits to get 0001.
    //
    // Also, on a write we set bit0 (the head), while
    // clearing the tail on a read.
    // --------------------------------------------------
        always @(posedge clk or posedge reset) begin
            if (reset) begin
                mem_used[0] <= 0;
            end 
            else begin
                if (write ^ read) begin
                    if (write)
                        mem_used[0] <= 1;
                    else if (read) begin
                        if (DEPTH > 1)
                            mem_used[0] <= mem_used[1];
                        else
                            mem_used[0] <= 0;
                    end    
                end
            end
        end

        if (DEPTH > 1) begin : gen_blk12
            always @(posedge clk or posedge reset) begin
                if (reset) begin
                    mem_used[DEPTH-1] <= 0;
                end
                else begin 
                    if (write ^ read) begin            
                        mem_used[DEPTH-1] <= 0;
                        if (write)
                            mem_used[DEPTH-1] <= mem_used[DEPTH-2];
                    end
                end
            end
          end
     
        for (i = 1; i < DEPTH-1; i = i + 1) begin : storage_logic
            always @(posedge clk, posedge reset) begin
                if (reset) begin
                    mem_used[i] <= 0;
                end 
                else begin
                    if (write ^ read) begin
                        if (write)
                            mem_used[i] <= mem_used[i-1];
                        else if (read)
                            mem_used[i] <= mem_used[i+1];     
                    end
                end
            end
        end
     
    end
    endgenerate


    // --------------------------------------------------
    // Memory FIFO Status Management
    //
    // Generates the full and empty signals from the
    // pointers. The FIFO is full when the next write 
    // pointer will be equal to the read pointer after
    // a write. Reading from a FIFO clears full.
    //
    // The FIFO is empty when the next read pointer will
    // be equal to the write pointer after a read. Writing
    // to a FIFO clears empty.
    //
    // A simultaneous read and write must not change any of 
    // the empty or full flags unless there is a drop on error event.
    // --------------------------------------------------
    generate if (USE_MEMORY_BLOCKS == 1) begin : gen_blk13

        always @* begin
            next_full = full;
            next_empty = empty;
     
            if (read && !write) begin
                next_full = 1'b0;
     
                if (incremented_rd_ptr == wr_ptr)
                    next_empty = 1'b1;
            end
            
            if (write && !read) begin
                if (!drop_on_error)
                  next_empty = 1'b0;
                else if (curr_sop_ptr == rd_ptr)   // drop on error and only 1 pkt in fifo
                  next_empty = 1'b1;
     
                if (incremented_wr_ptr == rd_ptr && !drop_on_error)
                    next_full = 1'b1;
            end

            if (write && read && drop_on_error) begin
                if (curr_sop_ptr == next_rd_ptr)
                  next_empty = 1'b1;
            end
        end
     
        always @(posedge clk or posedge reset) begin
            if (reset) begin
                empty <= 1;
                full  <= 0;
            end
            else begin 
                empty <= next_empty;
                full  <= next_full;
            end
        end

    end else begin : gen_blk13_else
    // --------------------------------------------------
    // Register FIFO Status Management
    //
    // Full when the tail occupancy bit is 1. Empty when
    // the head occupancy bit is 0.
    // --------------------------------------------------
        always @* begin
            full  = mem_used[DEPTH-1];
            empty = !mem_used[0];

            // ------------------------------------------
            // For a single slot FIFO, reading clears the
            // full status immediately.
            // ------------------------------------------
            if (DEPTH == 1)
                full = mem_used[0] && !read;

            internal_out_payload = mem[0];

            // ------------------------------------------
            // Writes clear empty immediately for lookahead modes.
            // Note that we use in_valid instead of write to avoid
            // combinational loops (in lookahead mode, qualifying
            // with in_ready is meaningless).
            //
            // In a 1-deep FIFO, a possible combinational loop runs
            // from write -> out_valid -> out_ready -> write
            // ------------------------------------------
            if (EMPTY_LATENCY == 0) begin
                empty = !mem_used[0] && !in_valid;

                if (!mem_used[0] && in_valid)
                    internal_out_payload = in_payload;
            end
        end

    end
    endgenerate

    // --------------------------------------------------
    // Avalon-ST Signals
    //
    // The in_ready signal is straightforward. 
    //
    // To match memory latency when empty latency > 1, 
    // out_valid assertions must be delayed by one clock
    // cycle.
    //
    // Note: out_valid deassertions must not be delayed or 
    // the FIFO will underflow.
    // --------------------------------------------------
    assign in_ready = !full;
    assign internal_out_ready = out_ready || !out_valid;

    generate if (EMPTY_LATENCY > 1) begin : gen_blk14
        always @(posedge clk or posedge reset) begin
            if (reset)
                internal_out_valid <= 0;
            else begin
                internal_out_valid <= !empty & ok_to_forward & ~drop_on_error;

                if (read) begin
                    if (incremented_rd_ptr == wr_ptr)
                        internal_out_valid <= 1'b0;
                end
            end
        end
    end else begin : gen_blk14_else
        always @* begin
            internal_out_valid = !empty & ok_to_forward;
        end
    end
    endgenerate

    // --------------------------------------------------
    // Single Output Pipeline Stage
    //
    // This output pipeline stage is enabled if the FIFO's 
    // empty latency is set to 3 (default). It is disabled
    // for all other allowed latencies.
    //
    // Reason: The memory outputs are unregistered, so we have to
    // register the output or fmax will drop if combinatorial
    // logic is present on the output datapath.
    // 
    // Q: The Avalon-ST spec says that I have to register my outputs
    //    But isn't the memory counted as a register?
    // A: The path from the address lookup to the memory output is
    //    slow. Registering the memory outputs is a good idea. 
    //
    // The registers get packed into the memory by the fitter
    // which means minimal resources are consumed (the result
    // is a altsyncram with registered outputs, available on 
    // all modern Altera devices). 
    //
    // This output stage acts as an extra slot in the FIFO, 
    // and complicates the fill level.
    // --------------------------------------------------
    generate if (EMPTY_LATENCY == 3) begin : gen_blk15
        always @(posedge clk or posedge reset) begin
            if (reset) begin
                out_valid   <= 0;
                out_payload <= 0;
            end
            else begin
                if (internal_out_ready) begin
                    out_valid   <= internal_out_valid & ok_to_forward;
                    out_payload <= internal_out_payload;
                end
            end
        end
    end
    else begin : gen_blk15_else
        always @* begin
            out_valid   = internal_out_valid;
            out_payload = internal_out_payload;
        end
    end
    endgenerate

    // --------------------------------------------------
    // Fill Level
    //
    // The fill level is calculated from the next write
    // and read pointers to avoid unnecessary latency
    // and logic.
    //
    // However, if the store-and-forward mode of the FIFO
    // is enabled, the fill level is an up-down counter
    // for fmax optimization reasons.
    //
    // If the output pipeline is enabled, the fill level 
    // must account for it, or we'll always be off by one.
    // This may, or may not be important depending on the
    // application.
    //
    // For now, we'll always calculate the exact fill level
    // at the cost of an extra adder when the output stage
    // is enabled.
    // --------------------------------------------------
    generate if (USE_FILL_LEVEL) begin : gen_blk16
        wire [31:0] depth32;
        assign depth32 = DEPTH;

        if (USE_STORE_FORWARD) begin

            reg [ADDR_WIDTH : 0] curr_packet_len_less_one;
            
            // --------------------------------------------------
            // We only drop on endofpacket. As long as we don't add to the fill
            // level on the dropped endofpacket cycle, we can simply subtract
            // (packet length - 1) from the fill level for dropped packets.
            // --------------------------------------------------
            always @(posedge clk or posedge reset) begin
                if (reset) begin
                    curr_packet_len_less_one <= 0;
                end else begin
                    if (write) begin
                        curr_packet_len_less_one <= curr_packet_len_less_one + 1'b1;
                        if (in_endofpacket)
                            curr_packet_len_less_one <= 0;
                    end
                end
            end

            always @(posedge clk or posedge reset) begin
                if (reset) begin
                    fifo_fill_level <= 0;
                end else if (drop_on_error) begin
                    fifo_fill_level <= fifo_fill_level - curr_packet_len_less_one;
                    if (read)
                        fifo_fill_level <= fifo_fill_level - curr_packet_len_less_one - 1'b1;
                end else if (write && !read) begin
                    fifo_fill_level <= fifo_fill_level + 1'b1;
                end else if (read && !write) begin
                    fifo_fill_level <= fifo_fill_level - 1'b1;
                end
            end

        end else begin

            always @(posedge clk or posedge reset) begin
                if (reset) 
                    fifo_fill_level <= 0;
                else if (next_full & !drop_on_error)
                    fifo_fill_level <= depth32[ADDR_WIDTH:0];
                else begin
                    fifo_fill_level[ADDR_WIDTH]     <= 1'b0;
                    fifo_fill_level[ADDR_WIDTH-1 : 0] <= next_wr_ptr - next_rd_ptr;
                end
            end

        end

        always @* begin
            fill_level = fifo_fill_level;

            if (EMPTY_LATENCY == 3)
                fill_level = fifo_fill_level + {{ADDR_WIDTH{1'b0}}, out_valid};
        end
    end
    else begin : gen_blk16_else
        always @* begin
            fill_level = 0;
        end  
    end
    endgenerate

    generate if (USE_ALMOST_FULL_IF) begin : gen_blk17
      assign almost_full_data = (fill_level >= almost_full_threshold);
    end
    else
      assign almost_full_data = 0;
    endgenerate

    generate if (USE_ALMOST_EMPTY_IF) begin : gen_blk18
      assign almost_empty_data = (fill_level <= almost_empty_threshold);
    end
    else
      assign almost_empty_data = 0;
    endgenerate

    // --------------------------------------------------
    // Avalon-MM Status & Control Connection Point
    //
    // Register map:
    //
    // | Addr   | RW |     31 - 0      |
    // |  0     | R  |   Fill level    |
    //
    // The registering of this connection point means
    // that there is a cycle of latency between 
    // reads/writes and the updating of the fill level.
    // --------------------------------------------------
    generate if (USE_STORE_FORWARD) begin : gen_blk19
    assign max_fifo_size = FIFO_DEPTH - 1;
      always @(posedge clk or posedge reset) begin
          if (reset) begin
              almost_full_threshold  <= max_fifo_size[23 : 0];
              almost_empty_threshold <= 0;
              cut_through_threshold  <= 0;
              drop_on_error_en       <= 0;
              csr_readdata           <= 0;
              pkt_mode               <= 1'b1;
          end
          else begin
              if (csr_read) begin
                csr_readdata <= 32'b0;
                if (csr_address == 5)
                    csr_readdata <= {31'b0, drop_on_error_en};
                else if (csr_address == 4)
                    csr_readdata <= {8'b0, cut_through_threshold};
                else if (csr_address == 3)
                    csr_readdata <= {8'b0, almost_empty_threshold};
                else if (csr_address == 2)
                    csr_readdata <= {8'b0, almost_full_threshold};
                else if (csr_address == 0)
                    csr_readdata <= {{(31 - ADDR_WIDTH){1'b0}}, fill_level};
             end
             else if (csr_write) begin
               if(csr_address == 3'b101)
                   drop_on_error_en       <= csr_writedata[0];
               else if(csr_address == 3'b100) begin
                   cut_through_threshold  <= csr_writedata[23:0];
                   pkt_mode <= (csr_writedata[23:0] == 0);
               end
               else if(csr_address == 3'b011)
                    almost_empty_threshold <= csr_writedata[23:0];
               else if(csr_address == 3'b010)
                  almost_full_threshold  <= csr_writedata[23:0];
             end     
          end
      end
    end
    else if (USE_ALMOST_FULL_IF || USE_ALMOST_EMPTY_IF) begin : gen_blk19_else1
    assign max_fifo_size = FIFO_DEPTH - 1;
      always @(posedge clk or posedge reset) begin
          if (reset) begin
              almost_full_threshold  <= max_fifo_size[23 : 0];
              almost_empty_threshold <= 0;
              csr_readdata           <= 0;
          end
          else begin
             if (csr_read) begin
                csr_readdata <= 32'b0;
                if (csr_address == 3)
                    csr_readdata <= {8'b0, almost_empty_threshold};
                else if (csr_address == 2)
                    csr_readdata <= {8'b0, almost_full_threshold};
                else if (csr_address == 0)
                    csr_readdata <= {{(31 - ADDR_WIDTH){1'b0}}, fill_level};
             end
             else if (csr_write) begin
               if(csr_address == 3'b011)
                   almost_empty_threshold <= csr_writedata[23:0];
               else if(csr_address == 3'b010)
                  almost_full_threshold  <= csr_writedata[23:0];
             end       
          end
      end
    end
    else begin : gen_blk19_else2
      always @(posedge clk or posedge reset) begin
          if (reset) begin
              csr_readdata <= 0;
          end
          else if (csr_read) begin
              csr_readdata <= 0;

              if (csr_address == 0) 
                  csr_readdata <= {{(31 - ADDR_WIDTH){1'b0}}, fill_level};
          end
      end
    end
    endgenerate

    // --------------------------------------------------
    // Store and forward logic
    // --------------------------------------------------
    // if the fifo gets full before the entire packet or the
    // cut-threshold condition is met then start sending out
    // data in order to avoid dead-lock situation

    generate if (USE_STORE_FORWARD) begin : gen_blk20
      assign wait_for_threshold   = (fifo_fill_level_lt_cut_through_threshold) & wait_for_pkt ;
      assign wait_for_pkt         = pkt_cnt_eq_zero  | (pkt_cnt_eq_one  & out_pkt_leave);
      assign ok_to_forward        = (pkt_mode ? (~wait_for_pkt | ~pkt_has_started) : 
                                     ~wait_for_threshold) | fifo_too_small_r;
      assign in_pkt_eop_arrive    = in_valid & in_ready & in_endofpacket;
      assign in_pkt_start         = in_valid & in_ready & in_startofpacket;
      assign in_pkt_error         = in_valid & in_ready & |in_error;
      assign out_pkt_sop_leave    = out_valid & out_ready & out_startofpacket;
      assign out_pkt_leave        = out_valid & out_ready & out_endofpacket;
      assign fifo_too_small       = (pkt_mode ? wait_for_pkt : wait_for_threshold) & full & out_ready;

      // count packets coming and going into the fifo
      always @(posedge clk or posedge reset) begin
        if (reset) begin
          pkt_cnt           <= 0;
          pkt_has_started   <= 0;
          sop_has_left_fifo <= 0;
          fifo_too_small_r  <= 0;
          pkt_cnt_eq_zero   <= 1'b1;
          pkt_cnt_eq_one    <= 1'b0;
          fifo_fill_level_lt_cut_through_threshold <= 1'b1;
        end
        else begin
          fifo_fill_level_lt_cut_through_threshold <= fifo_fill_level < cut_through_threshold;
          fifo_too_small_r <= fifo_too_small;

          if( in_pkt_eop_arrive )
            sop_has_left_fifo <= 1'b0;
          else if (out_pkt_sop_leave & pkt_cnt_eq_zero )
            sop_has_left_fifo <= 1'b1;

          if (in_pkt_eop_arrive & ~out_pkt_leave & ~drop_on_error ) begin
            pkt_cnt <= pkt_cnt + 1'b1;
            pkt_cnt_eq_zero <= 0;
            if (pkt_cnt == 0)
              pkt_cnt_eq_one <= 1'b1;
            else
              pkt_cnt_eq_one <= 1'b0;
          end
          else if((~in_pkt_eop_arrive | drop_on_error) & out_pkt_leave) begin
            pkt_cnt <= pkt_cnt - 1'b1;
            if (pkt_cnt == 1) 
              pkt_cnt_eq_zero <= 1'b1;
            else
              pkt_cnt_eq_zero <= 1'b0;
            if (pkt_cnt == 2) 
              pkt_cnt_eq_one <= 1'b1;
            else
              pkt_cnt_eq_one <= 1'b0;
          end

          if (in_pkt_start)
            pkt_has_started <= 1'b1;
          else if (in_pkt_eop_arrive)
            pkt_has_started <= 1'b0;
        end
      end

      // drop on error logic
      always @(posedge clk or posedge reset) begin
        if (reset) begin
          sop_ptr <= 0;
          error_in_pkt <= 0;
        end
        else begin
          // save the location of the SOP
          if ( in_pkt_start ) 
            sop_ptr <= wr_ptr;

          // remember if error in pkt
          // log error only if packet has already started
          if (in_pkt_eop_arrive)
            error_in_pkt <= 1'b0;
          else if ( in_pkt_error & (pkt_has_started | in_pkt_start))
            error_in_pkt <= 1'b1;
        end
      end

      assign drop_on_error = drop_on_error_en & (error_in_pkt | in_pkt_error) & in_pkt_eop_arrive & 
                            ~sop_has_left_fifo & ~(out_pkt_sop_leave & pkt_cnt_eq_zero);

      assign curr_sop_ptr = (write && in_startofpacket && in_endofpacket) ? wr_ptr : sop_ptr;

    end
    else begin : gen_blk20_else
      assign ok_to_forward = 1'b1;
      assign drop_on_error = 1'b0;
      if (ADDR_WIDTH <= 1)
        assign curr_sop_ptr = 1'b0;
      else
        assign curr_sop_ptr = {ADDR_WIDTH - 1 { 1'b0 }};
    end
    endgenerate


    // --------------------------------------------------
    // Calculates the log2ceil of the input value
    // --------------------------------------------------
    function integer log2ceil;
        input integer val;
        reg[31:0] i;

        begin
            i = 1;
            log2ceil = 0;

            while (i < val) begin
                log2ceil = log2ceil + 1;
                i = i[30:0] << 1;
            end
        end
    endfunction

endmodule",895,4
32,8,0,False,False,"module axi_protocol_converter_v2_1_r_axi3_conv #
  (
   parameter C_FAMILY                            = ""none"",
   parameter integer C_AXI_ID_WIDTH              = 1,
   parameter integer C_AXI_ADDR_WIDTH            = 32,
   parameter integer C_AXI_DATA_WIDTH            = 32,
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
   parameter integer C_AXI_RUSER_WIDTH           = 1,
   parameter integer C_SUPPORT_SPLITTING              = 1,
                       // Implement transaction splitting logic.
                       // Disabled whan all connected masters are AXI3 and have same or narrower data width.
   parameter integer C_SUPPORT_BURSTS                 = 1
                       // Disabled when all connected masters are AxiLite,
                       //   allowing logic to be simplified.
   )
  (
   // System Signals
   input wire ACLK,
   input wire ARESET,

   // Command Interface
   input  wire                              cmd_valid,
   input  wire                              cmd_split,
   output wire                              cmd_ready,
   
   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]    S_AXI_RID,
   output wire [C_AXI_DATA_WIDTH-1:0]  S_AXI_RDATA,
   output wire [2-1:0]                 S_AXI_RRESP,
   output wire                         S_AXI_RLAST,
   output wire [C_AXI_RUSER_WIDTH-1:0] S_AXI_RUSER,
   output wire                         S_AXI_RVALID,
   input  wire                         S_AXI_RREADY,
   
   // Master Interface Read Data Ports
   input  wire [C_AXI_ID_WIDTH-1:0]    M_AXI_RID,
   input  wire [C_AXI_DATA_WIDTH-1:0]  M_AXI_RDATA,
   input  wire [2-1:0]                 M_AXI_RRESP,
   input  wire                         M_AXI_RLAST,
   input  wire [C_AXI_RUSER_WIDTH-1:0] M_AXI_RUSER,
   input  wire                         M_AXI_RVALID,
   output wire                         M_AXI_RREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Constants for packing levels.
  localparam [2-1:0] C_RESP_OKAY        = 2'b00;
  localparam [2-1:0] C_RESP_EXOKAY      = 2'b01;
  localparam [2-1:0] C_RESP_SLVERROR    = 2'b10;
  localparam [2-1:0] C_RESP_DECERR      = 2'b11;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Throttling help signals.
  wire                            cmd_ready_i;
  wire                            pop_si_data;
  wire                            si_stalling;
  
  // Internal MI-side control signals.
  wire                            M_AXI_RREADY_I;
   
  // Internal signals for SI-side.
  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_RID_I;
  wire [C_AXI_DATA_WIDTH-1:0]     S_AXI_RDATA_I;
  wire [2-1:0]                    S_AXI_RRESP_I;
  wire                            S_AXI_RLAST_I;
  wire [C_AXI_RUSER_WIDTH-1:0]    S_AXI_RUSER_I;
  wire                            S_AXI_RVALID_I;
  wire                            S_AXI_RREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle interface handshaking:
  //
  // Forward data from MI-Side to SI-Side while a command is available. When
  // the transaction has completed the command is popped from the Command FIFO.
  // 
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Pop word from SI-side.
  assign M_AXI_RREADY_I = ~si_stalling & cmd_valid;
  assign M_AXI_RREADY   = M_AXI_RREADY_I;
  
  // Indicate when there is data available @ SI-side.
  assign S_AXI_RVALID_I = M_AXI_RVALID & cmd_valid;
  
  // Get SI-side data.
  assign pop_si_data    = S_AXI_RVALID_I & S_AXI_RREADY_I;
  
  // Signal that the command is done (so that it can be poped from command queue).
  assign cmd_ready_i    = cmd_valid & pop_si_data & M_AXI_RLAST;
  assign cmd_ready      = cmd_ready_i;
  
  // Detect when MI-side is stalling.
  assign si_stalling    = S_AXI_RVALID_I & ~S_AXI_RREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Simple AXI signal forwarding:
  // 
  // USER, ID, DATA and RRESP passes through untouched.
  // 
  // LAST has to be filtered to remove any intermediate LAST (due to split 
  // trasactions). LAST is only removed for the first parts of a split 
  // transaction. When splitting is unsupported is the LAST filtering completely
  // completely removed.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Calculate last, i.e. mask from split transactions.
  assign S_AXI_RLAST_I  = M_AXI_RLAST & 
                          ( ~cmd_split | ( C_SUPPORT_SPLITTING == 0 ) );
  
  // Data is passed through.
  assign S_AXI_RID_I    = M_AXI_RID;
  assign S_AXI_RUSER_I  = M_AXI_RUSER;
  assign S_AXI_RDATA_I  = M_AXI_RDATA;
  assign S_AXI_RRESP_I  = M_AXI_RRESP;
      
  
  /////////////////////////////////////////////////////////////////////////////
  // SI-side output handling
  // 
  /////////////////////////////////////////////////////////////////////////////
// TODO: registered?  
  assign S_AXI_RREADY_I = S_AXI_RREADY;
  assign S_AXI_RVALID   = S_AXI_RVALID_I;
  assign S_AXI_RID      = S_AXI_RID_I;
  assign S_AXI_RDATA    = S_AXI_RDATA_I;
  assign S_AXI_RRESP    = S_AXI_RRESP_I;
  assign S_AXI_RLAST    = S_AXI_RLAST_I;
  assign S_AXI_RUSER    = S_AXI_RUSER_I;
  
  
endmodule",153,5
34,64,0,False,False,"module e0 (x, y);

	input [31:0] x;
	output [31:0] y;

	assign y = {x[1:0],x[31:2]} ^ {x[12:0],x[31:13]} ^ {x[21:0],x[31:22]};

endmodule",8,6
34,64,0,False,False,"module e1 (x, y);

	input [31:0] x;
	output [31:0] y;

	assign y = {x[5:0],x[31:6]} ^ {x[10:0],x[31:11]} ^ {x[24:0],x[31:25]};

endmodule",8,7
4,32,0,False,False,"module ch (x, y, z, o);

	input [31:0] x, y, z;
	output [31:0] o;

	assign o = z ^ (x & (y ^ z));

endmodule",8,8
100,128,0,False,False,"module maj (x, y, z, o);

	input [31:0] x, y, z;
	output [31:0] o;

	assign o = (x & y) | (z & (x | y));

endmodule",8,9
31,61,0,False,False,"module s0 (x, y);

	input [31:0] x;
	output [31:0] y;

	assign y[31:29] = x[6:4] ^ x[17:15];
	assign y[28:0] = {x[3:0], x[31:7]} ^ {x[14:0],x[31:18]} ^ x[31:3];

endmodule",9,10
24,54,0,False,False,"module s1 (x, y);

        input [31:0] x;
        output [31:0] y;

        assign y[31:22] = x[16:7] ^ x[18:9];
        assign y[21:0] = {x[6:0],x[31:17]} ^ {x[8:0],x[31:19]} ^ x[31:10];

endmodule",9,11
68,62,0,False,False,"module axi_protocol_converter_v2_1_b2s_rd_cmd_fsm (
///////////////////////////////////////////////////////////////////////////////
// Port Declarations
///////////////////////////////////////////////////////////////////////////////
  input  wire                                 clk           ,
  input  wire                                 reset         ,
  output wire                                 s_arready       ,
  input  wire                                 s_arvalid       ,
  input  wire [7:0]                           s_arlen         ,
  output wire                                 m_arvalid        ,
  input  wire                                 m_arready      ,
  // signal to increment to the next mc transaction
  output wire                                 next          ,
  // signal to the fsm there is another transaction required
  input  wire                                 next_pending  ,
  // Write Data portion has completed or Read FIFO has a slot available (not
  // full)
  input  wire                                 data_ready    ,
  // status signal for w_channel when command is written.
  output wire                                 a_push        ,
  output wire                                 r_push
);

////////////////////////////////////////////////////////////////////////////////
// Local parameters
////////////////////////////////////////////////////////////////////////////////
// States
localparam SM_IDLE                = 2'b00;
localparam SM_CMD_EN              = 2'b01;
localparam SM_CMD_ACCEPTED        = 2'b10;
localparam SM_DONE                = 2'b11;

////////////////////////////////////////////////////////////////////////////////
// Wires/Reg declarations
////////////////////////////////////////////////////////////////////////////////
reg [1:0]       state;
// synthesis attribute MAX_FANOUT of state is 20;
reg [1:0]       state_r1;
reg [1:0]       next_state;
reg [7:0]       s_arlen_r;

////////////////////////////////////////////////////////////////////////////////
// BEGIN RTL
///////////////////////////////////////////////////////////////////////////////


// register for timing
always @(posedge clk) begin
  if (reset) begin
    state <= SM_IDLE;
    state_r1 <= SM_IDLE;
    s_arlen_r  <= 0;
  end else begin
    state <= next_state;
    state_r1 <= state;
    s_arlen_r  <= s_arlen;
  end
end

// Next state transitions.
always @( * ) begin
  next_state = state;
  case (state)
    SM_IDLE:
      if (s_arvalid & data_ready) begin
        next_state = SM_CMD_EN;
      end else begin
        next_state = state;
      end
    SM_CMD_EN:
    ///////////////////////////////////////////////////////////////////
    // Drive m_arvalid downstream in this state
      ///////////////////////////////////////////////////////////////////
      //If there is no fifo space
      if (~data_ready & m_arready & next_pending) begin
        ///////////////////////////////////////////////////////////////////
        //There is more to do, wait until data space is available drop valid
        next_state = SM_CMD_ACCEPTED;
      end else if (m_arready & ~next_pending)begin
         next_state = SM_DONE;
      end else if (m_arready & next_pending) begin
        next_state = SM_CMD_EN;
      end else begin
        next_state = state;
      end

    SM_CMD_ACCEPTED:
      if (data_ready) begin
        next_state = SM_CMD_EN;
      end else begin
        next_state = state;
      end

    SM_DONE:
        next_state = SM_IDLE;

      default:
        next_state = SM_IDLE;
  endcase
end

// Assign outputs based on current state.

assign m_arvalid  = (state == SM_CMD_EN);
assign next    = m_arready && (state == SM_CMD_EN);
assign         r_push  = next;
assign a_push  = (state == SM_IDLE);
assign s_arready = ((state == SM_CMD_EN) || (state == SM_DONE))  && (next_state == SM_IDLE);

endmodule",110,16
19,20,0,False,False,"module mux(opA,opB,sum,dsp_sel,out);
	input [3:0] opA,opB;
	input [4:0] sum;
	input [1:0] dsp_sel;
	output [3:0] out;
	
	reg cout;
	
	always @ (sum)
		begin
			if (sum[4] == 1)
				cout <= 4'b0001;
			else
				cout <= 4'b0000;
		end
	
	reg out;
	
	always @(dsp_sel,sum,cout,opB,opA)
		begin
			if (dsp_sel == 2'b00)
				out <= sum[3:0];
			else if (dsp_sel == 2'b01)
				out <= cout;
			else if (dsp_sel == 2'b10)
				out <= opB;
			else if (dsp_sel == 2'b11)
				out <= opA;
		end

endmodule",31,18
105,144,0,False,False,"module quad(clk, A, B, Z, zr, out);
parameter W=14;
input clk, A, B, Z, zr;
reg [(W-1):0] c, i; reg zl;
output [2*W:0] out = { zl, i, c };
// reg [(W-1):0] c, i; reg zl;

reg [2:0] Ad, Bd;
reg [2:0] Zc;
always @(posedge clk) Ad <= {Ad[1:0], A};
always @(posedge clk) Bd <= {Bd[1:0], B};

wire good_one = &Zc;
wire good_zero = ~|Zc;
reg last_good;

wire index_pulse = good_one && ! last_good;

wire count_enable = Ad[1] ^ Ad[2] ^ Bd[1] ^ Bd[2];
wire count_direction = Ad[1] ^ Bd[2];

always @(posedge clk)
begin
    if(Z && !good_one) Zc <= Zc + 2'b1;
    else if(!good_zero) Zc <= Zc - 2'b1;
    if(good_one) last_good <= 1;
    else if(good_zero) last_good <= 0;
    if(count_enable)
    begin
        if(count_direction) c <= c + 1'd1;
        else c <= c - 1'd1;
    end 
    if(index_pulse) begin
        i <= c;
        zl <= 1;
    end else if(zr) begin
        zl <= 0;
    end
end
endmodule",40,21
72,67,0,False,False,"module axi_protocol_converter_v2_1_b2s_wr_cmd_fsm (
///////////////////////////////////////////////////////////////////////////////
// Port Declarations
///////////////////////////////////////////////////////////////////////////////
  input  wire                                 clk           ,
  input  wire                                 reset         ,
  output wire                                 s_awready       ,
  input  wire                                 s_awvalid       ,
  output wire                                 m_awvalid        ,
  input  wire                                 m_awready      ,
  // signal to increment to the next mc transaction
  output wire                                 next          ,
  // signal to the fsm there is another transaction required
  input  wire                                 next_pending  ,
  // Write Data portion has completed or Read FIFO has a slot available (not
  // full)
  output wire                                 b_push        ,
  input  wire                                 b_full        ,
  output wire                                 a_push
);

////////////////////////////////////////////////////////////////////////////////
// Local parameters
////////////////////////////////////////////////////////////////////////////////
// States
localparam SM_IDLE                = 2'b00;
localparam SM_CMD_EN              = 2'b01;
localparam SM_CMD_ACCEPTED        = 2'b10;
localparam SM_DONE_WAIT           = 2'b11;

////////////////////////////////////////////////////////////////////////////////
// Wires/Reg declarations
////////////////////////////////////////////////////////////////////////////////
reg [1:0]       state;
// synthesis attribute MAX_FANOUT of state is 20;
reg [1:0]       next_state;

////////////////////////////////////////////////////////////////////////////////
// BEGIN RTL
///////////////////////////////////////////////////////////////////////////////


always @(posedge clk) begin
  if (reset) begin
    state <= SM_IDLE;
  end else begin
    state <= next_state;
  end
end

// Next state transitions.
always @( * )
begin
  next_state = state;
  case (state)
    SM_IDLE:
      if (s_awvalid) begin
        next_state = SM_CMD_EN;
      end else
        next_state = state;

    SM_CMD_EN:
      if (m_awready & next_pending)
        next_state = SM_CMD_ACCEPTED;
      else if (m_awready & ~next_pending & b_full)
        next_state = SM_DONE_WAIT;
      else if (m_awready & ~next_pending & ~b_full)
        next_state = SM_IDLE;
      else
        next_state = state;

    SM_CMD_ACCEPTED:
      next_state = SM_CMD_EN;

    SM_DONE_WAIT:
      if (!b_full)
        next_state = SM_IDLE;
      else
        next_state = state;

      default:
        next_state = SM_IDLE;
  endcase
end

// Assign outputs based on current state.

assign m_awvalid  = (state == SM_CMD_EN);

assign next    = ((state == SM_CMD_ACCEPTED)
                 | (((state == SM_CMD_EN) | (state == SM_DONE_WAIT)) & (next_state == SM_IDLE))) ;

assign a_push  = (state == SM_IDLE);
assign s_awready = ((state == SM_CMD_EN) | (state == SM_DONE_WAIT)) & (next_state == SM_IDLE);
assign b_push  = ((state == SM_CMD_EN) | (state == SM_DONE_WAIT)) & (next_state == SM_IDLE);

endmodule",97,22
4,1,0,False,False,"module beh_vlog_muxf7_v8_2 (O, I0, I1, S);

    output O;
    reg    O;

    input  I0, I1, S;

	always @(I0 or I1 or S) 
	    if (S)
		O = I1;
	    else
		O = I0;
endmodule",13,25
4,1,0,False,False,"module beh_vlog_ff_clr_v8_2 (Q, C, CLR, D);
  parameter INIT = 0;
localparam FLOP_DELAY = 100;
    output Q;

    input  C, CLR, D;

    reg Q;

    initial Q= 1'b0;

    always @(posedge C )
      if (CLR)
	Q<= 1'b0;
      else
	Q<= #FLOP_DELAY D;


endmodule",19,26
4,1,0,False,False,"module beh_vlog_ff_pre_v8_2 (Q, C, D, PRE);

  parameter INIT = 0;
localparam FLOP_DELAY = 100;
    output Q;
    input  C, D, PRE;

    reg Q;

    initial Q= 1'b0;

    always @(posedge C )
      if (PRE)
           Q <= 1'b1;
      else
	   Q <= #FLOP_DELAY D;

endmodule",18,27
5,1,0,False,False,"module beh_vlog_ff_ce_clr_v8_2 (Q, C, CE, CLR, D);

  parameter INIT = 0;
localparam FLOP_DELAY = 100;
    output Q;
    input  C, CE, CLR, D;

    reg Q;

    initial Q= 1'b0;
    always @(posedge C )
       if (CLR)
           Q <= 1'b0;
       else if (CE)
	   Q <= #FLOP_DELAY D;

endmodule",17,28
122,129,0,False,False,"module soc_design_Sys_Timer (
                              // inputs:
                               address,
                               chipselect,
                               clk,
                               reset_n,
                               write_n,
                               writedata,

                              // outputs:
                               irq,
                               readdata
                            )
;

  output           irq;
  output  [ 15: 0] readdata;
  input   [  2: 0] address;
  input            chipselect;
  input            clk;
  input            reset_n;
  input            write_n;
  input   [ 15: 0] writedata;

  wire             clk_en;
  wire             control_interrupt_enable;
  reg              control_register;
  wire             control_wr_strobe;
  reg              counter_is_running;
  wire             counter_is_zero;
  wire    [ 16: 0] counter_load_value;
  reg              delayed_unxcounter_is_zeroxx0;
  wire             do_start_counter;
  wire             do_stop_counter;
  reg              force_reload;
  reg     [ 16: 0] internal_counter;
  wire             irq;
  wire             period_h_wr_strobe;
  wire             period_l_wr_strobe;
  wire    [ 15: 0] read_mux_out;
  reg     [ 15: 0] readdata;
  wire             status_wr_strobe;
  wire             timeout_event;
  reg              timeout_occurred;
  assign clk_en = 1;
  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          internal_counter <= 17'h1869F;
      else if (counter_is_running || force_reload)
          if (counter_is_zero    || force_reload)
              internal_counter <= counter_load_value;
          else 
            internal_counter <= internal_counter - 1;
    end


  assign counter_is_zero = internal_counter == 0;
  assign counter_load_value = 17'h1869F;
  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          force_reload <= 0;
      else if (clk_en)
          force_reload <= period_h_wr_strobe || period_l_wr_strobe;
    end


  assign do_start_counter = 1;
  assign do_stop_counter = 0;
  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          counter_is_running <= 1'b0;
      else if (clk_en)
          if (do_start_counter)
              counter_is_running <= -1;
          else if (do_stop_counter)
              counter_is_running <= 0;
    end


  //delayed_unxcounter_is_zeroxx0, which is an e_register
  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          delayed_unxcounter_is_zeroxx0 <= 0;
      else if (clk_en)
          delayed_unxcounter_is_zeroxx0 <= counter_is_zero;
    end


  assign timeout_event = (counter_is_zero) & ~(delayed_unxcounter_is_zeroxx0);
  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          timeout_occurred <= 0;
      else if (clk_en)
          if (status_wr_strobe)
              timeout_occurred <= 0;
          else if (timeout_event)
              timeout_occurred <= -1;
    end


  assign irq = timeout_occurred && control_interrupt_enable;
  //s1, which is an e_avalon_slave
  assign read_mux_out = ({16 {(address == 1)}} & control_register) |
    ({16 {(address == 0)}} & {counter_is_running,
    timeout_occurred});

  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          readdata <= 0;
      else if (clk_en)
          readdata <= read_mux_out;
    end


  assign period_l_wr_strobe = chipselect && ~write_n && (address == 2);
  assign period_h_wr_strobe = chipselect && ~write_n && (address == 3);
  assign control_wr_strobe = chipselect && ~write_n && (address == 1);
  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          control_register <= 0;
      else if (control_wr_strobe)
          control_register <= writedata[0];
    end


  assign control_interrupt_enable = control_register;
  assign status_wr_strobe = chipselect && ~write_n && (address == 0);

endmodule",136,38
336,340,0,False,False,"module Priority_Codec_64(
    input wire [54:0]  Data_Dec_i,
    output reg [5:0] Data_Bin_o
    );

always @(Data_Dec_i)
	begin
	Data_Bin_o=6'b000000;
		if(~Data_Dec_i[54]) begin Data_Bin_o = 6'b000000;//0
		end else if(~Data_Dec_i[53]) begin Data_Bin_o = 6'b000001;//1
		end else if(~Data_Dec_i[52]) begin Data_Bin_o = 6'b000010;//2
		end else if(~Data_Dec_i[51]) begin Data_Bin_o = 6'b000011;//3
		end else if(~Data_Dec_i[50]) begin Data_Bin_o = 6'b000100;//4
		end else if(~Data_Dec_i[49]) begin Data_Bin_o = 6'b000101;//5
		end else if(~Data_Dec_i[48]) begin Data_Bin_o = 6'b000110;//6
		end else if(~Data_Dec_i[47]) begin Data_Bin_o = 6'b000111;//7
		end else if(~Data_Dec_i[46]) begin Data_Bin_o = 6'b001000;//8
		end else if(~Data_Dec_i[45]) begin Data_Bin_o = 6'b001001;//9
		end else if(~Data_Dec_i[44]) begin Data_Bin_o = 6'b001010;//10
		end else if(~Data_Dec_i[43]) begin Data_Bin_o = 6'b001011;//11
		end else if(~Data_Dec_i[42]) begin Data_Bin_o = 6'b001100;//12
		end else if(~Data_Dec_i[41]) begin Data_Bin_o = 6'b001101;//13
		end else if(~Data_Dec_i[40]) begin Data_Bin_o = 6'b001110;//14
		end else if(~Data_Dec_i[39]) begin Data_Bin_o = 6'b001111;//15
		end else if(~Data_Dec_i[38]) begin Data_Bin_o = 6'b010000;//16
		end else if(~Data_Dec_i[37]) begin Data_Bin_o = 6'b010001;//17
		end else if(~Data_Dec_i[36]) begin Data_Bin_o = 6'b010010;//18
		end else if(~Data_Dec_i[35]) begin Data_Bin_o = 6'b010011;//19
		end else if(~Data_Dec_i[34]) begin Data_Bin_o = 6'b010100;//20
		end else if(~Data_Dec_i[33]) begin Data_Bin_o = 6'b010101;//21
		end else if(~Data_Dec_i[32]) begin Data_Bin_o = 6'b010110;//22
		end else if(~Data_Dec_i[31]) begin Data_Bin_o = 6'b010111;//23
		end else if(~Data_Dec_i[30]) begin Data_Bin_o = 6'b011000;//24
		end else if(~Data_Dec_i[29]) begin Data_Bin_o = 6'b010101;//25
		end else if(~Data_Dec_i[28]) begin Data_Bin_o = 6'b010110;//26
		end else if(~Data_Dec_i[27]) begin Data_Bin_o = 6'b010111;//27
		end else if(~Data_Dec_i[26]) begin Data_Bin_o = 6'b011000;//28
		end else if(~Data_Dec_i[25]) begin Data_Bin_o = 6'b011001;//29
		end else if(~Data_Dec_i[24]) begin Data_Bin_o = 6'b011010;//30
		end else if(~Data_Dec_i[23]) begin Data_Bin_o = 6'b011011;//31
		end else if(~Data_Dec_i[22]) begin Data_Bin_o = 6'b011100;//32
		end else if(~Data_Dec_i[21]) begin Data_Bin_o = 6'b011101;//33
		end else if(~Data_Dec_i[20]) begin Data_Bin_o = 6'b011110;//34
		end else if(~Data_Dec_i[19]) begin Data_Bin_o = 6'b011111;//35
		end else if(~Data_Dec_i[18]) begin Data_Bin_o = 6'b100000;//36
		end else if(~Data_Dec_i[17]) begin Data_Bin_o = 6'b100001;//37
		end else if(~Data_Dec_i[16]) begin Data_Bin_o = 6'b100010;//38
		end else if(~Data_Dec_i[15]) begin Data_Bin_o = 6'b100011;//39
		end else if(~Data_Dec_i[14]) begin Data_Bin_o = 6'b100100;//40
		end else if(~Data_Dec_i[13]) begin Data_Bin_o = 6'b100101;//41
		end else if(~Data_Dec_i[12]) begin Data_Bin_o = 6'b100110;//42
		end else if(~Data_Dec_i[11]) begin Data_Bin_o = 6'b100111;//43
		end else if(~Data_Dec_i[10]) begin Data_Bin_o = 6'b101000;//44
		end else if(~Data_Dec_i[9]) begin Data_Bin_o = 6'b101001;//45
		end else if(~Data_Dec_i[8]) begin Data_Bin_o = 6'b101010;//46
		end else if(~Data_Dec_i[7]) begin Data_Bin_o = 6'b101011;//47
		end else if(~Data_Dec_i[6]) begin Data_Bin_o = 6'b101100;//48
		end else if(~Data_Dec_i[5]) begin Data_Bin_o = 6'b101101;//49
		end else if(~Data_Dec_i[4]) begin Data_Bin_o = 6'b101110;//50
		end else if(~Data_Dec_i[3]) begin Data_Bin_o = 6'b101111;//51
		end else if(~Data_Dec_i[2]) begin Data_Bin_o = 6'b110000;//52
		end else if(~Data_Dec_i[1]) begin Data_Bin_o = 6'b110001;//53
		end else if(~Data_Dec_i[0]) begin Data_Bin_o = 6'b110010;//54
		end else begin Data_Bin_o = 6'b000000;//zero value
		end		
	end
endmodule",67,43
4,1,0,False,False,"module beh_vlog_muxf7_v8_3 (O, I0, I1, S);

    output O;
    reg    O;

    input  I0, I1, S;

	always @(I0 or I1 or S) 
	    if (S)
		O = I1;
	    else
		O = I0;
endmodule",13,47
4,1,0,False,False,"module beh_vlog_ff_clr_v8_3 (Q, C, CLR, D);
  parameter INIT = 0;
localparam FLOP_DELAY = 100;
    output Q;

    input  C, CLR, D;

    reg Q;

    initial Q= 1'b0;

    always @(posedge C )
      if (CLR)
	Q<= 1'b0;
      else
	Q<= #FLOP_DELAY D;


endmodule",19,48
4,1,0,False,False,"module beh_vlog_ff_pre_v8_3 (Q, C, D, PRE);

  parameter INIT = 0;
localparam FLOP_DELAY = 100;
    output Q;
    input  C, D, PRE;

    reg Q;

    initial Q= 1'b0;

    always @(posedge C )
      if (PRE)
           Q <= 1'b1;
      else
	   Q <= #FLOP_DELAY D;

endmodule",18,49
5,1,0,False,False,"module beh_vlog_ff_ce_clr_v8_3 (Q, C, CE, CLR, D);

  parameter INIT = 0;
localparam FLOP_DELAY = 100;
    output Q;
    input  C, CE, CLR, D;

    reg Q;

    initial Q= 1'b0;
    always @(posedge C )
       if (CLR)
           Q <= 1'b0;
       else if (CE)
	   Q <= #FLOP_DELAY D;

endmodule",17,50
8,3,0,False,False,"module axi_data_fifo_v2_1_ndeep_srl #
  (
   parameter         C_FAMILY  = ""rtl"", // FPGA Family
   parameter         C_A_WIDTH = 1          // Address Width (>= 1)
   )
  (
   input  wire                 CLK, // Clock
   input  wire [C_A_WIDTH-1:0] A,   // Address
   input  wire                 CE,  // Clock Enable
   input  wire                 D,   // Input Data
   output wire                 Q    // Output Data
   );

  localparam integer P_SRLASIZE = 5;
  localparam integer P_SRLDEPTH = 32;
  localparam integer P_NUMSRLS  = (C_A_WIDTH>P_SRLASIZE) ? (2**(C_A_WIDTH-P_SRLASIZE)) : 1;
  localparam integer P_SHIFT_DEPTH  = 2**C_A_WIDTH;
  
  wire [P_NUMSRLS:0]   d_i;
  wire [P_NUMSRLS-1:0] q_i;
  wire [(C_A_WIDTH>P_SRLASIZE) ? (C_A_WIDTH-1) : (P_SRLASIZE-1) : 0] a_i;
  
  genvar i;
  
  // Instantiate SRLs in carry chain format
  assign d_i[0] = D;
  assign a_i = A;
  
  generate
					
    if (C_FAMILY == ""rtl"") begin : gen_rtl_shifter
      if (C_A_WIDTH <= P_SRLASIZE) begin : gen_inferred_srl
        reg [P_SRLDEPTH-1:0] shift_reg = {P_SRLDEPTH{1'b0}};
        always @(posedge CLK)
          if (CE)
            shift_reg <= {shift_reg[P_SRLDEPTH-2:0], D};
        assign Q = shift_reg[a_i];
      end else begin : gen_logic_shifter  // Very wasteful
        reg [P_SHIFT_DEPTH-1:0] shift_reg = {P_SHIFT_DEPTH{1'b0}};
        always @(posedge CLK)
          if (CE)
            shift_reg <= {shift_reg[P_SHIFT_DEPTH-2:0], D};
        assign Q = shift_reg[a_i];
      end
    end else begin : gen_primitive_shifter
      for (i=0;i<P_NUMSRLS;i=i+1) begin : gen_srls
        SRLC32E
          srl_inst
            (
             .CLK (CLK),
             .A   (a_i[P_SRLASIZE-1:0]),
             .CE  (CE),
             .D   (d_i[i]),
             .Q   (q_i[i]),
             .Q31 (d_i[i+1])
             );
      end
      
      if (C_A_WIDTH>P_SRLASIZE) begin : gen_srl_mux
        generic_baseblocks_v2_1_nto1_mux #
        (
          .C_RATIO         (2**(C_A_WIDTH-P_SRLASIZE)),
          .C_SEL_WIDTH     (C_A_WIDTH-P_SRLASIZE),
          .C_DATAOUT_WIDTH (1),
          .C_ONEHOT        (0)
        )
        srl_q_mux_inst
        (
          .SEL_ONEHOT ({2**(C_A_WIDTH-P_SRLASIZE){1'b0}}),
          .SEL        (a_i[C_A_WIDTH-1:P_SRLASIZE]),
          .IN         (q_i),
          .OUT        (Q)
        );
      end else begin : gen_no_srl_mux
        assign Q = q_i[0];
      end
    end
  endgenerate

endmodule",80,59
123,308,0,False,False,"module processing_system7_v5_5_trace_buffer #
  (
   parameter integer FIFO_SIZE = 128,
	parameter integer USE_TRACE_DATA_EDGE_DETECTOR = 0,
   parameter integer C_DELAY_CLKS = 12
   )
  (
   input wire TRACE_CLK,
   input wire RST,
   input wire TRACE_VALID_IN,
   input wire [3:0] TRACE_ATID_IN,
   input wire [31:0] TRACE_DATA_IN,
   output wire TRACE_VALID_OUT,
   output wire [3:0] TRACE_ATID_OUT,
   output wire [31:0] TRACE_DATA_OUT
  );

//------------------------------------------------------------
// Architecture section
//------------------------------------------------------------

// function called clogb2 that returns an integer which has the 
// value of the ceiling of the log base 2.

function integer clogb2 (input integer bit_depth);
 integer i;
 integer temp_log;
 begin
  temp_log = 0;
  for(i=bit_depth; i > 0; i = i>>1)
  clogb2 = temp_log;
  temp_log=temp_log+1;		
 end
endfunction

localparam DEPTH  = clogb2(FIFO_SIZE-1);

wire [31:0] reset_zeros;
reg  [31:0] trace_pedge; // write enable for FIFO
reg  [31:0] ti;
reg  [31:0] tom;

reg  [3:0] atid;

reg [31:0] trace_fifo [FIFO_SIZE-1:0];//Memory 

reg  [4:0]  dly_ctr;
reg  [DEPTH-1:0]  fifo_wp;
reg  [DEPTH-1:0]  fifo_rp;

reg         fifo_re;
wire        fifo_empty;
wire        fifo_full;
reg         fifo_full_reg;

assign reset_zeros = 32'h0;  


// Pipeline Stage for Traceport ATID ports
  always @(posedge TRACE_CLK) begin
    // process pedge_ti
    // rising clock edge
    if((RST == 1'b1)) begin
      atid <= reset_zeros;
    end
    else begin	 
      atid <= TRACE_ATID_IN;
	 end
  end

  assign TRACE_ATID_OUT = atid;
  
  /////////////////////////////////////////////
  // Generate FIFO data based on TRACE_VALID_IN
  /////////////////////////////////////////////
  generate
    if (USE_TRACE_DATA_EDGE_DETECTOR == 0) begin : gen_no_data_edge_detector
  /////////////////////////////////////////////
        
		  // memory update process
		  // Update memory when positive edge detected and FIFO not full
		  always @(posedge TRACE_CLK) begin
				if (TRACE_VALID_IN == 1'b1 && fifo_full_reg != 1'b1) begin
					trace_fifo[fifo_wp]  <= TRACE_DATA_IN;
				end
		  end

		  // fifo write pointer
		  always @(posedge TRACE_CLK) begin
				// process
			 if(RST == 1'b1) begin
				fifo_wp <= {DEPTH{1'b0}};
			 end
			 else if(TRACE_VALID_IN ) begin
				if(fifo_wp == (FIFO_SIZE - 1)) begin
				  if (fifo_empty) begin
					 fifo_wp <= {DEPTH{1'b0}};
				  end
				end
				else begin
				  fifo_wp <= fifo_wp + 1;
				end
			 end
		  end


  /////////////////////////////////////////////
  // Generate FIFO data based on data edge
  /////////////////////////////////////////////
    end else begin : gen_data_edge_detector
  /////////////////////////////////////////////


		  // purpose: check for pos edge on any trace input
		  always @(posedge TRACE_CLK) begin
			 // process pedge_ti
			 // rising clock edge
			 if((RST == 1'b1)) begin
				ti          <= reset_zeros;
				trace_pedge <= reset_zeros;
			 end
			 else begin
				ti          <= TRACE_DATA_IN;
				trace_pedge <= (~ti & TRACE_DATA_IN);
				//trace_pedge <= ((~ti ^ TRACE_DATA_IN)) &  ~ti;
				// posedge only
			 end
		  end
		  
		  // memory update process
		  // Update memory when positive edge detected and FIFO not full
		  always @(posedge TRACE_CLK) begin
			 if(|(trace_pedge)  == 1'b1 && fifo_full_reg != 1'b1) begin
				trace_fifo[fifo_wp]  <= trace_pedge;
			 end
		  end

		  // fifo write pointer
		  always @(posedge TRACE_CLK) begin
				// process
			 if(RST == 1'b1) begin
				fifo_wp <= {DEPTH{1'b0}};
			 end
			 else if(|(trace_pedge)  == 1'b1) begin
				if(fifo_wp == (FIFO_SIZE - 1)) begin
				  if (fifo_empty) begin
					 fifo_wp <= {DEPTH{1'b0}};
				  end
				end
				else begin
				  fifo_wp <= fifo_wp + 1;
				end
			 end
		  end


    end
  endgenerate


  always @(posedge TRACE_CLK) begin
    tom <= trace_fifo[fifo_rp] ;
  end


//  // fifo write pointer
//  always @(posedge TRACE_CLK) begin
//      // process
//    if(RST == 1'b1) begin
//      fifo_wp <= {DEPTH{1'b0}};
//    end
//    else if(|(trace_pedge)  == 1'b1) begin
//      if(fifo_wp == (FIFO_SIZE - 1)) begin
//        fifo_wp <= {DEPTH{1'b0}};
//      end
//      else begin
//        fifo_wp <= fifo_wp + 1;
//      end
//    end
//  end


  // fifo read pointer update
  always @(posedge TRACE_CLK) begin
    if(RST == 1'b1) begin
      fifo_rp <= {DEPTH{1'b0}};
      fifo_re <= 1'b0;
    end
    else if(fifo_empty != 1'b1 && dly_ctr == 5'b00000 && fifo_re == 1'b0) begin
      fifo_re <= 1'b1;
      if(fifo_rp == (FIFO_SIZE - 1)) begin
        fifo_rp <= {DEPTH{1'b0}};
      end
      else begin
        fifo_rp <= fifo_rp + 1;
      end
    end
    else begin
      fifo_re <= 1'b0;
    end
  end
  
  // delay counter update
  always @(posedge TRACE_CLK) begin
    if(RST == 1'b1) begin
      dly_ctr <= 5'h0;
    end
    else if (fifo_re == 1'b1) begin
      dly_ctr <= C_DELAY_CLKS-1;
    end
    else if(dly_ctr != 5'h0) begin
      dly_ctr <= dly_ctr - 1;
    end
  end

  // fifo empty update
  assign fifo_empty = (fifo_wp == fifo_rp) ? 1'b1 : 1'b0;

  // fifo full update
  assign fifo_full = (fifo_wp == FIFO_SIZE-1)? 1'b1 : 1'b0;

  always @(posedge TRACE_CLK) begin
    if(RST == 1'b1) begin
      fifo_full_reg <= 1'b0;
    end
    else if (fifo_empty) begin
      fifo_full_reg <= 1'b0;
	 end else begin	
      fifo_full_reg <= fifo_full;
    end
  end  
  
//  always @(posedge TRACE_CLK) begin
//    if(RST == 1'b1) begin
//      fifo_full_reg <= 1'b0;
//    end
//    else if ((fifo_wp == FIFO_SIZE-1) && (|(trace_pedge) == 1'b1)) begin
//      fifo_full_reg <= 1'b1;
//    end
//	 else begin
//        fifo_full_reg <= 1'b0;
//    end
//  end  
//  
  assign TRACE_DATA_OUT     = tom;
  
  assign TRACE_VALID_OUT    = fifo_re;  
  
  


endmodule",252,62
5,2,0,False,False,"module clockgate (clk, sen, ena, gatedclk);
   input	clk;
   input	sen;
   input	ena;
   output	gatedclk;

   reg		ena_b;
   wire gatedclk = clk & ena_b;

   // verilator lint_off COMBDLY
   always @(clk or ena or sen) begin
      if (~clk) begin
        ena_b <= ena | sen;
      end
      else begin
	 if ((clk^sen)===1'bX) ena_b <= 1'bX;
      end
   end
   // verilator lint_on COMBDLY

endmodule",21,68
49,33,0,False,False,"module processing_system7_v5_5_w_atc #
  (
   parameter         C_FAMILY                         = ""rtl"",
                       // FPGA Family. Current version: virtex6, spartan6 or later.
   parameter integer C_AXI_ID_WIDTH                   = 4,
                       // Width of all ID signals on SI and MI side of checker.
                       // Range: >= 1.
   parameter integer C_AXI_DATA_WIDTH                 = 64,
                       // Width of all DATA signals on SI and MI side of checker.
                       // Range: 64.
   parameter integer C_AXI_WUSER_WIDTH                = 1
                       // Width of AWUSER signals. 
                       // Range: >= 1.
   )
  (
   // Global Signals
   input  wire                                  ARESET,
   input  wire                                  ACLK,

   // Command Interface (In)
   input  wire                                  cmd_w_valid,
   input  wire                                  cmd_w_check,
   input  wire [C_AXI_ID_WIDTH-1:0]             cmd_w_id,
   output wire                                  cmd_w_ready,
   
   // Command Interface (Out)
   output wire                                  cmd_b_push,
   output wire                                  cmd_b_error,
   output reg  [C_AXI_ID_WIDTH-1:0]             cmd_b_id,
   input  wire                                  cmd_b_full,
   
   // Slave Interface Write Port
   input  wire [C_AXI_ID_WIDTH-1:0]             S_AXI_WID,
   input  wire [C_AXI_DATA_WIDTH-1:0]           S_AXI_WDATA,
   input  wire [C_AXI_DATA_WIDTH/8-1:0]         S_AXI_WSTRB,
   input  wire                                  S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,
   input  wire                                  S_AXI_WVALID,
   output wire                                  S_AXI_WREADY,

   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]             M_AXI_WID,
   output wire [C_AXI_DATA_WIDTH-1:0]           M_AXI_WDATA,
   output wire [C_AXI_DATA_WIDTH/8-1:0]         M_AXI_WSTRB,
   output wire                                  M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]          M_AXI_WUSER,
   output wire                                  M_AXI_WVALID,
   input  wire                                  M_AXI_WREADY
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Detecttion.
  wire                                any_strb_deasserted;
  wire                                incoming_strb_issue;
  reg                                 first_word;
  reg                                 strb_issue;
  
  // Data flow.
  wire                                data_pop;
  wire                                cmd_b_push_blocked;
  reg                                 cmd_b_push_i;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Detect error:
  //
  // Detect and accumulate error when a transaction shall be scanned for
  // potential issues.
  // Accumulation of error is restarted for each ne transaction. 
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Check stobe information
  assign any_strb_deasserted  = ( S_AXI_WSTRB != {C_AXI_DATA_WIDTH/8{1'b1}} );
  assign incoming_strb_issue  = cmd_w_valid & S_AXI_WVALID & cmd_w_check & any_strb_deasserted;
  
  // Keep track of first word in a transaction.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      first_word  <= 1'b1;
    end else if ( data_pop ) begin
      first_word  <= S_AXI_WLAST;
    end
  end
  
  // Keep track of error status.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      strb_issue  <= 1'b0;
      cmd_b_id    <= {C_AXI_ID_WIDTH{1'b0}};
    end else if ( data_pop ) begin
      if ( first_word ) begin
        strb_issue  <= incoming_strb_issue;
      end else begin
        strb_issue  <= incoming_strb_issue | strb_issue;
      end
      cmd_b_id    <= cmd_w_id;
    end
  end
  
  assign cmd_b_error  = strb_issue;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Control command queue to B:
  //
  // Push command to B queue when all data for the transaction has flowed  
  // through.
  // Delay pipelined command until there is room in the Queue.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Detect when data is popped.
  assign data_pop   = S_AXI_WVALID & M_AXI_WREADY & cmd_w_valid & ~cmd_b_full & ~cmd_b_push_blocked; 
  
  // Push command when last word in transfered (pipelined).
  always @ (posedge ACLK) begin
    if (ARESET) begin
      cmd_b_push_i  <= 1'b0;
    end else begin
      cmd_b_push_i  <= ( S_AXI_WLAST & data_pop ) | cmd_b_push_blocked;
    end
  end
  
  // Detect if pipelined push is blocked.
  assign cmd_b_push_blocked = cmd_b_push_i & cmd_b_full;
  
  // Assign output.
  assign cmd_b_push = cmd_b_push_i & ~cmd_b_full;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Transaction Throttling:
  //
  // Stall commands if FIFO is full or there is no valid command information 
  // from AW. 
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Propagate masked valid.
  assign M_AXI_WVALID   = S_AXI_WVALID & cmd_w_valid & ~cmd_b_full & ~cmd_b_push_blocked;
  
  // Return ready with push back.
  assign S_AXI_WREADY   = M_AXI_WREADY & cmd_w_valid & ~cmd_b_full & ~cmd_b_push_blocked;
  
  // End of burst.
  assign cmd_w_ready    = S_AXI_WVALID & M_AXI_WREADY & cmd_w_valid & ~cmd_b_full & ~cmd_b_push_blocked & S_AXI_WLAST;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Write propagation:
  //
  // All information is simply forwarded on from the SI- to MI-Side untouched.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // 1:1 mapping.
  assign M_AXI_WID      = S_AXI_WID;
  assign M_AXI_WDATA    = S_AXI_WDATA;
  assign M_AXI_WSTRB    = S_AXI_WSTRB;
  assign M_AXI_WLAST    = S_AXI_WLAST;
  assign M_AXI_WUSER    = S_AXI_WUSER;
  
  
endmodule",184,71
77,72,0,True,False,"module lo_simulate(
    pck0, ck_1356meg, ck_1356megb,
    pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4,
    adc_d, adc_clk,
    ssp_frame, ssp_din, ssp_dout, ssp_clk,
    cross_hi, cross_lo,
    dbg,
	 divisor
);
    input pck0, ck_1356meg, ck_1356megb;
    output pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4;
    input [7:0] adc_d;
    output adc_clk;
    input ssp_dout;
    output ssp_frame, ssp_din, ssp_clk;
    input cross_hi, cross_lo;
    output dbg;
	 input [7:0] divisor;

// No logic, straight through.
assign pwr_oe3 = 1'b0;
assign pwr_oe1 = ssp_dout;
assign pwr_oe2 = ssp_dout;
assign pwr_oe4 = ssp_dout;
assign ssp_clk = cross_lo;
assign pwr_lo = 1'b0;
assign pwr_hi = 1'b0;
assign dbg = ssp_frame;

// Divide the clock to be used for the ADC
reg [7:0] pck_divider;
reg clk_state;

always @(posedge pck0)
begin
	if(pck_divider == divisor[7:0])
		begin
			pck_divider <= 8'd0;
			clk_state = !clk_state;
		end
	else
	begin
		pck_divider <= pck_divider + 1;
	end
end

assign adc_clk = ~clk_state;

// Toggle the output with hysteresis
//  Set to high if the ADC value is above 200
//  Set to low if the ADC value is below 64
reg is_high;
reg is_low;
reg output_state;

always @(posedge pck0)
begin
	if((pck_divider == 8'd7) && !clk_state) begin
		is_high = (adc_d >= 8'd200);
		is_low = (adc_d <= 8'd64);
	end
end

always @(posedge is_high or posedge is_low)
begin
	if(is_high)
		output_state <= 1'd1;
	else if(is_low)
		output_state <= 1'd0;
end

assign ssp_frame = output_state;

endmodule",74,72
115,113,0,False,False,"module FSM_Add_Subtract
	(
		//INPUTS
		input wire clk, //system clock
		input wire rst, //system reset
		input wire rst_FSM,
		input wire beg_FSM, //Begin Finite State Machine
		//**REVISAD
		
	//////////////////////////////////////////////////////////////////////////////
		//Oper_Start_In evaluation signals
		input wire zero_flag_i,
		
		//Exp_operation evaluation signals
		input wire norm_iteration_i,
		
		//Barrel_Shifter evaluation signals
		//None

		//Add_Subt_Sgf evaluation signals
		input wire add_overflow_i,

		//LZA evaluation signals
		//None

		//Deco_round evaluation Signals
		input wire round_i,

		//Final_result evaluation signals
		//None
		
		
		//OUTPUT SIGNALS
	
////////////////////////////////////////////////////////////////////////////////////	
		//Oper_Start_In control signals
		output wire load_1_o,//Enable input registers
		output wire load_2_o,//Enable output registers

		//Exp_operation control signals
		output reg load_3_o, //Enable Output registers
		output reg load_8_o,
		output reg A_S_op_o, //Select operation for exponent normalization(Subt for left shift, Add for right shift)
	
		
		//Barrel shifter control signals
		output reg load_4_o, //Enable Output registers
		output reg left_right_o, //Select direction shift (right=0, left=1)
		output reg bit_shift_o, //bit input for shifts fills

		
		//Add_Subt_sgf control signals
		output reg load_5_o, //Enables Output registers
	
		
		//LZA control signals
		output reg load_6_o, //Enables Output registers

		//Deco_Round control signals
		//None

		//Final_Result control signals
		output reg load_7_o,
		
		///////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

		//Multiplexer selector for Exp_operation's OPER_A

		output reg ctrl_a_o,

		//Multiplexer selector for Exp_operation's OPER_B & Barrel_Shifter's Shift value

		output reg [1:0] ctrl_b_o,
		output reg ctrl_b_load_o,

		//Multiplexer selector for Data shift

		output reg ctrl_c_o,

		//Multiplexer selector for Add_Subt_Sgf's inputs

		output reg ctrl_d_o,

		

		
		
		//Internal reset signal
		output reg rst_int,
		//Ready  Signal
		output reg ready
	 );


localparam [3:0] 
//First I'm going to declarate the registers of the first phase of execution
					 start = 4'd0, //This state evaluates the beg_FSM to begin operations

				     load_oper = 4'd1, //This state enables the registers that contains
											 //both operands and the operator
					 zero_info_state = 4'd2, //Evaluate zero condition

					 load_diff_exp = 4'd3, //Enable registers for the exponent on the small value normalization and for the first
					 						//result normalization
					 						
					 extra1_64= 4'd4,					
					 
					 norm_sgf_first= 4'd5, //Enable the barrel shifter's registers and evaluate if it's the first time (small operand) or the
					 					  //second time (result normalization)	
                      
					 add_subt = 4'd6, //Enable the add_subt_sgf's registers  

					 add_subt_r = 4'd7, //Enable the add_subt_sgf's registers for round condition
					 
					 overflow_add = 4'd8,
					 
					 round_sgf = 4'd9, //Evaluate the significand round condition
                                          
                      overflow_add_r = 4'd10,
     
                      extra2_64= 4'd11, //Enable registers for the exponent normalization on round condition
                                                                
                      norm_sgf_r = 4'd12, //Enable the barrel shifter's registers for round condition
 
                      load_final_result  = 4'd13, //Load the final_result's register with the result
 
                      ready_flag = 4'd14; //Enable the ready flag with the final result

                     
                     
					 
					 


					 
					//**********************REVISADO
	
					
reg [3:0] state_reg, state_next ; //state registers declaration
		 
////////////////////////Logic outputs///////////////77

assign load_1_o= (state_reg==load_oper);
assign load_2_o= (state_reg==zero_info_state);

////
always @(posedge clk, posedge rst)
	if (rst) begin
		state_reg <= start;	
	end
	else begin
		state_reg <= state_next;
	end

///	
always @*
	begin
	state_next = state_reg;
	rst_int = 0;
		//Oper_Start_In control signals
	//load_1_o=0;
	//load_2_o=0;

	//Exp_operation control signals
	load_3_o=0;
	load_8_o=0;
	A_S_op_o=1;

	//Barrel shifter control signals
	load_4_o=0;
	left_right_o=0;
	bit_shift_o=0; //bit input for shifts fills

	
	//Add_Subt_sgf control signals
	load_5_o=0;

	//LZA control signals
	load_6_o=0;

	//Deco_Round control signals
	//None

	//Final_Result control signals
	load_7_o=0;
	
	///////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

	//Multiplexer selector for Exp_operation's OPER_A
	
	ctrl_a_o=0;

	//Multiplexer selector for Exp_operation's OPER_B

	ctrl_b_o=2'b00;
	ctrl_b_load_o=0;

	//Multiplexer selector for Barrel_Shifter's Data shift

	ctrl_c_o=0;

	//Multiplexer selector for Barrel_Shifter's Shift value


	//Multiplexer selector for Add_Subt_Sgf's inputs

	ctrl_d_o=0;

	
	//Ready Phase
	ready = 0;
	//**REVISADO
	rst_int = 0;
	
	case(state_reg)
//FPU reset 
		start: begin
			rst_int=1;

			if(beg_FSM) begin
				state_next = load_oper;
			end
		end

		load_oper: //Load input registers for  Oper_star in evaluation
		
		begin
			
		//	load_1_o = 1;
			state_next = zero_info_state;
		end

		zero_info_state: //In case of zero condition, go to final result for ready flag. Else, continue with the calculation
		begin
			if (zero_flag_i)begin
				state_next = ready_flag;end
			else begin
				//load_2_o = 1;
				state_next = load_diff_exp;end
		end
		

		load_diff_exp: //in first instance, Calculate DMP - DmP exponents, in other iteration, evaluation in
		begin
			load_3_o = 1;
			/*
			if ()*/

			state_next = extra1_64;
		end

        extra1_64:
        begin
        load_3_o = 1;
            if (norm_iteration_i)begin
                load_8_o=1;
                if(add_overflow_i)begin
                    A_S_op_o=0;
                    left_right_o=0;
                    bit_shift_o=1;
                end
                        
	            else begin
	                A_S_op_o=1;
	                left_right_o=1;
	                bit_shift_o=0;
                end
            end               
            state_next = norm_sgf_first;
        end
        
		norm_sgf_first: //
		begin
			load_4_o = 1;
			if (norm_iteration_i)begin
				if(add_overflow_i)begin
                    left_right_o=0;
                    bit_shift_o=1;
                    state_next = round_sgf;
                end
				else begin
					left_right_o=1;
					bit_shift_o=0;
					state_next = round_sgf;end
			end
			else 
				state_next = add_subt;
		end


		add_subt:
		begin
			//Reg enables
			load_5_o = 1;
			ctrl_c_o = 1;
			state_next = overflow_add;
		end

		overflow_add:
		begin
			//Reg enables/Disables
			load_6_o=1;
			ctrl_b_load_o=1;
            if ( add_overflow_i)begin
                ctrl_b_o=2'b10;
                
                end
            else begin
                A_S_op_o=1;
                ctrl_b_o=2'b01;
                

            end	
            //state_next = load_exp_oper_over;
            state_next = extra1_64;
		end



		round_sgf:
		begin
			load_4_o = 0;
			
				if(round_i) begin
					ctrl_d_o =1;
					ctrl_a_o = 1;
					state_next = add_subt_r; end
				else begin
					state_next = load_final_result; end
		end

		
		add_subt_r:
		begin
			load_5_o = 1;
			state_next = overflow_add_r;
			
		end
		
		overflow_add_r:
		begin
            ctrl_b_load_o=1;	
			if ( add_overflow_i)begin
                ctrl_b_o=2'b10;
                end
            else begin
                ctrl_b_o=2'b11;
                end		
		    state_next = extra2_64;
		end
		

		extra2_64:
		
		begin
  			load_3_o = 1;
            load_8_o = 1;
			if ( add_overflow_i)begin
                A_S_op_o=0;
	            bit_shift_o=1;
            end
	
			state_next = norm_sgf_r;
		  
        end
      
		norm_sgf_r:
		begin
			load_4_o = 1;
			if ( add_overflow_i)begin
                left_right_o=0;
                bit_shift_o=1;
            end
			state_next = load_final_result;
		end
		
		load_final_result:
		begin
			load_7_o = 1;
			state_next = ready_flag;
		end
		ready_flag:
		begin
			ready = 1;
				if(rst_FSM) begin
					state_next = start;end
		end

		default:
		begin
			state_next =start;end
	endcase
end

	
endmodule",396,73
5,2,0,True,False,"module sync_signal #(
    parameter WIDTH=1, // width of the input and output signals
    parameter N=2 // depth of synchronizer
)(
    input wire clk,
    input wire [WIDTH-1:0] in,
    output wire [WIDTH-1:0] out
);

reg [WIDTH-1:0] sync_reg[N-1:0];

/*
 * The synchronized output is the last register in the pipeline.
 */
assign out = sync_reg[N-1];

integer k;

always @(posedge clk) begin
    sync_reg[0] <= in;
    for (k = 1; k < N; k = k + 1) begin
        sync_reg[k] <= sync_reg[k-1];
    end
end

endmodule",26,77
19,25,0,False,False,"module wdt(clk, ena, cnt, out);
input clk, ena, cnt;
output out;
reg [6:0] timer;
wire timer_top = (timer == 7'd127);
reg internal_enable;
wire out = internal_enable && timer_top;

always @(posedge clk) begin
    if(ena) begin
	internal_enable <= 1;
	timer <= 0;
    end else if(cnt && !timer_top) timer <= timer + 7'd1;
end
endmodule",15,88
55,43,0,False,False,"module axi_protocol_converter_v2_1_b_downsizer #
  (
   parameter         C_FAMILY                         = ""none"", 
                       // FPGA Family. Current version: virtex6 or spartan6.
   parameter integer C_AXI_ID_WIDTH                   = 4, 
                       // Width of all ID signals on SI and MI side of converter.
                       // Range: >= 1.
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS      = 0,
                       // 1 = Propagate all USER signals, 0 = Dont propagate.
   parameter integer C_AXI_BUSER_WIDTH                = 1
                       // Width of BUSER signals. 
                       // Range: >= 1.
   )
  (
   // Global Signals
   input  wire                                                    ARESET,
   input  wire                                                    ACLK,

   // Command Interface
   input  wire                              cmd_valid,
   input  wire                              cmd_split,
   input  wire [4-1:0]                      cmd_repeat,
   output wire                              cmd_ready,
   
   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]           S_AXI_BID,
   output wire [2-1:0]                          S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire                                                    S_AXI_BVALID,
   input  wire                                                    S_AXI_BREADY,

   // Master Interface Write Response Ports
   input  wire [C_AXI_ID_WIDTH-1:0]          M_AXI_BID,
   input  wire [2-1:0]                         M_AXI_BRESP,
   input  wire [C_AXI_BUSER_WIDTH-1:0]         M_AXI_BUSER,
   input  wire                                                   M_AXI_BVALID,
   output wire                                                   M_AXI_BREADY
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Constants for packing levels.
  localparam [2-1:0] C_RESP_OKAY        = 2'b00;
  localparam [2-1:0] C_RESP_EXOKAY      = 2'b01;
  localparam [2-1:0] C_RESP_SLVERROR    = 2'b10;
  localparam [2-1:0] C_RESP_DECERR      = 2'b11;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Throttling help signals.
  wire                            cmd_ready_i;
  wire                            pop_mi_data;
  wire                            mi_stalling;
  
  // Repeat handling related.
  reg  [4-1:0]                    repeat_cnt_pre;
  reg  [4-1:0]                    repeat_cnt;
  wire [4-1:0]                    next_repeat_cnt;
  reg                             first_mi_word;
  wire                            last_word;
  
  // Ongoing split transaction.
  wire                            load_bresp;
  wire                            need_to_update_bresp;
  reg  [2-1:0]                    S_AXI_BRESP_ACC;
  
  // Internal signals for MI-side.
  wire                            M_AXI_BREADY_I;
  
  // Internal signals for SI-side.
  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_BID_I;
  reg  [2-1:0]                    S_AXI_BRESP_I;
  wire [C_AXI_BUSER_WIDTH-1:0]    S_AXI_BUSER_I;
  wire                            S_AXI_BVALID_I;
  wire                            S_AXI_BREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle interface handshaking:
  // 
  // The MI-side BRESP is popped when at once for split transactions, except 
  // for the last cycle that behaves like a ""normal"" transaction.
  // A ""normal"" BRESP is popped once the SI-side is able to use it,
  // 
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Pop word from MI-side.
  assign M_AXI_BREADY_I = M_AXI_BVALID & ~mi_stalling;
  assign M_AXI_BREADY   = M_AXI_BREADY_I;
  
  // Indicate when there is a BRESP available @ SI-side.
  assign S_AXI_BVALID_I = M_AXI_BVALID & last_word;
  
  // Get MI-side data.
  assign pop_mi_data    = M_AXI_BVALID & M_AXI_BREADY_I;
  
  // Signal that the command is done (so that it can be poped from command queue).
  assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;
  assign cmd_ready      = cmd_ready_i;
  
  // Detect when MI-side is stalling.
  assign mi_stalling    = (~S_AXI_BREADY_I & last_word);
                          
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle the accumulation of BRESP.
  // 
  // Forward the accumulated or MI-side BRESP value depending on state:
  //  * MI-side BRESP is forwarded untouched when it is a non split cycle.
  //    (MI-side BRESP value is also used when updating the accumulated for
  //     the last access during a split access).
  //  * The accumulated BRESP is for a split transaction.
  // 
  // The accumulated BRESP register is updated for each MI-side response that 
  // is used.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Force load accumulated BRESPs to first value
  assign load_bresp           = (cmd_split & first_mi_word);
  
  // Update if more critical.
  assign need_to_update_bresp = ( M_AXI_BRESP > S_AXI_BRESP_ACC );
  
  // Select accumultated or direct depending on setting.
  always @ *
  begin
    if ( cmd_split ) begin
      if ( load_bresp || need_to_update_bresp ) begin
        S_AXI_BRESP_I = M_AXI_BRESP;
      end else begin
        S_AXI_BRESP_I = S_AXI_BRESP_ACC;
      end
    end else begin
      S_AXI_BRESP_I = M_AXI_BRESP;
    end
  end
  
  // Accumulate MI-side BRESP.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      S_AXI_BRESP_ACC <= C_RESP_OKAY;
    end else begin
      if ( pop_mi_data ) begin
        S_AXI_BRESP_ACC <= S_AXI_BRESP_I;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Keep track of BRESP repeat counter.
  //
  // Last BRESP word is either:
  //  * The first and only word when not merging.
  //  * The last value when merging.
  // 
  // The internal counter is taken from the external command interface during
  // the first response when merging. The counter is updated each time a
  // BRESP is popped from the MI-side interface.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Determine last BRESP cycle.
  assign last_word  = ( ( repeat_cnt == 4'b0 ) & ~first_mi_word ) | 
                      ~cmd_split;
  
  // Select command reapeat or counted repeat value.
  always @ *
  begin
    if ( first_mi_word ) begin
      repeat_cnt_pre  =  cmd_repeat;
    end else begin
      repeat_cnt_pre  =  repeat_cnt;
    end
  end
  
  // Calculate next repeat counter value.
  assign next_repeat_cnt  = repeat_cnt_pre - 1'b1;
  
  // Keep track of the repeat count.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      repeat_cnt    <= 4'b0;
      first_mi_word <= 1'b1;
    end else begin
      if ( pop_mi_data ) begin
        repeat_cnt    <= next_repeat_cnt;
        first_mi_word <= last_word;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // BID Handling
  /////////////////////////////////////////////////////////////////////////////
  
  assign S_AXI_BID_I  = M_AXI_BID;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // USER Data bits
  // 
  // The last USER bits are simply taken from the last BRESP that is merged.
  // Ground USER bits when unused.
  /////////////////////////////////////////////////////////////////////////////
  
  // Select USER bits.
  assign S_AXI_BUSER_I = {C_AXI_BUSER_WIDTH{1'b0}};
  
  
  /////////////////////////////////////////////////////////////////////////////
  // SI-side output handling
  /////////////////////////////////////////////////////////////////////////////
// TODO: registered?  
  assign S_AXI_BID      = S_AXI_BID_I;
  assign S_AXI_BRESP    = S_AXI_BRESP_I;
  assign S_AXI_BUSER    = S_AXI_BUSER_I;
  assign S_AXI_BVALID   = S_AXI_BVALID_I;
  assign S_AXI_BREADY_I = S_AXI_BREADY;
  
  
endmodule",241,96
5,3,0,False,False,"module altera_reset_synchronizer
#(
    parameter ASYNC_RESET = 1,
    parameter DEPTH       = 2
)
(
    input   reset_in /* synthesis ALTERA_ATTRIBUTE = ""SUPPRESS_DA_RULE_INTERNAL=R101"" */,

    input   clk,
    output  reset_out
);

    // -----------------------------------------------
    // Synchronizer register chain. We cannot reuse the
    // standard synchronizer in this implementation 
    // because our timing constraints are different.
    //
    // Instead of cutting the timing path to the d-input 
    // on the first flop we need to cut the aclr input.
    // 
    // We omit the ""preserve"" attribute on the final
    // output register, so that the synthesis tool can
    // duplicate it where needed.
    // -----------------------------------------------
    (*preserve*) reg [DEPTH-1:0] altera_reset_synchronizer_int_chain;
    reg altera_reset_synchronizer_int_chain_out;

    generate if (ASYNC_RESET) begin

        // -----------------------------------------------
        // Assert asynchronously, deassert synchronously.
        // -----------------------------------------------
        always @(posedge clk or posedge reset_in) begin
            if (reset_in) begin
                altera_reset_synchronizer_int_chain <= {DEPTH{1'b1}};
                altera_reset_synchronizer_int_chain_out <= 1'b1;
            end
            else begin
                altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];
                altera_reset_synchronizer_int_chain[DEPTH-1] <= 0;
                altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];
            end
        end

        assign reset_out = altera_reset_synchronizer_int_chain_out;
     
    end else begin

        // -----------------------------------------------
        // Assert synchronously, deassert synchronously.
        // -----------------------------------------------
        always @(posedge clk) begin
            altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];
            altera_reset_synchronizer_int_chain[DEPTH-1] <= reset_in;
            altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];
        end

        assign reset_out = altera_reset_synchronizer_int_chain_out;
 
    end
    endgenerate

endmodule",63,100
27,41,0,False,False,"module altera_avalon_st_pipeline_base (
                                       clk,
                                       reset,
                                       in_ready,
                                       in_valid,
                                       in_data,
                                       out_ready,
                                       out_valid,
                                       out_data
                                       );

   parameter  SYMBOLS_PER_BEAT  = 1;
   parameter  BITS_PER_SYMBOL   = 8;
   parameter  PIPELINE_READY    = 1;
   localparam DATA_WIDTH = SYMBOLS_PER_BEAT * BITS_PER_SYMBOL;
   
   input clk;
   input reset;
   
   output in_ready;
   input  in_valid;
   input [DATA_WIDTH-1:0] in_data;
   
   input                  out_ready;
   output                 out_valid;
   output [DATA_WIDTH-1:0] out_data;
   
   reg                     full0;
   reg                     full1;
   reg [DATA_WIDTH-1:0]    data0;
   reg [DATA_WIDTH-1:0]    data1;

   assign out_valid = full1;
   assign out_data  = data1;    
   
   generate if (PIPELINE_READY == 1) 
     begin : REGISTERED_READY_PLINE
        
        assign in_ready  = !full0;

        always @(posedge clk, posedge reset) begin
           if (reset) begin
              data0 <= {DATA_WIDTH{1'b0}};
              data1 <= {DATA_WIDTH{1'b0}};
           end else begin
              // ----------------------------
              // always load the second slot if we can
              // ----------------------------
              if (~full0)
                data0 <= in_data;
              // ----------------------------
              // first slot is loaded either from the second,
              // or with new data
              // ----------------------------
              if (~full1 || (out_ready && out_valid)) begin
                 if (full0)
                   data1 <= data0;
                 else
                   data1 <= in_data;
              end
           end
        end
        
        always @(posedge clk or posedge reset) begin
           if (reset) begin
              full0    <= 1'b0;
              full1    <= 1'b0;
           end else begin
              // no data in pipeline
              if (~full0 & ~full1) begin
                 if (in_valid) begin
                    full1 <= 1'b1;
                 end
              end // ~f1 & ~f0

              // one datum in pipeline 
              if (full1 & ~full0) begin
                 if (in_valid & ~out_ready) begin
                    full0 <= 1'b1;
                 end
                 // back to empty
                 if (~in_valid & out_ready) begin
                    full1 <= 1'b0;
                 end
              end // f1 & ~f0
              
              // two data in pipeline 
              if (full1 & full0) begin
                 // go back to one datum state
                 if (out_ready) begin
                    full0 <= 1'b0;
                 end
              end // end go back to one datum stage
           end
        end

     end 
   else 
     begin : UNREGISTERED_READY_PLINE
	
	// in_ready will be a pass through of the out_ready signal as it is not registered
	assign in_ready = (~full1) | out_ready;
	
	always @(posedge clk or posedge reset) begin
	   if (reset) begin
	      data1 <= 'b0;
	      full1 <= 1'b0;
	   end
	   else begin
	      if (in_ready) begin
		 data1 <= in_data;
		 full1 <= in_valid;
	      end
	   end
	end		
     end
   endgenerate
endmodule",118,101
288,333,0,True,False,"module processing_system7_v5_5_aw_atc #
  (
   parameter         C_FAMILY                         = ""rtl"", 
                       // FPGA Family. Current version: virtex6, spartan6 or later.
   parameter integer C_AXI_ID_WIDTH                   = 4, 
                       // Width of all ID signals on SI and MI side of checker.
                       // Range: >= 1.
   parameter integer C_AXI_ADDR_WIDTH                 = 32, 
                       // Width of all ADDR signals on SI and MI side of checker.
                       // Range: 32.
   parameter integer C_AXI_AWUSER_WIDTH               = 1,
                       // Width of AWUSER signals. 
                       // Range: >= 1.
   parameter integer C_FIFO_DEPTH_LOG                 = 4
   )
  (
   // Global Signals
   input  wire                                  ARESET,
   input  wire                                  ACLK,

   // Command Interface
   output reg                                   cmd_w_valid,
   output wire                                  cmd_w_check,
   output wire [C_AXI_ID_WIDTH-1:0]             cmd_w_id,
   input  wire                                  cmd_w_ready,
   input  wire [C_FIFO_DEPTH_LOG-1:0]           cmd_b_addr,
   input  wire                                  cmd_b_ready,
   
   // Slave Interface Write Address Port
   input  wire [C_AXI_ID_WIDTH-1:0]             S_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,
   input  wire [4-1:0]                          S_AXI_AWLEN,
   input  wire [3-1:0]                          S_AXI_AWSIZE,
   input  wire [2-1:0]                          S_AXI_AWBURST,
   input  wire [2-1:0]                          S_AXI_AWLOCK,
   input  wire [4-1:0]                          S_AXI_AWCACHE,
   input  wire [3-1:0]                          S_AXI_AWPROT,
   input  wire [C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,
   input  wire                                  S_AXI_AWVALID,
   output wire                                  S_AXI_AWREADY,

   // Master Interface Write Address Port
   output wire [C_AXI_ID_WIDTH-1:0]             M_AXI_AWID,
   output wire [C_AXI_ADDR_WIDTH-1:0]           M_AXI_AWADDR,
   output wire [4-1:0]                          M_AXI_AWLEN,
   output wire [3-1:0]                          M_AXI_AWSIZE,
   output wire [2-1:0]                          M_AXI_AWBURST,
   output wire [2-1:0]                          M_AXI_AWLOCK,
   output wire [4-1:0]                          M_AXI_AWCACHE,
   output wire [3-1:0]                          M_AXI_AWPROT,
   output wire [C_AXI_AWUSER_WIDTH-1:0]         M_AXI_AWUSER,
   output wire                                  M_AXI_AWVALID,
   input  wire                                  M_AXI_AWREADY
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Constants for burst types.
  localparam [2-1:0] C_FIX_BURST         = 2'b00;
  localparam [2-1:0] C_INCR_BURST        = 2'b01;
  localparam [2-1:0] C_WRAP_BURST        = 2'b10;
  
  // Constants for size.
  localparam [3-1:0] C_OPTIMIZED_SIZE    = 3'b011;
  
  // Constants for length.
  localparam [4-1:0] C_OPTIMIZED_LEN     = 4'b0011;

  // Constants for cacheline address.
  localparam [4-1:0] C_NO_ADDR_OFFSET    = 5'b0;
  
  // Command FIFO settings
  localparam C_FIFO_WIDTH                = C_AXI_ID_WIDTH + 1;
  localparam C_FIFO_DEPTH                = 2 ** C_FIFO_DEPTH_LOG;
    
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  integer index;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Transaction properties.
  wire                                access_is_incr;
  wire                                access_is_wrap;
  wire                                access_is_coherent;
  wire                                access_optimized_size;
  wire                                incr_addr_boundary;
  wire                                incr_is_optimized;
  wire                                wrap_is_optimized;
  wire                                access_is_optimized;
  
  // Command FIFO.
  wire                                cmd_w_push;
  reg                                 cmd_full;
  reg  [C_FIFO_DEPTH_LOG-1:0]         addr_ptr;
  wire [C_FIFO_DEPTH_LOG-1:0]         all_addr_ptr;
  reg  [C_FIFO_WIDTH-1:0]             data_srl[C_FIFO_DEPTH-1:0];
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Transaction Decode:
  //
  // Detect if transaction is of correct typ, size and length to qualify as
  // an optimized transaction that has to be checked for errors.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Transaction burst type.
  assign access_is_incr         = ( S_AXI_AWBURST == C_INCR_BURST );
  assign access_is_wrap         = ( S_AXI_AWBURST == C_WRAP_BURST );
  
  // Transaction has to be Coherent.
  assign access_is_coherent     = ( S_AXI_AWUSER[0]  == 1'b1 ) &
                                  ( S_AXI_AWCACHE[1] == 1'b1 );
  
  // Transaction cacheline boundary address.
  assign incr_addr_boundary     = ( S_AXI_AWADDR[4:0] == C_NO_ADDR_OFFSET );
  
  // Transaction length & size.
  assign access_optimized_size  = ( S_AXI_AWSIZE == C_OPTIMIZED_SIZE ) & 
                                  ( S_AXI_AWLEN  == C_OPTIMIZED_LEN  );
  
  // Transaction is optimized.
  assign incr_is_optimized      = access_is_incr & access_is_coherent & access_optimized_size & incr_addr_boundary;
  assign wrap_is_optimized      = access_is_wrap & access_is_coherent & access_optimized_size;
  assign access_is_optimized    = ( incr_is_optimized | wrap_is_optimized );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Command FIFO:
  //
  // Since supported write interleaving is only 1, it is safe to use only a 
  // simple SRL based FIFO as a command queue.
  // 
  /////////////////////////////////////////////////////////////////////////////
    
  // Determine when transaction infromation is pushed to the FIFO.
  assign cmd_w_push = S_AXI_AWVALID & M_AXI_AWREADY & ~cmd_full;
  
  // SRL FIFO Pointer.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      addr_ptr <= {C_FIFO_DEPTH_LOG{1'b1}};
    end else begin
      if ( cmd_w_push & ~cmd_w_ready ) begin
        addr_ptr <= addr_ptr + 1;
      end else if ( ~cmd_w_push & cmd_w_ready ) begin
        addr_ptr <= addr_ptr - 1;
      end
    end
  end
  
  // Total number of buffered commands.
  assign all_addr_ptr = addr_ptr + cmd_b_addr + 2;
  
  // FIFO Flags.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      cmd_full    <= 1'b0;
      cmd_w_valid <= 1'b0;
    end else begin
      if ( cmd_w_push & ~cmd_w_ready ) begin
        cmd_w_valid <= 1'b1;
      end else if ( ~cmd_w_push & cmd_w_ready ) begin
        cmd_w_valid <= ( addr_ptr != 0 );
      end
      if ( cmd_w_push & ~cmd_b_ready ) begin
        // Going to full.
        cmd_full    <= ( all_addr_ptr == C_FIFO_DEPTH-3 );
      end else if ( ~cmd_w_push & cmd_b_ready ) begin
        // Pop in middle of queue doesn't affect full status.
        cmd_full    <= ( all_addr_ptr == C_FIFO_DEPTH-2 );
      end
    end
  end
  
  // Infere SRL for storage.
  always @ (posedge ACLK) begin
    if ( cmd_w_push ) begin
      for (index = 0; index < C_FIFO_DEPTH-1 ; index = index + 1) begin
        data_srl[index+1] <= data_srl[index];
      end
      data_srl[0]   <= {access_is_optimized, S_AXI_AWID};
    end
  end
  
  // Get current transaction info.
  assign {cmd_w_check, cmd_w_id} = data_srl[addr_ptr];
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Transaction Throttling:
  //
  // Stall commands if FIFO is full. 
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Propagate masked valid.
  assign M_AXI_AWVALID   = S_AXI_AWVALID & ~cmd_full;
  
  // Return ready with push back.
  assign S_AXI_AWREADY   = M_AXI_AWREADY & ~cmd_full;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Address Write propagation:
  //
  // All information is simply forwarded on from the SI- to MI-Side untouched.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // 1:1 mapping.
  assign M_AXI_AWID      = S_AXI_AWID; 
  assign M_AXI_AWADDR    = S_AXI_AWADDR;
  assign M_AXI_AWLEN     = S_AXI_AWLEN;
  assign M_AXI_AWSIZE    = S_AXI_AWSIZE;
  assign M_AXI_AWBURST   = S_AXI_AWBURST;
  assign M_AXI_AWLOCK    = S_AXI_AWLOCK;
  assign M_AXI_AWCACHE   = S_AXI_AWCACHE;
  assign M_AXI_AWPROT    = S_AXI_AWPROT;
  assign M_AXI_AWUSER    = S_AXI_AWUSER;
  
  
endmodule",238,102
149,136,0,False,False,"module axi_protocol_converter_v2_1_decerr_slave #
  (
   parameter integer C_AXI_ID_WIDTH           = 1,
   parameter integer C_AXI_DATA_WIDTH         = 32,
   parameter integer C_AXI_BUSER_WIDTH        = 1,
   parameter integer C_AXI_RUSER_WIDTH        = 1,
   parameter integer C_AXI_PROTOCOL           = 0,
   parameter integer C_RESP                   = 2'b11,
   parameter integer C_IGNORE_ID              = 0
   )
  (
   input   wire                                         ACLK,
   input   wire                                         ARESETN,
   input   wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_AWID,
   input   wire                                         S_AXI_AWVALID,
   output  wire                                         S_AXI_AWREADY,
   input   wire                                         S_AXI_WLAST,
   input   wire                                         S_AXI_WVALID,
   output  wire                                         S_AXI_WREADY,
   output  wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_BID,
   output  wire [1:0]                                   S_AXI_BRESP,
   output  wire [C_AXI_BUSER_WIDTH-1:0]                 S_AXI_BUSER,
   output  wire                                         S_AXI_BVALID,
   input   wire                                         S_AXI_BREADY,
   input   wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_ARID,
   input   wire [((C_AXI_PROTOCOL == 1) ? 4 : 8)-1:0]   S_AXI_ARLEN,
   input   wire                                         S_AXI_ARVALID,
   output  wire                                         S_AXI_ARREADY,
   output  wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_RID,
   output  wire [(C_AXI_DATA_WIDTH-1):0]                S_AXI_RDATA,
   output  wire [1:0]                                   S_AXI_RRESP,
   output  wire [C_AXI_RUSER_WIDTH-1:0]                 S_AXI_RUSER,
   output  wire                                         S_AXI_RLAST,
   output  wire                                         S_AXI_RVALID,
   input   wire                                         S_AXI_RREADY
   );
   
  reg s_axi_awready_i;
  reg s_axi_wready_i;
  reg s_axi_bvalid_i;
  reg s_axi_arready_i;
  reg s_axi_rvalid_i;
  
  localparam P_WRITE_IDLE = 2'b00;
  localparam P_WRITE_DATA = 2'b01;
  localparam P_WRITE_RESP = 2'b10;
  localparam P_READ_IDLE  = 2'b00;
  localparam P_READ_START = 2'b01;
  localparam P_READ_DATA  = 2'b10;
  localparam integer  P_AXI4 = 0;
  localparam integer  P_AXI3 = 1;
  localparam integer  P_AXILITE = 2;
   
  assign S_AXI_BRESP = C_RESP;
  assign S_AXI_RRESP = C_RESP;
  assign S_AXI_RDATA = {C_AXI_DATA_WIDTH{1'b0}};
  assign S_AXI_BUSER = {C_AXI_BUSER_WIDTH{1'b0}};
  assign S_AXI_RUSER = {C_AXI_RUSER_WIDTH{1'b0}};
  assign S_AXI_AWREADY = s_axi_awready_i;
  assign S_AXI_WREADY = s_axi_wready_i;
  assign S_AXI_BVALID = s_axi_bvalid_i;
  assign S_AXI_ARREADY = s_axi_arready_i;
  assign S_AXI_RVALID = s_axi_rvalid_i;
  
  generate
  if (C_AXI_PROTOCOL == P_AXILITE) begin : gen_axilite
    
    reg s_axi_rvalid_en;
    assign S_AXI_RLAST = 1'b1;
    assign S_AXI_BID = 0;
    assign S_AXI_RID = 0;
    
    always @(posedge ACLK) begin
      if (~ARESETN) begin
        s_axi_awready_i <= 1'b0;
        s_axi_wready_i <= 1'b0;
        s_axi_bvalid_i <= 1'b0;
      end else begin
        if (s_axi_bvalid_i) begin
          if (S_AXI_BREADY) begin
            s_axi_bvalid_i <= 1'b0;
            s_axi_awready_i <= 1'b1;
          end
        end else if (S_AXI_WVALID & s_axi_wready_i) begin
            s_axi_wready_i <= 1'b0;
            s_axi_bvalid_i <= 1'b1;
        end else if (S_AXI_AWVALID & s_axi_awready_i) begin
          s_axi_awready_i <= 1'b0;
          s_axi_wready_i <= 1'b1;
        end else begin
          s_axi_awready_i <= 1'b1;
        end
      end
    end
           
    always @(posedge ACLK) begin
      if (~ARESETN) begin
        s_axi_arready_i <= 1'b0;
        s_axi_rvalid_i <= 1'b0;
        s_axi_rvalid_en <= 1'b0;
      end else begin
        if (s_axi_rvalid_i) begin
          if (S_AXI_RREADY) begin
            s_axi_rvalid_i <= 1'b0;
            s_axi_arready_i <= 1'b1;
          end
        end else if (s_axi_rvalid_en) begin
          s_axi_rvalid_en <= 1'b0;
          s_axi_rvalid_i <= 1'b1;
        end else if (S_AXI_ARVALID & s_axi_arready_i) begin
          s_axi_arready_i <= 1'b0;
          s_axi_rvalid_en <= 1'b1;
        end else begin
          s_axi_arready_i <= 1'b1;
        end
      end
    end
        
  end else begin : gen_axi
  
    reg s_axi_rlast_i;
    reg [(C_AXI_ID_WIDTH-1):0] s_axi_bid_i;
    reg [(C_AXI_ID_WIDTH-1):0] s_axi_rid_i;
    reg [((C_AXI_PROTOCOL == 1) ? 4 : 8)-1:0] read_cnt;
    reg [1:0] write_cs;
    reg [1:0] read_cs;
  
    assign S_AXI_RLAST = s_axi_rlast_i;
    assign S_AXI_BID = C_IGNORE_ID ? 0 : s_axi_bid_i;
    assign S_AXI_RID = C_IGNORE_ID ? 0 : s_axi_rid_i;
  
    always @(posedge ACLK) begin
      if (~ARESETN) begin
        write_cs <= P_WRITE_IDLE;
        s_axi_awready_i <= 1'b0;
        s_axi_wready_i <= 1'b0;
        s_axi_bvalid_i <= 1'b0;
        s_axi_bid_i <= 0;
      end else begin
        case (write_cs) 
          P_WRITE_IDLE: 
            begin
              if (S_AXI_AWVALID & s_axi_awready_i) begin
                s_axi_awready_i <= 1'b0;
                if (C_IGNORE_ID == 0) s_axi_bid_i <= S_AXI_AWID;
                s_axi_wready_i <= 1'b1;
                write_cs <= P_WRITE_DATA;
              end else begin
                s_axi_awready_i <= 1'b1;
              end
            end
          P_WRITE_DATA:
            begin
              if (S_AXI_WVALID & S_AXI_WLAST) begin
                s_axi_wready_i <= 1'b0;
                s_axi_bvalid_i <= 1'b1;
                write_cs <= P_WRITE_RESP;
              end
            end
          P_WRITE_RESP:
            begin
              if (S_AXI_BREADY) begin
                s_axi_bvalid_i <= 1'b0;
                s_axi_awready_i <= 1'b1;
                write_cs <= P_WRITE_IDLE;
              end
            end
        endcase
      end
    end
  
    always @(posedge ACLK) begin
      if (~ARESETN) begin
        read_cs <= P_READ_IDLE;
        s_axi_arready_i <= 1'b0;
        s_axi_rvalid_i <= 1'b0;
        s_axi_rlast_i <= 1'b0;
        s_axi_rid_i <= 0;
        read_cnt <= 0;
      end else begin
        case (read_cs) 
          P_READ_IDLE: 
            begin
              if (S_AXI_ARVALID & s_axi_arready_i) begin
                s_axi_arready_i <= 1'b0;
                if (C_IGNORE_ID == 0) s_axi_rid_i <= S_AXI_ARID;
                read_cnt <= S_AXI_ARLEN;
                s_axi_rlast_i <= (S_AXI_ARLEN == 0);
                read_cs <= P_READ_START;
              end else begin
                s_axi_arready_i <= 1'b1;
              end
            end
          P_READ_START:
            begin
              s_axi_rvalid_i <= 1'b1;
              read_cs <= P_READ_DATA;
            end
          P_READ_DATA:
            begin
              if (S_AXI_RREADY) begin
                if (read_cnt == 0) begin
                  s_axi_rvalid_i <= 1'b0;
                  s_axi_rlast_i <= 1'b0;
                  s_axi_arready_i <= 1'b1;
                  read_cs <= P_READ_IDLE;
                end else begin
                  if (read_cnt == 1) begin
                    s_axi_rlast_i <= 1'b1;
                  end
                  read_cnt <= read_cnt - 1;
                end
              end
            end
        endcase
      end
    end
  
  end  
  endgenerate

endmodule",222,104
58,46,0,False,False,"module axi_protocol_converter_v2_1_w_axi3_conv #
  (
   parameter C_FAMILY                            = ""none"",
   parameter integer C_AXI_ID_WIDTH              = 1,
   parameter integer C_AXI_ADDR_WIDTH            = 32,
   parameter integer C_AXI_DATA_WIDTH            = 32,
   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,
   parameter integer C_AXI_WUSER_WIDTH           = 1,
   parameter integer C_SUPPORT_SPLITTING              = 1,
                       // Implement transaction splitting logic.
                       // Disabled whan all connected masters are AXI3 and have same or narrower data width.
   parameter integer C_SUPPORT_BURSTS                 = 1
                       // Disabled when all connected masters are AxiLite,
                       //   allowing logic to be simplified.
   )
  (
   // System Signals
   input wire ACLK,
   input wire ARESET,

   // Command Interface
   input  wire                              cmd_valid,
   input  wire [C_AXI_ID_WIDTH-1:0]         cmd_id,
   input  wire [4-1:0]                      cmd_length,
   output wire                              cmd_ready,
   
   // Slave Interface Write Data Ports
   input  wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,
   input  wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,
   input  wire                          S_AXI_WLAST,
   input  wire [C_AXI_WUSER_WIDTH-1:0]  S_AXI_WUSER,
   input  wire                          S_AXI_WVALID,
   output wire                          S_AXI_WREADY,
   
   // Master Interface Write Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_WID,
   output wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA,
   output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,
   output wire                          M_AXI_WLAST,
   output wire [C_AXI_WUSER_WIDTH-1:0]  M_AXI_WUSER,
   output wire                          M_AXI_WVALID,
   input  wire                          M_AXI_WREADY
   );

   
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////

  // Burst length handling.
  reg                             first_mi_word;
  reg  [8-1:0]                    length_counter_1;
  reg  [8-1:0]                    length_counter;
  wire [8-1:0]                    next_length_counter;
  wire                            last_beat;
  wire                            last_word;
  
  // Throttling help signals.
  wire                            cmd_ready_i;
  wire                            pop_mi_data;
  wire                            mi_stalling;
  
  // Internal SI side control signals.
  wire                            S_AXI_WREADY_I;
  
  // Internal signals for MI-side.
  wire [C_AXI_ID_WIDTH-1:0]       M_AXI_WID_I;
  wire [C_AXI_DATA_WIDTH-1:0]     M_AXI_WDATA_I;
  wire [C_AXI_DATA_WIDTH/8-1:0]   M_AXI_WSTRB_I;
  wire                            M_AXI_WLAST_I;
  wire [C_AXI_WUSER_WIDTH-1:0]    M_AXI_WUSER_I;
  wire                            M_AXI_WVALID_I;
  wire                            M_AXI_WREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Handle interface handshaking:
  // 
  // Forward data from SI-Side to MI-Side while a command is available. When
  // the transaction has completed the command is popped from the Command FIFO.
  // 
  /////////////////////////////////////////////////////////////////////////////
                          
  // Pop word from SI-side.
  assign S_AXI_WREADY_I = S_AXI_WVALID & cmd_valid & ~mi_stalling;
  assign S_AXI_WREADY   = S_AXI_WREADY_I;
  
  // Indicate when there is data available @ MI-side.
  assign M_AXI_WVALID_I = S_AXI_WVALID & cmd_valid;
  
  // Get MI-side data.
  assign pop_mi_data    = M_AXI_WVALID_I & M_AXI_WREADY_I;
  
  // Signal that the command is done (so that it can be poped from command queue).
  assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;
  assign cmd_ready      = cmd_ready_i;
  
  // Detect when MI-side is stalling.
  assign mi_stalling    = M_AXI_WVALID_I & ~M_AXI_WREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Keep track of data forwarding:
  // 
  // On the first cycle of the transaction is the length taken from the Command
  // FIFO. The length is decreased until 0 is reached which indicates last data 
  // word.
  //
  // If bursts are unsupported will all data words be the last word, each one
  // from a separate transaction.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Select command length or counted length.
  always @ *
  begin
    if ( first_mi_word )
      length_counter = cmd_length;
    else
      length_counter = length_counter_1;
  end
  
  // Calculate next length counter value.
  assign next_length_counter = length_counter - 1'b1;
  
  // Keep track of burst length.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      first_mi_word    <= 1'b1;
      length_counter_1 <= 4'b0;
    end else begin
      if ( pop_mi_data ) begin
        if ( M_AXI_WLAST_I ) begin
          first_mi_word    <= 1'b1;
        end else begin
          first_mi_word    <= 1'b0;
        end
      
        length_counter_1 <= next_length_counter;
      end
    end
  end
  
  // Detect last beat in a burst.
  assign last_beat = ( length_counter == 4'b0 );
  
  // Determine if this last word that shall be extracted from this SI-side word.
  assign last_word = ( last_beat ) |
                     ( C_SUPPORT_BURSTS == 0 );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Select the SI-side word to write.
  // 
  // Most information can be reused directly (DATA, STRB, ID and USER).
  // ID is taken from the Command FIFO.
  //
  // Split transactions needs to insert new LAST transactions. So to simplify
  // is the LAST signal always generated.
  //
  /////////////////////////////////////////////////////////////////////////////
  
  // ID and USER is copied from the SI word to all MI word transactions.
  assign M_AXI_WUSER_I  = ( C_AXI_SUPPORTS_USER_SIGNALS ) ? S_AXI_WUSER : {C_AXI_WUSER_WIDTH{1'b0}};
  
  // Data has to be multiplexed.
  assign M_AXI_WDATA_I  = S_AXI_WDATA;
  assign M_AXI_WSTRB_I  = S_AXI_WSTRB;
  
  // ID is taken directly from the command queue.
  assign M_AXI_WID_I    = cmd_id;
  
  // Handle last flag, i.e. set for MI-side last word.
  assign M_AXI_WLAST_I  = last_word;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // MI-side output handling
  // 
  /////////////////////////////////////////////////////////////////////////////
// TODO: registered?
  assign M_AXI_WID      = M_AXI_WID_I;
  assign M_AXI_WDATA    = M_AXI_WDATA_I;
  assign M_AXI_WSTRB    = M_AXI_WSTRB_I;
  assign M_AXI_WLAST    = M_AXI_WLAST_I;
  assign M_AXI_WUSER    = M_AXI_WUSER_I;
  assign M_AXI_WVALID   = M_AXI_WVALID_I;
  assign M_AXI_WREADY_I = M_AXI_WREADY;
  
  
endmodule",206,105
135,179,0,True,False,"module debounce_switch  #(
    parameter WIDTH=1, // width of the input and output signals
    parameter N=3, // length of shift register
    parameter RATE=125000 // clock division factor
)(
    input wire clk,
    input wire rst,
    input wire [WIDTH-1:0] in,
    output wire [WIDTH-1:0] out
);

reg [23:0] cnt_reg = 24'd0;

reg [N-1:0] debounce_reg[WIDTH-1:0];

reg [WIDTH-1:0] state;

/*
 * The synchronized output is the state register
 */
assign out = state;

integer k;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        cnt_reg <= 0;
        state <= 0;
        
        for (k = 0; k < WIDTH; k = k + 1) begin
            debounce_reg[k] <= 0;
        end
    end else begin
        if (cnt_reg < RATE) begin
            cnt_reg <= cnt_reg + 24'd1;
        end else begin
            cnt_reg <= 24'd0;
        end
        
        if (cnt_reg == 24'd0) begin
            for (k = 0; k < WIDTH; k = k + 1) begin
                debounce_reg[k] <= {debounce_reg[k][N-2:0], in[k]};
            end
        end
        
        for (k = 0; k < WIDTH; k = k + 1) begin
            if (|debounce_reg[k] == 0) begin
                state[k] <= 0;
            end else if (&debounce_reg[k] == 1) begin
                state[k] <= 1;
            end else begin
                state[k] <= state[k];
            end
        end
    end
end

endmodule",58,106
79,133,0,False,False,"module fifo_generator_v13_1_3_axic_reg_slice #
  (
   parameter C_FAMILY     = ""virtex7"",
   parameter C_DATA_WIDTH = 32,
   parameter C_REG_CONFIG = 32'h00000000
   )
  (
   // System Signals
   input  wire                      ACLK,
   input  wire                      ARESET,

   // Slave side
   input  wire [C_DATA_WIDTH-1:0]   S_PAYLOAD_DATA,
   input  wire                      S_VALID,
   output wire                      S_READY,

   // Master side
   output wire [C_DATA_WIDTH-1:0]   M_PAYLOAD_DATA,
   output wire                      M_VALID,
   input  wire                      M_READY
   );

  generate
  ////////////////////////////////////////////////////////////////////
  //
  // Both FWD and REV mode
  //
  ////////////////////////////////////////////////////////////////////
    if (C_REG_CONFIG == 32'h00000000)
    begin
      reg [1:0] state;
      localparam [1:0] 
        ZERO = 2'b10,
        ONE  = 2'b11,
        TWO  = 2'b01;
      
      reg [C_DATA_WIDTH-1:0] storage_data1 = 0;
      reg [C_DATA_WIDTH-1:0] storage_data2 = 0;
      reg                    load_s1;
      wire                   load_s2;
      wire                   load_s1_from_s2;
      reg                    s_ready_i; //local signal of output
      wire                   m_valid_i; //local signal of output

      // assign local signal to its output signal
      assign S_READY = s_ready_i;
      assign M_VALID = m_valid_i;

      reg  areset_d1; // Reset delay register
      always @(posedge ACLK) begin
        areset_d1 <= ARESET;
      end
      
      // Load storage1 with either slave side data or from storage2
      always @(posedge ACLK) 
      begin
        if (load_s1)
          if (load_s1_from_s2)
            storage_data1 <= storage_data2;
          else
            storage_data1 <= S_PAYLOAD_DATA;        
      end

      // Load storage2 with slave side data
      always @(posedge ACLK) 
      begin
        if (load_s2)
          storage_data2 <= S_PAYLOAD_DATA;
      end

      assign M_PAYLOAD_DATA = storage_data1;

      // Always load s2 on a valid transaction even if it's unnecessary
      assign load_s2 = S_VALID & s_ready_i;

      // Loading s1
      always @ *
      begin
        if ( ((state == ZERO) && (S_VALID == 1)) || // Load when empty on slave transaction
             // Load when ONE if we both have read and write at the same time
             ((state == ONE) && (S_VALID == 1) && (M_READY == 1)) ||
             // Load when TWO and we have a transaction on Master side
             ((state == TWO) && (M_READY == 1)))
          load_s1 = 1'b1;
        else
          load_s1 = 1'b0;
      end // always @ *

      assign load_s1_from_s2 = (state == TWO);
                       
      // State Machine for handling output signals
      always @(posedge ACLK) begin
        if (ARESET) begin
          s_ready_i <= 1'b0;
          state <= ZERO;
        end else if (areset_d1) begin
          s_ready_i <= 1'b1;
        end else begin
          case (state)
            // No transaction stored locally
            ZERO: if (S_VALID) state <= ONE; // Got one so move to ONE

            // One transaction stored locally
            ONE: begin
              if (M_READY & ~S_VALID) state <= ZERO; // Read out one so move to ZERO
              if (~M_READY & S_VALID) begin
                state <= TWO;  // Got another one so move to TWO
                s_ready_i <= 1'b0;
              end
            end

            // TWO transaction stored locally
            TWO: if (M_READY) begin
              state <= ONE; // Read out one so move to ONE
              s_ready_i <= 1'b1;
            end
          endcase // case (state)
        end
      end // always @ (posedge ACLK)
      
      assign m_valid_i = state[0];

    end // if (C_REG_CONFIG == 1)
  ////////////////////////////////////////////////////////////////////
  //
  // 1-stage pipeline register with bubble cycle, both FWD and REV pipelining
  // Operates same as 1-deep FIFO
  //
  ////////////////////////////////////////////////////////////////////
    else if (C_REG_CONFIG == 32'h00000001)
    begin
      reg [C_DATA_WIDTH-1:0] storage_data1 = 0;
      reg                    s_ready_i; //local signal of output
      reg                    m_valid_i; //local signal of output

      // assign local signal to its output signal
      assign S_READY = s_ready_i;
      assign M_VALID = m_valid_i;

      reg  areset_d1; // Reset delay register
      always @(posedge ACLK) begin
        areset_d1 <= ARESET;
      end
      
      // Load storage1 with slave side data
      always @(posedge ACLK) 
      begin
        if (ARESET) begin
          s_ready_i <= 1'b0;
          m_valid_i <= 1'b0;
        end else if (areset_d1) begin
          s_ready_i <= 1'b1;
        end else if (m_valid_i & M_READY) begin
          s_ready_i <= 1'b1;
          m_valid_i <= 1'b0;
        end else if (S_VALID & s_ready_i) begin
          s_ready_i <= 1'b0;
          m_valid_i <= 1'b1;
        end
        if (~m_valid_i) begin
          storage_data1 <= S_PAYLOAD_DATA;        
        end
      end
      assign M_PAYLOAD_DATA = storage_data1;
    end // if (C_REG_CONFIG == 7)
    
    else begin : default_case
      // Passthrough
      assign M_PAYLOAD_DATA = S_PAYLOAD_DATA;
      assign M_VALID        = S_VALID;
      assign S_READY        = M_READY;      
    end

  endgenerate
endmodule",175,110
464,558,0,True,True,"module processing_system7_v5_5_b_atc #
  (
   parameter         C_FAMILY                         = ""rtl"", 
                       // FPGA Family. Current version: virtex6, spartan6 or later.
   parameter integer C_AXI_ID_WIDTH                   = 4, 
                       // Width of all ID signals on SI and MI side of checker.
                       // Range: >= 1.
   parameter integer C_AXI_BUSER_WIDTH                = 1,
                       // Width of AWUSER signals. 
                       // Range: >= 1.
   parameter integer C_FIFO_DEPTH_LOG                 = 4
   )
  (
   // Global Signals
   input  wire                                  ARESET,
   input  wire                                  ACLK,

   // Command Interface
   input  wire                                  cmd_b_push,
   input  wire                                  cmd_b_error,
   input  wire [C_AXI_ID_WIDTH-1:0]             cmd_b_id,
   output wire                                  cmd_b_ready,
   output wire [C_FIFO_DEPTH_LOG-1:0]           cmd_b_addr,
   output reg                                   cmd_b_full,
   
   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]             S_AXI_BID,
   output reg  [2-1:0]                          S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0]          S_AXI_BUSER,
   output wire                                  S_AXI_BVALID,
   input  wire                                  S_AXI_BREADY,

   // Master Interface Write Response Ports
   input  wire [C_AXI_ID_WIDTH-1:0]             M_AXI_BID,
   input  wire [2-1:0]                          M_AXI_BRESP,
   input  wire [C_AXI_BUSER_WIDTH-1:0]          M_AXI_BUSER,
   input  wire                                  M_AXI_BVALID,
   output wire                                  M_AXI_BREADY,
   
   // Trigger detection
   output reg                                   ERROR_TRIGGER,
   output reg  [C_AXI_ID_WIDTH-1:0]             ERROR_TRANSACTION_ID
   );
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Local params
  /////////////////////////////////////////////////////////////////////////////
  
  // Constants for packing levels.
  localparam [2-1:0] C_RESP_OKAY         = 2'b00;
  localparam [2-1:0] C_RESP_EXOKAY       = 2'b01;
  localparam [2-1:0] C_RESP_SLVERROR     = 2'b10;
  localparam [2-1:0] C_RESP_DECERR       = 2'b11;
  
  // Command FIFO settings
  localparam C_FIFO_WIDTH                = C_AXI_ID_WIDTH + 1;
  localparam C_FIFO_DEPTH                = 2 ** C_FIFO_DEPTH_LOG;
    
  
  /////////////////////////////////////////////////////////////////////////////
  // Variables for generating parameter controlled instances.
  /////////////////////////////////////////////////////////////////////////////
  
  integer index;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Functions
  /////////////////////////////////////////////////////////////////////////////
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Internal signals
  /////////////////////////////////////////////////////////////////////////////
  
  // Command Queue.
  reg  [C_FIFO_DEPTH_LOG-1:0]         addr_ptr;
  reg  [C_FIFO_WIDTH-1:0]             data_srl[C_FIFO_DEPTH-1:0];
  reg                                 cmd_b_valid;
  wire                                cmd_b_ready_i;
  wire                                inject_error;
  wire [C_AXI_ID_WIDTH-1:0]           current_id;
  
  // Search command.
  wire                                found_match;
  wire                                use_match;
  wire                                matching_id;
  
  // Manage valid command.
  wire                                write_valid_cmd;
  reg  [C_FIFO_DEPTH-2:0]             valid_cmd;
  reg  [C_FIFO_DEPTH-2:0]             updated_valid_cmd;
  reg  [C_FIFO_DEPTH-2:0]             next_valid_cmd;
  reg  [C_FIFO_DEPTH_LOG-1:0]         search_addr_ptr;
  reg  [C_FIFO_DEPTH_LOG-1:0]         collapsed_addr_ptr;
  
  // Pipelined data
  reg  [C_AXI_ID_WIDTH-1:0]           M_AXI_BID_I;
  reg  [2-1:0]                        M_AXI_BRESP_I;
  reg  [C_AXI_BUSER_WIDTH-1:0]        M_AXI_BUSER_I;
  reg                                 M_AXI_BVALID_I;
  wire                                M_AXI_BREADY_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Command Queue:
  //
  // Keep track of depth of Queue to generate full flag.
  // 
  // Also generate valid to mark pressence of commands in Queue.
  // 
  // Maintain Queue and extract data from currently searched entry.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // SRL FIFO Pointer.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      addr_ptr <= {C_FIFO_DEPTH_LOG{1'b1}};
    end else begin
      if ( cmd_b_push & ~cmd_b_ready_i ) begin
        // Pushing data increase length/addr.
        addr_ptr <= addr_ptr + 1;
      end else if ( cmd_b_ready_i ) begin
        // Collapse addr when data is popped.
        addr_ptr <= collapsed_addr_ptr;
      end
    end
  end
  
  // FIFO Flags.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      cmd_b_full  <= 1'b0;
      cmd_b_valid <= 1'b0;
    end else begin
      if ( cmd_b_push & ~cmd_b_ready_i ) begin
        cmd_b_full  <= ( addr_ptr == C_FIFO_DEPTH-3 );
        cmd_b_valid <= 1'b1;
      end else if ( ~cmd_b_push & cmd_b_ready_i ) begin
        cmd_b_full  <= 1'b0;
        cmd_b_valid <= ( collapsed_addr_ptr != C_FIFO_DEPTH-1 );
      end
    end
  end
  
  // Infere SRL for storage.
  always @ (posedge ACLK) begin
    if ( cmd_b_push ) begin
      for (index = 0; index < C_FIFO_DEPTH-1 ; index = index + 1) begin
        data_srl[index+1] <= data_srl[index];
      end
      data_srl[0]   <= {cmd_b_error, cmd_b_id};
    end
  end
  
  // Get current transaction info.
  assign {inject_error, current_id} = data_srl[search_addr_ptr];
  
  // Assign outputs.
  assign cmd_b_addr = collapsed_addr_ptr;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Search Command Queue:
  //
  // Search for matching valid command in queue.
  // 
  // A command is found when an valid entry with correct ID is found. The queue
  // is search from the oldest entry, i.e. from a high value.
  // When new commands are pushed the search address has to be updated to always 
  // start the search from the oldest available.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Handle search addr.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      search_addr_ptr <= {C_FIFO_DEPTH_LOG{1'b1}};
    end else begin
      if ( cmd_b_ready_i ) begin
        // Collapse addr when data is popped.
        search_addr_ptr <= collapsed_addr_ptr;
        
      end else if ( M_AXI_BVALID_I & cmd_b_valid & ~found_match & ~cmd_b_push ) begin
        // Skip non valid command.
        search_addr_ptr <= search_addr_ptr - 1;
        
      end else if ( cmd_b_push ) begin
        search_addr_ptr <= search_addr_ptr + 1;
        
      end
    end
  end
  
  // Check if searched command is valid and match ID (for existing response on MI side).
  assign matching_id  = ( M_AXI_BID_I == current_id );
  assign found_match  = valid_cmd[search_addr_ptr] & matching_id & M_AXI_BVALID_I;
  assign use_match    = found_match & S_AXI_BREADY;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Track Used Commands:
  //
  // Actions that affect Valid Command:
  // * When a new command is pushed
  //   => Shift valid vector one step
  // * When a command is used
  //   => Clear corresponding valid bit
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Valid command status is updated when a command is used or a new one is pushed.
  assign write_valid_cmd  = cmd_b_push | cmd_b_ready_i;
  
  // Update the used command valid bit.
  always @ *
  begin
    updated_valid_cmd                   = valid_cmd;
    updated_valid_cmd[search_addr_ptr]  = ~use_match;
  end
  
  // Shift valid vector when command is pushed.
  always @ *
  begin
    if ( cmd_b_push ) begin
      next_valid_cmd = {updated_valid_cmd[C_FIFO_DEPTH-3:0], 1'b1};
    end else begin
      next_valid_cmd = updated_valid_cmd;
    end
  end
  
  // Valid signals for next cycle.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      valid_cmd <= {C_FIFO_WIDTH{1'b0}};
    end else if ( write_valid_cmd ) begin
      valid_cmd <= next_valid_cmd;
    end
  end
  
  // Detect oldest available command in Queue.
  always @ *
  begin
    // Default to empty.
    collapsed_addr_ptr = {C_FIFO_DEPTH_LOG{1'b1}};
    
    for (index = 0; index < C_FIFO_DEPTH-2 ; index = index + 1) begin
      if ( next_valid_cmd[index] ) begin
        collapsed_addr_ptr = index;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Pipe incoming data:
  // 
  // The B channel is piped to improve timing and avoid impact in search
  // mechanism due to late arriving signals.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Clock data.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      M_AXI_BID_I     <= {C_AXI_ID_WIDTH{1'b0}};
      M_AXI_BRESP_I   <= 2'b00;
      M_AXI_BUSER_I   <= {C_AXI_BUSER_WIDTH{1'b0}};
      M_AXI_BVALID_I  <= 1'b0;
    end else begin
      if ( M_AXI_BREADY_I | ~M_AXI_BVALID_I ) begin
        M_AXI_BVALID_I  <= 1'b0;
      end
      if (M_AXI_BVALID & ( M_AXI_BREADY_I | ~M_AXI_BVALID_I) ) begin
        M_AXI_BID_I     <= M_AXI_BID;
        M_AXI_BRESP_I   <= M_AXI_BRESP;
        M_AXI_BUSER_I   <= M_AXI_BUSER;
        M_AXI_BVALID_I  <= 1'b1;
      end
    end
  end
  
  // Generate ready to get new transaction.
  assign M_AXI_BREADY = M_AXI_BREADY_I | ~M_AXI_BVALID_I;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Inject Error:
  //
  // BRESP is modified according to command information.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Inject error in response.
  always @ *
  begin
    if ( inject_error ) begin
      S_AXI_BRESP = C_RESP_SLVERROR;
    end else begin
      S_AXI_BRESP = M_AXI_BRESP_I;
    end
  end
  
  // Handle interrupt generation.
  always @ (posedge ACLK) begin
    if (ARESET) begin
      ERROR_TRIGGER        <= 1'b0;
      ERROR_TRANSACTION_ID <= {C_AXI_ID_WIDTH{1'b0}};
    end else begin
      if ( inject_error & cmd_b_ready_i ) begin
        ERROR_TRIGGER        <= 1'b1;
        ERROR_TRANSACTION_ID <= M_AXI_BID_I;
      end else begin
        ERROR_TRIGGER        <= 1'b0;
      end
    end
  end
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Transaction Throttling:
  //
  // Response is passed forward when a matching entry has been found in queue.
  // Both ready and valid are set when the command is completed.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // Propagate masked valid.
  assign S_AXI_BVALID   = M_AXI_BVALID_I & cmd_b_valid & found_match;
  
  // Return ready with push back.
  assign M_AXI_BREADY_I = cmd_b_valid & use_match;
  
  // Command has been handled.
  assign cmd_b_ready_i  = M_AXI_BVALID_I & cmd_b_valid & use_match;
  assign cmd_b_ready    = cmd_b_ready_i;
  
  
  /////////////////////////////////////////////////////////////////////////////
  // Write Response Propagation:
  //
  // All information is simply forwarded on from MI- to SI-Side untouched.
  // 
  /////////////////////////////////////////////////////////////////////////////
  
  // 1:1 mapping.
  assign S_AXI_BID    = M_AXI_BID_I;
  assign S_AXI_BUSER  = M_AXI_BUSER_I;
  
  
endmodule",353,117
128,131,0,False,False,"module Priority_Codec_32(
    input wire [25:0] Data_Dec_i,
    output reg [4:0] Data_Bin_o
    );

	always @(Data_Dec_i)
	begin
		if(~Data_Dec_i[25]) begin Data_Bin_o = 5'b00000;//0
		end else if(~Data_Dec_i[24]) begin Data_Bin_o = 5'b00001;//1
		end else if(~Data_Dec_i[23]) begin Data_Bin_o = 5'b00010;//2
		end else if(~Data_Dec_i[22]) begin Data_Bin_o = 5'b00011;//3
		end else if(~Data_Dec_i[21]) begin Data_Bin_o = 5'b00100;//4
		end else if(~Data_Dec_i[20]) begin Data_Bin_o = 5'b00101;//5
		end else if(~Data_Dec_i[19]) begin Data_Bin_o = 5'b00110;//6
		end else if(~Data_Dec_i[18]) begin Data_Bin_o = 5'b00111;//7
		end else if(~Data_Dec_i[17]) begin Data_Bin_o = 5'b01000;//8
		end else if(~Data_Dec_i[16]) begin Data_Bin_o = 5'b01001;//9
		end else if(~Data_Dec_i[15]) begin Data_Bin_o = 5'b01010;//10
		end else if(~Data_Dec_i[14]) begin Data_Bin_o = 5'b01011;//11
		end else if(~Data_Dec_i[13]) begin Data_Bin_o = 5'b01100;//12
		end else if(~Data_Dec_i[12]) begin Data_Bin_o = 5'b01101;//13
		end else if(~Data_Dec_i[11]) begin Data_Bin_o = 5'b01110;//14
		end else if(~Data_Dec_i[10]) begin Data_Bin_o = 5'b01111;//15
		end else if(~Data_Dec_i[9])  begin Data_Bin_o = 5'b10000;//16
		end else if(~Data_Dec_i[8])  begin Data_Bin_o = 5'b10001;//17
		end else if(~Data_Dec_i[7])  begin Data_Bin_o = 5'b10010;//18
		end else if(~Data_Dec_i[6])  begin Data_Bin_o = 5'b10011;//19
		end else if(~Data_Dec_i[5])  begin Data_Bin_o = 5'b10100;//20
		end else if(~Data_Dec_i[4])  begin Data_Bin_o = 5'b10101;//21
		end else if(~Data_Dec_i[3])  begin Data_Bin_o = 5'b10110;//22
		end else if(~Data_Dec_i[2])  begin Data_Bin_o = 5'b10111;//23
		end else if(~Data_Dec_i[1])  begin Data_Bin_o = 5'b11000;//24
		end else if(~Data_Dec_i[0])  begin Data_Bin_o = 5'b10101;//25
		end
		else Data_Bin_o = 5'b00000;//zero value
	
	end
endmodule",38,118
152,303,0,False,False,"module clk_test(
  input clk,
  input sysclk,
  output [31:0] snes_sysclk_freq
);

reg [31:0] snes_sysclk_freq_r;
assign snes_sysclk_freq = snes_sysclk_freq_r;

reg [31:0] sysclk_counter;
reg [31:0] sysclk_value;

initial snes_sysclk_freq_r = 32'hFFFFFFFF;
initial sysclk_counter = 0;
initial sysclk_value = 0;

reg [1:0] sysclk_sreg;
always @(posedge clk) sysclk_sreg <= {sysclk_sreg[0], sysclk};
wire sysclk_rising = (sysclk_sreg == 2'b01);

always @(posedge clk) begin
  if(sysclk_counter < 96000000) begin
    sysclk_counter <= sysclk_counter + 1;
    if(sysclk_rising) sysclk_value <= sysclk_value + 1;
  end else begin
    snes_sysclk_freq_r <= sysclk_value;
    sysclk_counter <= 0;
    sysclk_value <= 0;
  end
end

endmodule",32,119
170,222,0,False,False,"module Frequency(
    input wire clk,
	 input wire rst,
    input wire rand,
    output reg pass
    );
	 
parameter N = 20000, U = 10182, L = 9818;

reg [14:0] count_bits0, count_bits1, count_ones;

always @(posedge clk)
	if (rst) begin
		count_bits0 <= 15'H7FFF;
		count_bits1 <= 0;
		count_ones <= 0;
		pass <= 0;
	end
	else begin 
		count_bits0 <= count_bits0 + 1;
		count_bits1 <= count_bits0;
		if (count_bits0 == (N-1)) begin
			count_bits0 <= 0;
		end
		
		if (rand) count_ones <= count_ones + 1;				
		
		if (count_bits1 == (N-1)) begin
			count_ones <= rand;
			if ((count_ones <= U) && (count_ones >= L)) pass <= 1;
			else pass <= 0;
		end
	end

endmodule",35,132
3,1,0,False,False,"module sky130_fd_sc_ls__einvp (
    Z ,
    A ,
    TE
);

    // Module ports
    output Z ;
    input  A ;
    input  TE;

    //     Name     Output  Other arguments
    notif1 notif10 (Z     , A, TE          );

endmodule",15,133
12,3,0,False,False,"module AxiSSplitCopy #(
    parameter DATA_WIDTH = 64,
    parameter DEST_WIDTH = 0,
    parameter ID_WIDTH = 0,
    parameter INTF_CLS = ""<class 'hwtLib.amba.axis.AxiStream'>"",
    parameter IS_BIGENDIAN = 0,
    parameter OUTPUTS = 2,
    parameter USER_WIDTH = 0,
    parameter USE_KEEP = 0,
    parameter USE_STRB = 0
) (
    input wire[63:0] dataIn_data,
    input wire dataIn_last,
    output reg dataIn_ready,
    input wire dataIn_valid,
    output wire[63:0] dataOut_0_data,
    output wire dataOut_0_last,
    input wire dataOut_0_ready,
    output reg dataOut_0_valid,
    output wire[63:0] dataOut_1_data,
    output wire dataOut_1_last,
    input wire dataOut_1_ready,
    output reg dataOut_1_valid
);
    always @(dataOut_0_ready, dataOut_1_ready) begin: assig_process_dataIn_ready
        dataIn_ready = dataOut_0_ready & dataOut_1_ready;
    end

    assign dataOut_0_data = dataIn_data;
    assign dataOut_0_last = dataIn_last;
    always @(dataIn_valid, dataOut_1_ready) begin: assig_process_dataOut_0_valid
        dataOut_0_valid = dataIn_valid & dataOut_1_ready;
    end

    assign dataOut_1_data = dataIn_data;
    assign dataOut_1_last = dataIn_last;
    always @(dataIn_valid, dataOut_0_ready) begin: assig_process_dataOut_1_valid
        dataOut_1_valid = dataIn_valid & dataOut_0_ready;
    end

    generate if (DATA_WIDTH != 64)
        $error(""%m Generated only for this param value"");
    endgenerate

    generate if (DEST_WIDTH != 0)
        $error(""%m Generated only for this param value"");
    endgenerate

    generate if (ID_WIDTH != 0)
        $error(""%m Generated only for this param value"");
    endgenerate

    generate if (INTF_CLS != ""<class 'hwtLib.amba.axis.AxiStream'>"")
        $error(""%m Generated only for this param value"");
    endgenerate

    generate if (IS_BIGENDIAN != 0)
        $error(""%m Generated only for this param value"");
    endgenerate

    generate if (OUTPUTS != 2)
        $error(""%m Generated only for this param value"");
    endgenerate

    generate if (USER_WIDTH != 0)
        $error(""%m Generated only for this param value"");
    endgenerate

    generate if (USE_KEEP != 0)
        $error(""%m Generated only for this param value"");
    endgenerate

    generate if (USE_STRB != 0)
        $error(""%m Generated only for this param value"");
    endgenerate

endmodule",77,155
2,1,0,False,False,"module v3676a0_vd54ca1 (
 input a,
 output q
);
 //-- NOT Gate
 assign q = ~a;
 
 
endmodule",9,182
3,1,0,False,False,"module vba518e_vf4938a (
 input a,
 input b,
 output c
);
 //-- AND gate
 //-- Verilog implementation
 
 assign c = a & b;
 
endmodule",11,184
3,1,0,False,False,"module vd12401_vf4938a (
 input a,
 input b,
 output c
);
 //-- XOR gate
 //-- Verilog implementation
 
 assign c = a ^ b;
 
endmodule",11,194
3,1,0,False,False,"module v873425_vf4938a (
 input a,
 input b,
 output c
);
 //-- OR Gate
 //-- Verilog implementation
 
 assign c = a | b;
 
 
endmodule",12,210
3,1,0,False,False,"module v053dc2_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 output q
);
 //-- Initial value
 reg q = INI;
 
 //-- Capture the input data  
 //-- on the rising edge of  
 //-- the system clock
 always @(posedge clk)
   q <= d;
endmodule",16,223
87,122,0,True,False,"module altera_up_character_lcd_communication (
	// Inputs
	clk,
	reset,

	data_in,
	enable,
	rs,
	rw,

	display_on,
	back_light_on,

	// Bidirectionals
	LCD_DATA,

	// Outputs
	LCD_ON,
	LCD_BLON,

	LCD_EN,
	LCD_RS,
	LCD_RW,

	data_out,
	transfer_complete
);

/*****************************************************************************
 *                           Parameter Declarations                          *
 *****************************************************************************/

// Timing info for minimum wait between consecutive communications 
//   if using a 50MHz Clk
parameter	CLOCK_CYCLES_FOR_IDLE_STATE		= 7'h7F;	// Minimum 2500 ns
parameter	IC											= 7;		// Number of bits for idle counter
parameter	IDLE_COUNTER_INCREMENT				= 7'h01;

parameter	CLOCK_CYCLES_FOR_OPERATION_STATE	= 3;		// Minimum  40 ns
parameter	CLOCK_CYCLES_FOR_ENABLE_STATE		= 15;		// Minimum 230 ns
parameter	CLOCK_CYCLES_FOR_HOLD_STATE		= 1;		// Minimum  10 ns
parameter	SC											= 4;		// Number of bits for states counter
parameter	COUNTER_INCREMENT						= 4'h1;

/*****************************************************************************
 *                             Port Declarations                             *
 *****************************************************************************/
// Inputs
input						clk;
input						reset;

input			[ 7: 0]	data_in;
input						rs;
input						rw;
input						enable;

input						display_on;
input						back_light_on;

// Bidirectionals
inout			[ 7: 0]	LCD_DATA;

// Outputs
output reg				LCD_ON;
output reg				LCD_BLON;

output reg				LCD_EN;
output reg				LCD_RS;
output reg				LCD_RW;

output reg	[ 7: 0]	data_out;			// Stores data read from the LCD
output reg				transfer_complete;	// Indicates the end of the transfer

/*****************************************************************************
 *                           Constant Declarations                           *
 *****************************************************************************/
// states
parameter	LCD_STATE_4_IDLE			= 3'h4,
				LCD_STATE_0_OPERATION	= 3'h0,
				LCD_STATE_1_ENABLE		= 3'h1,
				LCD_STATE_2_HOLD			= 3'h2,
				LCD_STATE_3_END			= 3'h3;

/*****************************************************************************
 *                 Internal Wires and Registers Declarations                 *
 *****************************************************************************/
// Internal Wires

// Internal Registers
reg			[ 7: 0]	data_to_lcd;

reg			[IC: 1]	idle_counter;
reg			[SC: 1]	state_0_counter;
reg			[SC: 1]	state_1_counter;
reg			[SC: 1]	state_2_counter;

// State Machine Registers
reg			[ 2: 0]	ns_lcd;
reg			[ 2: 0]	s_lcd;

/*****************************************************************************
 *                         Finite State Machine(s)                           *
 *****************************************************************************/

always @(posedge clk)
begin
	if (reset)
		s_lcd <= LCD_STATE_4_IDLE;
	else
		s_lcd <= ns_lcd;
end

always @(*)
begin
	ns_lcd = LCD_STATE_4_IDLE;

   case (s_lcd)
	LCD_STATE_4_IDLE:
		begin
			if ((idle_counter == CLOCK_CYCLES_FOR_IDLE_STATE) & enable)
				ns_lcd = LCD_STATE_0_OPERATION;
			else
				ns_lcd = LCD_STATE_4_IDLE;
		end
	LCD_STATE_0_OPERATION:
		begin
			if (state_0_counter == CLOCK_CYCLES_FOR_OPERATION_STATE)
				ns_lcd = LCD_STATE_1_ENABLE;
			else
				ns_lcd = LCD_STATE_0_OPERATION;
		end
	LCD_STATE_1_ENABLE:
		begin
			if (state_1_counter == CLOCK_CYCLES_FOR_ENABLE_STATE)
				ns_lcd = LCD_STATE_2_HOLD;
			else
				ns_lcd = LCD_STATE_1_ENABLE;
		end
	LCD_STATE_2_HOLD:
		begin
			if (state_2_counter == CLOCK_CYCLES_FOR_HOLD_STATE)
				ns_lcd = LCD_STATE_3_END;
			else
				ns_lcd = LCD_STATE_2_HOLD;
		end
	LCD_STATE_3_END:
		begin
			if (enable == 1'b0)
				ns_lcd = LCD_STATE_4_IDLE;
			else
				ns_lcd = LCD_STATE_3_END;
		end
	default:
		begin
			ns_lcd = LCD_STATE_4_IDLE;
		end
	endcase
end


/*****************************************************************************
 *                             Sequential Logic                              *
 *****************************************************************************/

always @(posedge clk)
begin
	if (reset)
	begin
		LCD_ON 	<= 1'b0;
		LCD_BLON <= 1'b0;
	end
	else
	begin
		LCD_ON 	<= display_on;
		LCD_BLON <= back_light_on;
	end
end

always @(posedge clk)
begin
	if (reset)
	begin
		LCD_EN				<= 1'b0;
		LCD_RS				<= 1'b0;
		LCD_RW				<= 1'b0;
		data_out				<= 8'h00;
		transfer_complete	<= 1'b0;
	end
	else
	begin
		if (s_lcd == LCD_STATE_1_ENABLE)
			LCD_EN		<= 1'b1;
		else
			LCD_EN		<= 1'b0;

		if (s_lcd == LCD_STATE_4_IDLE)
		begin
			LCD_RS		<= rs;
			LCD_RW		<= rw;
			
			data_to_lcd <= data_in;
		end

		if (s_lcd == LCD_STATE_1_ENABLE)
			data_out	<= LCD_DATA;

		if (s_lcd == LCD_STATE_3_END)
			transfer_complete	<= 1'b1;
		else
			transfer_complete	<= 1'b0;
	end
end

always @(posedge clk)
begin
	if (reset)
		idle_counter <= {IC{1'b0}};
	else if (s_lcd == LCD_STATE_4_IDLE)
		idle_counter <= idle_counter + IDLE_COUNTER_INCREMENT;
	else
		idle_counter <= {IC{1'b0}};
end

always @(posedge clk)
begin
	if (reset)
	begin
		state_0_counter <= {SC{1'b0}};
		state_1_counter <= {SC{1'b0}};
		state_2_counter <= {SC{1'b0}};
	end
	else
	begin
		if (s_lcd == LCD_STATE_0_OPERATION)
			state_0_counter <= state_0_counter + COUNTER_INCREMENT;
		else
			state_0_counter <= {SC{1'b0}};

		if (s_lcd == LCD_STATE_1_ENABLE)
			state_1_counter <= state_1_counter + COUNTER_INCREMENT;
		else
			state_1_counter <= {SC{1'b0}};

		if (s_lcd == LCD_STATE_2_HOLD)
			state_2_counter <= state_2_counter + COUNTER_INCREMENT;
		else
			state_2_counter <= {SC{1'b0}};
	end
end

/*****************************************************************************
 *                            Combinational Logic                            *
 *****************************************************************************/

assign LCD_DATA	= 
		(((s_lcd == LCD_STATE_1_ENABLE) ||
		  (s_lcd == LCD_STATE_2_HOLD)) &&
		  (LCD_RW == 1'b0)) ? data_to_lcd : 8'hzz;

/*****************************************************************************
 *                              Internal Modules                             *
 *****************************************************************************/


endmodule",265,256
5,8,0,False,False,"module sync_r2w #(parameter ADDRSIZE = 3)
  (output reg [ADDRSIZE:0] wq2_rptr,
   input [ADDRSIZE:0] rptr,
   input wclk, wrst_n);

   reg [ADDRSIZE:0] wq1_rptr;
   
   always @(posedge wclk or negedge wrst_n)
     
     if (!wrst_n) {wq2_rptr,wq1_rptr} <= 0;
   
     else {wq2_rptr,wq1_rptr} <= {wq1_rptr,rptr};
   
endmodule",14,258
5,8,0,False,False,"module sync_w2r #(parameter ADDRSIZE = 3)
  (output reg [ADDRSIZE:0] rq2_wptr,
   input [ADDRSIZE:0] wptr,
   input rclk, rrst_n);
   
   reg [ADDRSIZE:0] rq1_wptr;
   
   always @(posedge rclk or negedge rrst_n)
     
     if (!rrst_n) {rq2_wptr,rq1_wptr} <= 0;
   
     else {rq2_wptr,rq1_wptr} <= {rq1_wptr,wptr};
   
endmodule",14,259
49,52,0,False,False,"module wptr_full 
  #(parameter ADDRSIZE = 3,
    parameter ALMOST_FULL_SIZE=5
    )
  (output reg wfull,
   output reg w_almost_full,
   output [ADDRSIZE-1:0] waddr,
   output reg [ADDRSIZE :0] wptr,
   input [ADDRSIZE :0] wq2_rptr,
   input winc, wclk, wrst_n);
      
   reg [ADDRSIZE:0] wbin;
   wire [ADDRSIZE:0] wgraynext, wbinnext;
   reg [ADDRSIZE :0] wq2_rptr_bin;
   integer 	     i;
      
   // GRAYSTYLE2 pointer
   
   always @(posedge wclk or negedge wrst_n)
     if (!wrst_n) {wbin, wptr} <= 0;
     else {wbin, wptr} <= {wbinnext, wgraynext};
      
   // Memory write-address pointer (okay to use binary to address memory)
   assign waddr = wbin[ADDRSIZE-1:0];
   
   assign wbinnext = wbin + (winc & ~wfull);
   assign wgraynext = (wbinnext>>1) ^ wbinnext;
   
   
   //-----------------------------------------------------------------
   // Simplified version of the three necessary full-tests:
   // assign wfull_val=((wgnext[ADDRSIZE] !=wq2_rptr[ADDRSIZE] ) &&
   // (wgnext[ADDRSIZE-1] !=wq2_rptr[ADDRSIZE-1]) &&
   // (wgnext[ADDRSIZE-2:0]==wq2_rptr[ADDRSIZE-2:0]));
   //-----------------------------------------------------------------
   wire wfull_val = (wgraynext ==
		     {~wq2_rptr[ADDRSIZE:ADDRSIZE-1],wq2_rptr[ADDRSIZE-2:0]});

   // Gray code to Binary code conversion
   always @(wq2_rptr)
     for (i=0; i<(ADDRSIZE+1); i=i+1)
       wq2_rptr_bin[i] = ^ (wq2_rptr >> i);

   wire [ADDRSIZE :0] subtract = wbinnext - wq2_rptr_bin - ALMOST_FULL_SIZE;
   
   wire w_almost_full_val = ~subtract[ADDRSIZE];
      
   always @(posedge wclk or negedge wrst_n)
     if (!wrst_n) begin 
	wfull <= 1'b0;
	w_almost_full <= 1'b 0;
     end
     else begin 
	wfull <= wfull_val;
	w_almost_full <= w_almost_full_val;
     end

endmodule",58,260
85,142,0,False,False,"module fifo_mem #(parameter DATASIZE = 8, // Memory data word width
		 parameter ADDRSIZE = 3) // Number of mem address bits
  
  (output [DATASIZE-1:0] rdata,
   input [DATASIZE-1:0] wdata,
   input [ADDRSIZE-1:0] waddr, raddr,
   input wclken, wfull, wclk);
   
   // RTL Verilog memory model
   localparam DEPTH = 1<<ADDRSIZE;
   
   reg [DATASIZE-1:0] mem [0:DEPTH-1];
      
   assign rdata = mem[raddr];
   
   always @(posedge wclk)
     if (wclken && !wfull) mem[waddr] <= wdata;
   
endmodule",19,261
32,79,0,False,False,"module wb_mux (sys_clk,
               resetcpu,
               
               // High priority bus
               h_cyc,
               h_stb,
               h_we,
               h_sel,
               h_ack,
               h_adr,
               h_dat_o,
               h_dat_i,

               // Low priority bus
               l_cyc,
               l_stb,
               l_we,
               l_sel,
               l_ack,
               l_adr,
               l_dat_o,
               l_dat_i,

               // Muxed bus
               m_cyc,
               m_stb,
               m_we,
               m_sel,
               m_ack,
               m_adr,
               m_dat_o,
               m_dat_i

);

input          sys_clk;
input          resetcpu;

input          h_cyc;
input          h_stb;
input          h_we;
input    [3:0] h_sel;
input   [31:0] h_adr;
input   [31:0] h_dat_o; // An input, but matches name of LM32 interface
output  [31:0] h_dat_i; // An output, but matches name of LM32 interface
output         h_ack;

input          l_cyc;
input          l_stb;
input          l_we;
input    [3:0] l_sel;
input   [31:0] l_adr;
input   [31:0] l_dat_o; // An input, but matches name of LM32 interface
output  [31:0] l_dat_i; // An output, but matches name of LM32 interface
output         l_ack;

output         m_cyc;
output         m_stb;
output         m_we;
output   [3:0] m_sel;
output  [31:0] m_adr;
output  [31:0] m_dat_o;
input   [31:0] m_dat_i;
input          m_ack;

reg            active;
reg            h_owns_bus_reg;

// Select high priority bus, if bus inactive and high priority bus
// requesting, or (when active), it is the selected bus.
wire   sel_h         = (h_cyc & ~active) | (h_owns_bus_reg & active);

// Mux the outputs from the two busses
assign m_cyc         = h_cyc | l_cyc;
assign m_stb         = sel_h ? h_stb   : l_stb;
assign m_we          = sel_h ? h_we    : l_we;
assign m_sel         = sel_h ? h_sel   : l_sel;
assign m_adr         = sel_h ? h_adr   : l_adr;
assign m_dat_o       = sel_h ? h_dat_o : l_dat_o;

// Route read data back to sources (regardless of bus selection)
assign h_dat_i       = m_dat_i;
assign l_dat_i       = m_dat_i;

// Route ACK back to selected bus.
// Using h_owns_bus_reg assumes there can be no ACK earlier than the 
// next cycle. If ACK can be in the same cycle as assertion of m_cyc,
// then sel_h should be used, but this has slow timing and could, potentially,
// create a timing loop, as ack would then be dependant on <x>_cyc.
assign h_ack         =  h_owns_bus_reg & m_ack;
assign l_ack         = ~h_owns_bus_reg & m_ack;

always @(posedge sys_clk  or posedge resetcpu)
begin
  if (resetcpu == 1'b1)
  begin
    active          <= 1'b0;
    h_owns_bus_reg  <= 1'b0;
  end
  else
  begin
    // Go active (and hold) if either bus requesting, clearing state on the returned ACK
    active          <= (active | h_cyc | l_cyc) & ~m_ack;
    
    // Flag high priority bus ownership, and hold, or if that bus requesting and inactive.
    h_owns_bus_reg  <= (active & h_owns_bus_reg) | (~active & h_cyc);
  end
end

endmodule",110,278
12,3,0,False,False,"module sky130_fd_sc_ms__a2bb2oi (
    Y   ,
    A1_N,
    A2_N,
    B1  ,
    B2
);

    // Module ports
    output Y   ;
    input  A1_N;
    input  A2_N;
    input  B1  ;
    input  B2  ;

    // Module supplies
    supply1 VPWR;
    supply0 VGND;
    supply1 VPB ;
    supply0 VNB ;

    // Local signals
    wire and0_out  ;
    wire nor0_out  ;
    wire nor1_out_Y;

    //  Name  Output      Other arguments
    and and0 (and0_out  , B1, B2            );
    nor nor0 (nor0_out  , A1_N, A2_N        );
    nor nor1 (nor1_out_Y, nor0_out, and0_out);
    buf buf0 (Y         , nor1_out_Y        );

endmodule",33,283
92,146,0,False,False,"module spi_slave_0_base(
clk,sck,mosi,miso,ssel,rst_n,recived_status
);

input clk;
input rst_n;
input sck,mosi,ssel;
output miso;
output recived_status;

reg recived_status;
reg[2:0] sckr;
reg[2:0] sselr;
reg[1:0] mosir;
reg[2:0] bitcnt;
reg[7:0] bytecnt;
reg byte_received;  // high when a byte has been received
reg [7:0] byte_data_received;
reg[7:0] received_memory;
reg [7:0] byte_data_sent;
reg [7:0] cnt;

wire ssel_active;
wire sck_risingedge;
wire sck_fallingedge;
wire ssel_startmessage;
wire ssel_endmessage;
wire mosi_data;
/*******************************************************************************
*detect the rising edge and falling edge of sck
*******************************************************************************/
always @(posedge clk or negedge rst_n)begin
	if(!rst_n)
		sckr <= 3'h0;
	else
		sckr <= {sckr[1:0],sck};
end

assign sck_risingedge = (sckr[2:1] == 2'b01) ? 1'b1 : 1'b0;
assign sck_fallingedge = (sckr[2:1] == 2'b10) ? 1'b1 : 1'b0;

/*******************************************************************************
*detect starts at falling edge and stops at rising edge of ssel
*******************************************************************************/
always @(posedge clk or negedge rst_n)begin
	if(!rst_n)
		sselr <= 3'h0;
	else
		sselr <= {sselr[1:0],ssel};
end

assign  ssel_active = (~sselr[1]) ? 1'b1 : 1'b0;  // SSEL is active low
assign  ssel_startmessage = (sselr[2:1]==2'b10) ? 1'b1 : 1'b0;  // message starts at falling edge
assign  ssel_endmessage = (sselr[2:1]==2'b01) ? 1'b1 : 1'b0;  // message stops at rising edge

/*******************************************************************************
*read from mosi
*******************************************************************************/
always @(posedge clk or negedge rst_n)begin
	if(!rst_n)
		mosir <= 2'h0;
	else
		mosir <={mosir[0],mosi};
end

assign mosi_data = mosir[1];

/*******************************************************************************
*SPI slave reveive in 8-bits format
*******************************************************************************/
always @(posedge clk or negedge rst_n)begin
  if(!rst_n)begin
	bitcnt <= 3'b000;
	byte_data_received <= 8'h0;
  end
  else begin
   if(~ssel_active)
     bitcnt <= 3'b000;
   else begin
      if(sck_risingedge)begin
        bitcnt <= bitcnt + 3'b001;
        byte_data_received <= {byte_data_received[6:0], mosi_data};
      end
		else begin
		  bitcnt <= bitcnt;
        byte_data_received <= byte_data_received;
		end
	  end
  end
end

always @(posedge clk or negedge rst_n) begin
	if(!rst_n)
		byte_received <= 1'b0;
	else
		byte_received <= ssel_active && sck_risingedge && (bitcnt==3'b111);
end

always @(posedge clk or negedge rst_n) begin
	if(!rst_n)begin
		bytecnt <= 8'h0;
		received_memory <= 8'h0;
	end
   else begin 
	 if(byte_received) begin
		  bytecnt <= bytecnt + 1'b1;
	     received_memory <= (byte_data_received == bytecnt) ? (received_memory + 1'b1) : received_memory;
	 end
	 else begin
		  bytecnt <= bytecnt;
	     received_memory <= received_memory;
	 end
	end
end

/*******************************************************************************
*SPI  slave send date 
*******************************************************************************/
always @(posedge clk or negedge rst_n) begin
	 if(!rst_n)
	  cnt<= 8'h0;
	 else begin
     if(byte_received) 
			cnt<=cnt+8'h1;  // count the messages
		else
			cnt<=cnt;
    end
end

always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
		byte_data_sent <= 8'h0;
	 else begin
      if(ssel_active && sck_fallingedge) begin
          if(bitcnt==3'b000)
               byte_data_sent <= cnt;  // after that, we send 0s
           else
               byte_data_sent <= {byte_data_sent[6:0], 1'b0};
		end
		else
			byte_data_sent <= byte_data_sent;
	end
end

assign miso = byte_data_sent[7];  // send MSB first

always @(posedge clk or negedge rst_n) begin
	 if(!rst_n)
	  recived_status <= 1'b0;
	 else 
	  recived_status <= (received_memory == 8'd64) ? 1'b1 : 1'b0;
end

endmodule",154,294
20,256,0,False,False,"module axi_ad9144_if (

  // jesd interface
  // tx_clk is (line-rate/40)

  tx_clk,
  tx_data,

  // dac interface

  dac_clk,
  dac_rst,
  dac_data_0_0,
  dac_data_0_1,
  dac_data_0_2,
  dac_data_0_3,
  dac_data_1_0,
  dac_data_1_1,
  dac_data_1_2,
  dac_data_1_3,
  dac_data_2_0,
  dac_data_2_1,
  dac_data_2_2,
  dac_data_2_3,
  dac_data_3_0,
  dac_data_3_1,
  dac_data_3_2,
  dac_data_3_3);

  // jesd interface
  // tx_clk is (line-rate/40)

  input           tx_clk;
  output [255:0]  tx_data;

  // dac interface

  output          dac_clk;
  input           dac_rst;
  input   [15:0]  dac_data_0_0;
  input   [15:0]  dac_data_0_1;
  input   [15:0]  dac_data_0_2;
  input   [15:0]  dac_data_0_3;
  input   [15:0]  dac_data_1_0;
  input   [15:0]  dac_data_1_1;
  input   [15:0]  dac_data_1_2;
  input   [15:0]  dac_data_1_3;
  input   [15:0]  dac_data_2_0;
  input   [15:0]  dac_data_2_1;
  input   [15:0]  dac_data_2_2;
  input   [15:0]  dac_data_2_3;
  input   [15:0]  dac_data_3_0;
  input   [15:0]  dac_data_3_1;
  input   [15:0]  dac_data_3_2;
  input   [15:0]  dac_data_3_3;

  // internal registers

  reg    [255:0]  tx_data = 'd0;

  // reorder data for the jesd links

  assign dac_clk = tx_clk;

  always @(posedge dac_clk) begin
    if (dac_rst == 1'b1) begin
      tx_data <= 256'd0;
    end else begin
      tx_data[255:248] <= dac_data_3_3[ 7: 0];
      tx_data[247:240] <= dac_data_3_2[ 7: 0];
      tx_data[239:232] <= dac_data_3_1[ 7: 0];
      tx_data[231:224] <= dac_data_3_0[ 7: 0];
      tx_data[223:216] <= dac_data_3_3[15: 8];
      tx_data[215:208] <= dac_data_3_2[15: 8];
      tx_data[207:200] <= dac_data_3_1[15: 8];
      tx_data[199:192] <= dac_data_3_0[15: 8];
      tx_data[191:184] <= dac_data_2_3[ 7: 0];
      tx_data[183:176] <= dac_data_2_2[ 7: 0];
      tx_data[175:168] <= dac_data_2_1[ 7: 0];
      tx_data[167:160] <= dac_data_2_0[ 7: 0];
      tx_data[159:152] <= dac_data_2_3[15: 8];
      tx_data[151:144] <= dac_data_2_2[15: 8];
      tx_data[143:136] <= dac_data_2_1[15: 8];
      tx_data[135:128] <= dac_data_2_0[15: 8];
      tx_data[127:120] <= dac_data_1_3[ 7: 0];
      tx_data[119:112] <= dac_data_1_2[ 7: 0];
      tx_data[111:104] <= dac_data_1_1[ 7: 0];
      tx_data[103: 96] <= dac_data_1_0[ 7: 0];
      tx_data[ 95: 88] <= dac_data_1_3[15: 8];
      tx_data[ 87: 80] <= dac_data_1_2[15: 8];
      tx_data[ 79: 72] <= dac_data_1_1[15: 8];
      tx_data[ 71: 64] <= dac_data_1_0[15: 8];
      tx_data[ 63: 56] <= dac_data_0_3[ 7: 0];
      tx_data[ 55: 48] <= dac_data_0_2[ 7: 0];
      tx_data[ 47: 40] <= dac_data_0_1[ 7: 0];
      tx_data[ 39: 32] <= dac_data_0_0[ 7: 0];
      tx_data[ 31: 24] <= dac_data_0_3[15: 8];
      tx_data[ 23: 16] <= dac_data_0_2[15: 8];
      tx_data[ 15:  8] <= dac_data_0_1[15: 8];
      tx_data[  7:  0] <= dac_data_0_0[15: 8];
    end
  end

endmodule",104,354
1170,1353,0,False,False,"module antiDroopIIR_16 (
	input clk,
	input trig,
	input signed [15:0] din,
	input signed [6:0] tapWeight,
	input accClr_en,
	//input oflowClr,
	(* shreg_extract = ""no"" *) output reg oflowDetect = 1'd0,
	output reg signed [15:0] dout = 16'sd0);

parameter IIR_scale = 15; // define the scaling factor for the IIR multiplier, eg for 0.002 (din = 63, IIR_scale = 15).

//`define ADDPIPEREG

(* shreg_extract = ""no"" *) reg signed [15:0] din_del = 16'sd0;
`ifdef ADDPIPEREG (* shreg_extract = ""no"" *) reg signed [15:0] din_del_b = 16'sd0;
`endif
reg signed [47:0] tap = 48'sd0;
reg signed [22:0] multreg = 23'sd0;

(* equivalent_register_removal = ""no"" *) reg trig_a = 1'b0, trig_b = 1'b0;
wire trig_edge = trig_a & ~trig_b;
//reg trig_edge = 1'b0;
(* shreg_extract = ""no"" *) reg signed [6:0] tapWeight_a = 7'sd0, tapWeight_b = 7'sd0;

//wire oflow = (^tap[IIR_scale+16:IIR_scale+15]);
wire oflow = (~&tap[47:IIR_scale+15] && ~&(~tap[47:IIR_scale+15]));


always @(posedge clk) begin
	//trig_edge <= trig_a & ~trig_b;
	tapWeight_a <= tapWeight;
	tapWeight_b <= tapWeight_a;
	trig_a <= trig;
	trig_b <= trig_a;
	din_del <= din;
	`ifdef ADDPIPEREG
		din_del_b <= din_del;
		multreg <= din_del*tapWeight_b;
		//dout <= din_del_b + tap[IIR_scale+15:IIR_scale];
		if (oflow) dout <= (tap[IIR_scale+16]) ? -16'sd32768 : 16'sd32767;
		else dout <= din_del_b + tap[IIR_scale+15:IIR_scale];
	`else
		multreg <= din*tapWeight_b;
		//dout <= din_del + tap[IIR_scale+15:IIR_scale];
		if (oflow) dout <= (tap[IIR_scale+16]) ? -16'sd32768 : 16'sd32767;
		else dout <= din_del + tap[IIR_scale+15:IIR_scale];
	`endif
	if (trig_edge && accClr_en) tap <= 48'sd0;
	else tap <= multreg + tap;
	//tap <= din*tapWeight + tap;
	//if (oflowDetect && oflowClr) oflowDetect <= 1'b0;
	//else if ((~& tap[47:IIR_scale+12]) || (& ~tap[47:IIR_scale+12])) oflowDetect <= 1'b1;
	//else if ((~& tap[47:IIR_scale+12]) || (& tap[47:IIR_scale+12])) oflowDetect <= 1'b1;
	//else if (^ tap[IIR_scale+16:IIR_scale+15]) oflowDetect <= 1'b1;
	//else oflowDetect <= oflowDetect;
	//oflowDetect <= (^tap[IIR_scale+16:IIR_scale+15]) ? 1'b1 : 1'b0;
	oflowDetect <= oflow;
end

endmodule",61,357
9290,9193,0,False,False,"module execute_mul_booth32(
		//iDATA
		input wire [31:0] iDATA_0,
		input wire [31:0] iDATA_1,
		//oDATA
		output wire [63:0] oDATA,
		output wire oHSF,
		output wire oHOF,				
		output wire oHCF,
		output wire oHPF,
		output wire oHZF,
		output wire oLSF,
		output wire oLOF,				
		output wire oLCF,
		output wire oLPF,
		output wire oLZF
	);
				

	/****************************************
	wire
	****************************************/
	wire [63:0] w_tmp_out;
	wire [63:0] w0_tmp;
	wire [63:0] w1_tmp;
	wire [63:0] w2_tmp;
	wire [63:0] w3_tmp;
	wire [63:0] w4_tmp;
	wire [63:0] w5_tmp;
	wire [63:0] w6_tmp;
	wire [63:0] w7_tmp;
	wire [63:0] w8_tmp;
	wire [63:0] w9_tmp;
	wire [63:0] w10_tmp;
	wire [63:0] w11_tmp;
	wire [63:0] w12_tmp;
	wire [63:0] w13_tmp;
	wire [63:0] w14_tmp;
	wire [63:0] w15_tmp;
	wire [63:0] w16_tmp;


	/****************************************
	Booth - Encoder
	****************************************/
	assign w0_tmp = func_booth_algorithm(iDATA_0, iDATA_1[1], iDATA_1[0], 1'b0);
	assign w1_tmp = func_booth_algorithm(iDATA_0, iDATA_1[3], iDATA_1[2], iDATA_1[1]);
	assign w2_tmp = func_booth_algorithm(iDATA_0, iDATA_1[5], iDATA_1[4], iDATA_1[3]);
	assign w3_tmp = func_booth_algorithm(iDATA_0, iDATA_1[7], iDATA_1[6], iDATA_1[5]);
	assign w4_tmp = func_booth_algorithm(iDATA_0, iDATA_1[9], iDATA_1[8], iDATA_1[7]);
	assign w5_tmp = func_booth_algorithm(iDATA_0, iDATA_1[11], iDATA_1[10], iDATA_1[9]);
	assign w6_tmp = func_booth_algorithm(iDATA_0, iDATA_1[13], iDATA_1[12], iDATA_1[11]);
	assign w7_tmp = func_booth_algorithm(iDATA_0, iDATA_1[15], iDATA_1[14], iDATA_1[13]);
	assign w8_tmp = func_booth_algorithm(iDATA_0, iDATA_1[17], iDATA_1[16], iDATA_1[15]);
	assign w9_tmp = func_booth_algorithm(iDATA_0, iDATA_1[19], iDATA_1[18], iDATA_1[17]);
	assign w10_tmp = func_booth_algorithm(iDATA_0, iDATA_1[21], iDATA_1[20], iDATA_1[19]);
	assign w11_tmp = func_booth_algorithm(iDATA_0, iDATA_1[23], iDATA_1[22], iDATA_1[21]);
	assign w12_tmp = func_booth_algorithm(iDATA_0, iDATA_1[25], iDATA_1[24], iDATA_1[23]);
	assign w13_tmp = func_booth_algorithm(iDATA_0, iDATA_1[27], iDATA_1[26], iDATA_1[25]);
	assign w14_tmp = func_booth_algorithm(iDATA_0, iDATA_1[29], iDATA_1[28], iDATA_1[27]);
	assign w15_tmp = func_booth_algorithm(iDATA_0, iDATA_1[31], iDATA_1[30], iDATA_1[29]);
	assign w16_tmp = func_booth_algorithm(iDATA_0, 1'b0, 1'b0, iDATA_1[31]);


	/****************************************
	Booth - Exeout
	****************************************/
	assign w_tmp_out = w0_tmp + w1_tmp<<2 + w2_tmp<<4 + w3_tmp<<6 + 
						w4_tmp<<8 + w5_tmp<<10 + w6_tmp<<12 + w7_tmp<<14 + 
						w8_tmp<<16 + w9_tmp<<18 + w10_tmp<<20 + w11_tmp<<22 + 
						w12_tmp<<24 + w13_tmp<<26 + w14_tmp<<28 + w15_tmp<<30 + w16_tmp<<32;

				
	function [63:0] func_booth_algorithm;
		input [31:0] func_booth_algorithm_a;
		input func_booth_algorithm_b2;
		input func_booth_algorithm_b1;
		input func_booth_algorithm_b0;
		reg [2:0] reg_func_booth_algorithm_tmp;
		reg [2:0] reg_func_booth_algorithm_cmd;
		begin
			reg_func_booth_algorithm_tmp = {func_booth_algorithm_b2, func_booth_algorithm_b1, func_booth_algorithm_b0};
			case(reg_func_booth_algorithm_tmp)
				3'h0 : reg_func_booth_algorithm_cmd = 3'h0;
				3'h1 : reg_func_booth_algorithm_cmd = 3'h1;
				3'h2 : reg_func_booth_algorithm_cmd = 3'h1;
				3'h3 : reg_func_booth_algorithm_cmd = 3'h2;
				3'h4 : reg_func_booth_algorithm_cmd = {1'b1, 2'h2};
				3'h5 : reg_func_booth_algorithm_cmd = {1'b1, 2'h1};
				3'h6 : reg_func_booth_algorithm_cmd = {1'b1, 2'h1};
				default : reg_func_booth_algorithm_cmd = 3'h0;
			endcase
			if(reg_func_booth_algorithm_cmd[2] == 0)begin
				//Plus
				if(reg_func_booth_algorithm_cmd[1:0] == 2'h0)begin
					func_booth_algorithm = {32{1'b0}};
				end
				else if(reg_func_booth_algorithm_cmd[1:0] == 2'h1)begin
					func_booth_algorithm = {{32{1'b0}}, func_booth_algorithm_a};
				end
				else begin
					func_booth_algorithm = {{32{1'b0}}, func_booth_algorithm_a} << 1;
				end
			end
			else begin
				if(reg_func_booth_algorithm_cmd[1:0] == 2'h0)begin
					func_booth_algorithm = {32{1'b0}};
				end
				else if(reg_func_booth_algorithm_cmd[1:0] == 2'h1)begin
					func_booth_algorithm = -{{32{1'b0}}, func_booth_algorithm_a};//(~{{32{1'b0}}, func_booth_algorithm_a}) + {{63{1'b0}}, 1'b1};
				end
				else begin
					func_booth_algorithm = -({{32{1'b0}}, func_booth_algorithm_a} << 1);//(~({{32{1'b0}}, func_booth_algorithm_a} << 1)) + {{63{1'b0}}, 1'b1};
				end
			end
		end
	endfunction	
	
	/****************************************
	Assign
	****************************************/
	assign oDATA = w_tmp_out;
	assign oLSF = w_tmp_out[31];
	assign oLCF = w_tmp_out[32];
	assign oLOF = w_tmp_out[32] ^ w_tmp_out[31];
	assign oLPF = w_tmp_out[0];
	assign oLZF = (w_tmp_out == {64{1'b0}})? 1'b1 : 1'b0;	//(w_tmp_out[32:0] == {33{1'b0}})? 1'b1 : 1'b0;
	assign oHSF = w_tmp_out[32];
	assign oHCF = 1'b0;
	assign oHOF = w_tmp_out[63];
	assign oHPF = w_tmp_out[32];
	assign oHZF = (w_tmp_out == {64{1'b0}})? 1'b1 : 1'b0;	//(w_tmp_out == {64{1'b0}})? 1'b1 : 1'b0;
		
endmodule",134,359
788,895,0,False,False,"module tmu2_geninterp18(
	input sys_clk,

	input load,
	input next_point,
	input signed [17:0] init,
	input positive,
	input [16:0] q,
	input [16:0] r,
	input [16:0] divisor,

	output signed [17:0] o
);

reg positive_r;
reg [16:0] q_r;
reg [16:0] r_r;
reg [16:0] divisor_r;

always @(posedge sys_clk) begin
	if(load) begin
		positive_r <= positive;
		q_r <= q;
		r_r <= r;
		divisor_r <= divisor;
	end
end

reg [17:0] err;
reg correct;
reg signed [17:0] o_r;
assign o = o_r;

always @(posedge sys_clk) begin
	if(load) begin
		err = 18'd0;
		o_r = init;
	end else if(next_point) begin
		err = err + r_r;
		correct = (err[16:0] > {1'b0, divisor_r[16:1]}) & ~err[17];
		if(positive_r) begin
			o_r = o_r + {1'b0, q_r};
			if(correct)
				o_r = o_r + 18'd1;
		end else begin
			o_r = o_r - {1'b0, q_r};
			if(correct)
				o_r = o_r - 18'd1;
		end
		if(correct)
			err = err - {1'b0, divisor_r};
	end
end

endmodule",55,369
16,5,0,False,False,"module sky130_fd_sc_hd__a222oi (
    Y ,
    A1,
    A2,
    B1,
    B2,
    C1,
    C2
);

    // Module ports
    output Y ;
    input  A1;
    input  A2;
    input  B1;
    input  B2;
    input  C1;
    input  C2;

    // Module supplies
    supply1 VPWR;
    supply0 VGND;
    supply1 VPB ;
    supply0 VNB ;

    // Local signals
    wire nand0_out ;
    wire nand1_out ;
    wire nand2_out ;
    wire and0_out_Y;

    //   Name   Output      Other arguments
    nand nand0 (nand0_out , A2, A1                         );
    nand nand1 (nand1_out , B2, B1                         );
    nand nand2 (nand2_out , C2, C1                         );
    and  and0  (and0_out_Y, nand0_out, nand1_out, nand2_out);
    buf  buf0  (Y         , and0_out_Y                     );

endmodule",39,376
580,617,0,False,False,"module mac_scale 
   (input wire signed [39:0] to_scaling,
	     input wire [2:0] 		     c_scalefactor,
	     output wire 		     scale_overflow,
	     output reg [39:0] from_scaling);


   reg 					     scale_pos_overflow;
   reg 					     scale_neg_overflow;

   assign scale_overflow = scale_neg_overflow | scale_pos_overflow;
   // Mux for scaling
   always@(*) begin
      scale_pos_overflow = 0;
      scale_neg_overflow = 0;
      case (c_scalefactor)
	3'b000: begin
	   from_scaling=to_scaling;  // *1
	end
	3'b001: begin
	   from_scaling=to_scaling << 1;  // *2
	   scale_pos_overflow = ~to_scaling[39] & to_scaling[38];
	   scale_neg_overflow = to_scaling[39] & ~to_scaling[38];
	end
	3'b010: begin
	   from_scaling=to_scaling << 2;  // *4
	   scale_pos_overflow = ~to_scaling[39] & (|to_scaling[38:37]);
	   scale_neg_overflow = to_scaling[39] & ~(&to_scaling[38:37]);
	end
	3'b011: begin
	   from_scaling={to_scaling[39],to_scaling[39:1]};  // *0.5
	end
	3'b100: begin
	   from_scaling={{2{to_scaling[39]}},to_scaling[39:2]};  // *0.25
	end
	3'b101: begin
	   from_scaling={{3{to_scaling[39]}},to_scaling[39:3]};  // *0.125
	end
	3'b110: begin
	   from_scaling={{4{to_scaling[39]}},to_scaling[39:4]};  // *0.0625
	end
	3'b111: begin
	   from_scaling=to_scaling << 16; // *2^16
	   scale_pos_overflow = ~to_scaling[39] & (|to_scaling[38:23]);
	   scale_neg_overflow = to_scaling[39] & ~(&to_scaling[38:23]);
	end
      endcase
   end
   

endmodule",51,378
270,257,0,False,False,"module FLOW_CONTROLLER(
						clk,
						rst_n,
						init_rst_i,
						
						mrd_start_i,
						mrd_len_i,
						//mrd_cur_rd_count_i,
						mrd_tlp_sent_i,
						
						cpld_data_size_i,

						cfg_rd_comp_bound_i,
						rd_metering_i,
						
						mwr_start_i,
						trn_tbuf_av_i,
						
						mrd_start_fc_o,
						mwr_start_fc_o
    );
	
	// Set when the PCIe CORE was generated
	
	parameter			MAX_REQUEST_SIZE = 128;
	parameter			MAX_PAYLOAD_SIZE = 256;
	parameter			CPLH_CREDITS = 36;
	parameter			CPLD_CREDITS = 154;
	parameter			TRANSMIT_TLP_BUFFERD = 29;
	parameter			LIMIT_FC_MAX_NP = 18;

	input				clk;
	input				rst_n , init_rst_i;
	
	input				mrd_start_i;
	input [10:0]		mrd_len_i; // Memory Read Size Command (DWs)
	//input [15:0]		mrd_cur_rd_count_i;
	input [31:0]		mrd_tlp_sent_i;
	
	input				mwr_start_i;
	
	input [31:0]		cpld_data_size_i;
	input				cfg_rd_comp_bound_i; // Programmed RCB = 0=64B or 1=128B
	
	input				rd_metering_i; // enable send rate control
	
	input [5:0]			trn_tbuf_av_i;
	
	output				mrd_start_fc_o;
	output				mwr_start_fc_o;
	
	reg					mrd_start_fc_o;
	reg					mwr_start_fc_o;
	
	wire [31:0]			NPs_send = mrd_tlp_sent_i;
	wire [26:0]			NPs_recv = cpld_data_size_i >> 5;
	
	wire [26:0]			NPs_pending = NPs_send[26:0] - NPs_recv;

	always @ ( posedge clk ) begin
	
		if( !rst_n ) begin
		
			mrd_start_fc_o <= 1'b0;
			mwr_start_fc_o <= 1'b0;	
			
		end
		else begin
		
			if(init_rst_i) begin
			
				mrd_start_fc_o <= 1'b0;
				mwr_start_fc_o <= 1'b0;
			
			end
			
			if( rd_metering_i ) begin
			
`ifdef	SIMULATION

				if( NPs_pending > 0 )
					mrd_start_fc_o <= 1'b0;
				else
					mrd_start_fc_o <= mrd_start_i;
`else
				if ( ( NPs_pending < LIMIT_FC_MAX_NP + 5 ) && ( trn_tbuf_av_i > 1'b1 ) )
					mrd_start_fc_o <= mrd_start_i;
				else
					mrd_start_fc_o <= 1'b0;
`endif
			
			end
			else
				mrd_start_fc_o <= mrd_start_i;
				
			if( trn_tbuf_av_i > 1'b1  )
				mwr_start_fc_o <= mwr_start_i;
			else
				mwr_start_fc_o <= 1'b0;
		
		end
	
	end
	
endmodule",105,392
383,463,0,False,False,"module simpleio (
	input wire clk,
	input wire rst,
	input wire [3:0] AD,
	input wire [7:0] DI,
	output reg [7:0] DO,
	input wire rw,
	input wire cs,
	output wire irq,
	
	input wire clk_in,
	
	// physical connections
	output reg [7:0] leds,
	output reg [7:0] led7hi,
	output reg [7:0] led7lo,
	output reg [2:0] rgb1,
	output reg [2:0] rgb2,
	input wire  [3:0] switches,
	input wire  [3:0] keys
);
	reg [23:0] timer_cnt;
	reg [23:0] timer_prescaler;
	reg [7:0] timer_mode;
	reg timer_eq_flag;
	
	assign irq = timer_mode[7] & timer_mode[6];
	
	always @ (posedge clk_in) begin
		if (rst) begin
			timer_cnt <= 0;
			timer_eq_flag <= 0;
		end else begin
			if (timer_mode[0]) begin
				if (timer_cnt == timer_prescaler) begin
					timer_eq_flag <= 1;
					timer_cnt <= 0;
				end else begin
					timer_cnt <= timer_cnt + 1'b1;
					if (timer_mode[7]) timer_eq_flag <= 0;
				end
			end
		end
	end
	
	always @ (posedge clk) begin
		if (rst) begin
			leds <= 8'b11111111;
			rgb1 <= 8'b111;
			rgb2 <= 8'b111;
			led7hi <= 0;
			led7lo <= 0;
			timer_mode <= 0;
			timer_prescaler <= 0;
		end else begin
			if (timer_eq_flag) timer_mode[7] <= 1;

			if (cs) begin
				if (rw) begin
					case (AD[3:0])
					4'b0000: DO <= ~leds;
					4'b0001: DO <= led7hi;
					4'b0010: DO <= led7lo;
					4'b0011: begin
						DO[6:4] <= ~rgb1;
						DO[2:0] <= ~rgb2;
						end
					4'b0100: DO <= {switches, ~keys};
					4'b1000: begin
						DO <= timer_mode;
						timer_mode[7] <= 0;
						end
					4'b1001: DO <= timer_mode[0]?timer_cnt[23:16]:timer_prescaler[23:16];
					4'b1010: DO <= timer_mode[0]?timer_cnt[15:8]:timer_prescaler[15:8];
					4'b1011: DO <= timer_mode[0]?timer_cnt[7:0]:timer_prescaler[7:0];
					endcase
				end else begin
					case (AD[3:0])
					4'b0000: leds <= ~DI;
					4'b0001: led7hi <= DI;
					4'b0010: led7lo <= DI;
					4'b0011: begin
						rgb1 <= ~DI[6:4];
						rgb2 <= ~DI[2:0];
						end
					4'b1000: timer_mode[6:0] <= DI[6:0];
					4'b1001: timer_prescaler[23:16] <= DI;
					4'b1010: timer_prescaler[15:8] <= DI;
					4'b1011: timer_prescaler[7:0] <= DI;
					endcase
				end
			end
		end
	end
endmodule",95,405
213,393,0,False,False,"module NormaliseProd(
	input [35:0] cout_Multiply,
	input [35:0] zout_Multiply,
	input [31:0] sout_Multiply,
	input [49:0] productout_Multiply,
	input [1:0] modeout_Multiply,
	input operationout_Multiply,
	input NatLogFlagout_Multiply,
	input [7:0] InsTag_Multiply,
	input clock,
	input [1:0] idle_Multiply,
	output reg [1:0] idle_NormaliseProd,
	output reg [35:0] cout_NormaliseProd,
	output reg [35:0] zout_NormaliseProd,
	output reg [31:0] sout_NormaliseProd,
	output reg [1:0]  modeout_NormaliseProd,
	output reg operationout_NormaliseProd,
	output reg NatLogFlagout_NormaliseProd,
	output reg [49:0] productout_NormaliseProd,
	output reg [7:0] InsTag_NormaliseProd
   );
	 
parameter mode_circular  =2'b01, 
			 mode_linear    =2'b00, 
			 mode_hyperbolic=2'b11;

parameter no_idle = 2'b00,
			 allign_idle = 2'b01,
			 put_idle = 2'b10;

wire z_sign;
wire [7:0] z_exponent;
wire [26:0] z_mantissa;

assign z_sign = zout_Multiply[35];
assign z_exponent = zout_Multiply[34:27];
assign z_mantissa = {zout_Multiply[26:0]};

always @ (posedge clock) begin
	
	InsTag_NormaliseProd <= InsTag_Multiply;
	sout_NormaliseProd <= sout_Multiply;
	cout_NormaliseProd <= cout_Multiply;
	modeout_NormaliseProd <= modeout_Multiply;
	operationout_NormaliseProd <= operationout_Multiply;
	idle_NormaliseProd <= idle_Multiply;
	NatLogFlagout_NormaliseProd <= NatLogFlagout_Multiply;
	
	if (idle_Multiply == no_idle) begin
	
		// This case will never arise. This is because for input with exponent less than -12 multiply isn't used.
		if ($signed(z_exponent) < -126) begin
			zout_NormaliseProd[35] <= z_sign;
         zout_NormaliseProd[34:27] <= z_exponent + 1;
			zout_NormaliseProd[26:0]  <= z_mantissa;
         productout_NormaliseProd <= productout_Multiply >> 1;
		end
			
		// This could be problematic. Will have to test for average number of cycles
		// Current solution is to hard code for all cases like normalisation in addition.
		else if (productout_Multiply[49] == 0) begin
			zout_NormaliseProd[35] <= z_sign;
			zout_NormaliseProd[34:27] <= z_exponent - 1;
			//zout_NormaliseProd[26:0] <= product[48:25];
			zout_NormaliseProd[26:0] <= {productout_Multiply[48:25] , 3'd0};
			productout_NormaliseProd <= productout_Multiply << 1;
		end
		
		else begin
			zout_NormaliseProd[35] <= z_sign;
			zout_NormaliseProd[34:27] <= z_exponent;
			//z_mantissa <= productout_Multiply[49:26];
			zout_NormaliseProd[26:0] <= {productout_Multiply[49:26] , 3'd0};
			productout_NormaliseProd <= productout_Multiply;
		end	
	end
	
	else begin
		zout_NormaliseProd <= zout_Multiply;
	end
	
end

endmodule",84,411
287,316,0,False,False,"module state_control(
	input CLK, START, RESET, BTN_PLAYER1, BTN_PLAYER2,
	input [3:0] iSW,
	output [7:0] OLED,
	output reg [8:0] occupied,
	output reg [8:0] symbol
);

// state parameter
localparam IDLE = 2'd0;
localparam PLAYER1 = 2'd1;
localparam PLAYER2 = 2'd2;
localparam FINISH = 2'd3;
// win parameter
localparam NO_WIN = 2'd0;
localparam PLAYER1_WIN = 2'd1;
localparam PLAYER2_WIN = 2'd2;
localparam DRAW_GAME = 2'd3;



reg [1:0] WIN, state;
reg [1:0] next_win, next_state;

assign OLED = {WIN, 4'b0, state};

always @(posedge CLK)
begin
	if (RESET) begin
		state <= IDLE;
		WIN <= NO_WIN;
	end else begin
		state <= next_state;
		WIN <= next_win;
	end
end


// Drawing check.
reg py1_draw, py2_draw;
always @(*)
begin
	if (iSW > 0 && iSW <= 9 && ~occupied[iSW-1]) begin
		py1_draw = BTN_PLAYER1;
		py2_draw = BTN_PLAYER2;
	end else begin
		py1_draw = 1'b0;
		py2_draw = 1'b0;
	end
end

// Board drawing.
always @(posedge CLK)
begin
	if (RESET) begin
		occupied = 9'b0;
		symbol = 9'b0;
	end else if (iSW > 0 && iSW <= 9) begin
		if (state == PLAYER1 && py1_draw) begin
			occupied[iSW-1] = 1'b1;
			symbol[iSW-1] = 1'b0;
		end else if (state == PLAYER2 && py2_draw) begin
			occupied[iSW-1] = 1'b1;
			symbol[iSW-1] = 1'b1;
		end
	end
end

reg [8:0] next_occupied, next_symbol;


always @(*)
begin
	next_occupied = occupied;
	next_symbol = symbol;
	if ((state == PLAYER1 && py1_draw) || (state == PLAYER2 && py2_draw))
		next_occupied = occupied | (1'b1 << (iSW-1'b1));
	if (state == PLAYER2 && py2_draw)
		next_symbol = symbol | (1'b1 << (iSW-1'b1));
end

// Wining check.
always @(*)
begin
	if (WIN == PLAYER1_WIN)
		next_win = PLAYER1_WIN;
	else if (WIN == PLAYER2_WIN)
		next_win = PLAYER2_WIN;
	else if (WIN == DRAW_GAME)
		next_win = DRAW_GAME;
	else begin
		next_win = NO_WIN;
		if ((state == PLAYER1 && py1_draw) || (state == PLAYER2 && py2_draw)) begin
			if (next_occupied[0] && next_occupied[1] && next_occupied[2])
				if (next_symbol[0] == next_symbol[1] && next_symbol[1] == next_symbol[2])
					if (next_symbol[0])
						next_win = PLAYER2_WIN;
					else
						next_win = PLAYER1_WIN;

			if (next_occupied[3] && next_occupied[4] && next_occupied[5])
				if (next_symbol[3] == next_symbol[4] && next_symbol[4] == next_symbol[5])
					if (next_symbol[3])
						next_win = PLAYER2_WIN;
					else
						next_win = PLAYER1_WIN;

			if (next_occupied[6] && next_occupied[7] && next_occupied[8])
				if (next_symbol[6] == next_symbol[7] && next_symbol[7] == next_symbol[8])
					if (next_symbol[6])
						next_win = PLAYER2_WIN;
					else
						next_win = PLAYER1_WIN;

			if (next_occupied[0] && next_occupied[3] && next_occupied[6])
				if (next_symbol[0] == next_symbol[3] && next_symbol[3] == next_symbol[6])
					if (next_symbol[0])
						next_win = PLAYER2_WIN;
					else
						next_win = PLAYER1_WIN;

			if (next_occupied[1] && next_occupied[4] && next_occupied[7])
				if (next_symbol[1] == next_symbol[4] && next_symbol[4] == next_symbol[7])
					if (next_symbol[1])
						next_win = PLAYER2_WIN;
					else
						next_win = PLAYER1_WIN;

			if (next_occupied[2] && next_occupied[5] && next_occupied[8])
				if (next_symbol[2] == next_symbol[5] && next_symbol[5] == next_symbol[8])
					if (next_symbol[2])
						next_win = PLAYER2_WIN;
					else
						next_win = PLAYER1_WIN;

			if (next_occupied[0] && next_occupied[4] && next_occupied[8])
				if (next_symbol[0] == next_symbol[4] && next_symbol[4] == next_symbol[8])
					if (next_symbol[0])
						next_win = PLAYER2_WIN;
					else
						next_win = PLAYER1_WIN;

			if (next_occupied[2] && next_occupied[4] && next_occupied[6])
				if (next_symbol[2] == next_symbol[4] && next_symbol[4] == next_symbol[6])
					if (next_symbol[2])
						next_win = PLAYER2_WIN;
					else
						next_win = PLAYER1_WIN;

			if (next_win == NO_WIN && next_occupied == 9'b111111111)
				next_win = DRAW_GAME;
		end
	end

end

// State control.
always @(*)
begin
	case (state)
		IDLE:
			if (START)
				next_state = PLAYER1;
			else
				next_state = IDLE;
		PLAYER1:
			if (py1_draw)
				if (next_win)
					next_state = FINISH;
				else
					next_state = PLAYER2;

			else
				next_state = PLAYER1;
		PLAYER2:
			if (py2_draw)
				if (next_win)
					next_state = FINISH;
				else
					next_state = PLAYER1;
			else
				next_state = PLAYER2;
		default: next_state = FINISH;
	endcase
end


endmodule",188,414
19,14,0,False,False,"module pulse_synchronizer
    ( input pulse_in_clkA,
      input clkA,
      output pulse_out_clkB,
      input clkB,
      input reset_clkA,
      input reset_clkB
      );

   reg 	    ackA;
   reg 	    ackB;

   reg 	    ackA_synch;
   reg 	    ackA_clkB;
   reg 	    ackB_synch;
   reg 	    ackB_clkA;

   reg 	    pulse_in_clkA_d1;
   reg 	    ackA_clkB_d1;
   reg 	    ackB_d1;

   /* detect rising edges in clkA domain, set the ackA signal
    * until the pulse is acked from the other domain */
   always @(posedge clkA) begin
      if(reset_clkA) begin
	 ackA <= 0;
      end
      else if(!pulse_in_clkA_d1 & pulse_in_clkA) begin
	 ackA <= 1;
      end
      else if(ackB_clkA) begin
	 ackA <= 0;
      end
   end // always @ (posedge clkA)

   /* detect the rising edge of ackA and set ackB until ackA falls */
   always @(posedge clkB) begin
      if(reset_clkB) begin
	 ackB <= 0;
      end
      else if(!ackA_clkB_d1 & ackA_clkB) begin
	 ackB <= 1;
      end
      else if(!ackA_clkB) begin
	 ackB <= 0;
      end
   end // always @ (posedge clkB)

   /* detect rising edge of ackB and send pulse */
   assign pulse_out_clkB = ackB & !ackB_d1;

   /* synchronize the ack signals */
   always @(posedge clkA) begin
      if(reset_clkA) begin
	 pulse_in_clkA_d1 <= 0;
	 ackB_synch <= 0;
	 ackB_clkA <= 0;
      end
      else begin
	 pulse_in_clkA_d1 <= pulse_in_clkA;
	 ackB_synch <= ackB;
	 ackB_clkA <= ackB_synch;
      end
   end

   /* synchronize the ack signals */
   always @(posedge clkB) begin
      if(reset_clkB) begin
	 ackB_d1 <= 0;
	 ackA_synch <= 0;
	 ackA_clkB <= 0;
	 ackA_clkB_d1 <= 0;
      end
      else begin
	 ackB_d1 <= ackB;
	 ackA_synch <= ackA;
	 ackA_clkB <= ackA_synch;
	 ackA_clkB_d1 <= ackA_clkB;
      end
   end

endmodule",82,451
10,3,0,True,False,"module  wasca_altpll_1_dffpipe_l2c
	( 
	clock,
	clrn,
	d,
	q) /* synthesis synthesis_clearbox=1 */;
	input   clock;
	input   clrn;
	input   [0:0]  d;
	output   [0:0]  q;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   clock;
	tri1   clrn;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[0:0]	dffe4a;
	reg	[0:0]	dffe5a;
	reg	[0:0]	dffe6a;
	wire ena;
	wire prn;
	wire sclr;

	// synopsys translate_off
	initial
		dffe4a = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge prn or  negedge clrn)
		if (prn == 1'b0) dffe4a <= {1{1'b1}};
		else if (clrn == 1'b0) dffe4a <= 1'b0;
		else if  (ena == 1'b1)   dffe4a <= (d & (~ sclr));
	// synopsys translate_off
	initial
		dffe5a = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge prn or  negedge clrn)
		if (prn == 1'b0) dffe5a <= {1{1'b1}};
		else if (clrn == 1'b0) dffe5a <= 1'b0;
		else if  (ena == 1'b1)   dffe5a <= (dffe4a & (~ sclr));
	// synopsys translate_off
	initial
		dffe6a = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge prn or  negedge clrn)
		if (prn == 1'b0) dffe6a <= {1{1'b1}};
		else if (clrn == 1'b0) dffe6a <= 1'b0;
		else if  (ena == 1'b1)   dffe6a <= (dffe5a & (~ sclr));
	assign
		ena = 1'b1,
		prn = 1'b1,
		q = dffe6a,
		sclr = 1'b0;
endmodule",56,464
107,214,0,False,False,"module FrequencyCounter(
    input clk,
    input freqin,
    output [23:0] frequency
    );

parameter        SecondCount    =    8001800;          //    Number of cycles of clk to 1 second

reg    [23:0]    counter        =    0;                //    Counter for input freqin
reg    [23:0]    freq           =    0;                //    Last frequency value
reg    [23:0]    secondcounter  =    0;                //    Counter to one second
reg              stopin         =    0;                //    Stop Input Counter
reg              inreseted      =    0;                //    Reset Input Counter

always @(posedge clk)    
begin
        if(secondcounter == SecondCount)
        begin
            secondcounter     <= 0;
            stopin             <= 1;
            freq                 <=    counter*2;
        end
        else 
            if(~stopin)
                secondcounter <= secondcounter + 1;
        
        if(inreseted)
            stopin <= 0;
end

always @(negedge freqin)
begin
        if(~stopin)
        begin
            counter    <=    counter + 1;
            inreseted <= 0;
        end
        else
        begin
            counter <= 0;
            inreseted <= 1;
        end
end

assign frequency = freq;

endmodule",47,474
53,86,0,False,False,"module ClkDiv_20Hz(
    CLK,										// 12MHz onbaord clock
    RST,										// Reset
    CLKOUT,									// New clock output
    CLKOUTn
    );

// ===========================================================================
// 										Port Declarations
// ===========================================================================
	input CLK;
	input RST;
	output CLKOUT;
	output CLKOUTn;

// ===========================================================================
// 							  Parameters, Regsiters, and Wires
// ===========================================================================

	// Output register
	reg CLKOUT = 1'b1;

	// Value to toggle output clock at
	parameter cntEndVal = 19'h493E0;
	// Current count
	reg [18:0] clkCount = 19'h00000;

// ===========================================================================
// 										Implementation
// ===========================================================================
    
    assign CLKOUTn = ~CLKOUT;
    
	//-------------------------------------------------
	// 20Hz Clock Divider Generates timing to initiate Send/Receive
	//-------------------------------------------------
	always @(posedge CLK) begin

			// Reset clock
			if(RST == 1'b1) begin
					CLKOUT <= 1'b0;
					clkCount <= 0;
			end
			// Count/toggle normally
			else begin

					if(clkCount == cntEndVal) begin
							CLKOUT <= ~CLKOUT;
							clkCount <= 0;
					end
					else begin
							clkCount <= clkCount + 1'b1;
					end

			end

	end

endmodule",59,475
24,321,0,False,False,"module shift_reg(
    input rx,
    output reg[(reg_length-1):0] shifted_bus,
	output reg finished_rx,
    input rst,
    input baud_clk
    );
	
	parameter reg_length = 150;

	initial finished_rx = 0;
	parameter idle = 2'b00, reading = 2'b01, finished = 2'b10, finished_and_waiting = 2'b11;
	reg[1:0] current_state, next_state;
	
	reg [(reg_length-1):0] bitShiftReg = {reg_length{1'b1}};

	always @(posedge baud_clk or posedge rst) begin
		if(rst) begin
			bitShiftReg <= {reg_length{1'b1}};
			current_state <=  idle;
		end
		else begin
			current_state <= next_state;
			bitShiftReg <= {bitShiftReg[(reg_length-2):0],rx};
		end
	end
	always @(rx or bitShiftReg or current_state) begin
		case(current_state) 
			idle: begin
				if(rx == 1)
					next_state <= idle;
				else 
					next_state <= reading;
				end
			reading: begin
				if(bitShiftReg[6:0] == {7{1'b1}})
					next_state <= finished;
				else
					next_state <= reading;
				end
			finished: begin
				next_state<= finished_and_waiting;
			end
			
			default: begin
				next_state<=idle;
			end
		endcase
	end
	
	always @ (current_state) begin
		if(current_state == finished)
			finished_rx <= 1;
		else
			finished_rx <= 0;
	end
	
	always @ (posedge finished_rx or posedge rst) begin
		if(rst) 
			shifted_bus <= {reg_length{1'b1}};
		else
			shifted_bus <= bitShiftReg;
	end

endmodule",65,479
78,69,0,False,False,"module axi_protocol_converter_v2_1_axilite_conv #
  (
   parameter         C_FAMILY                    = ""virtex6"",
   parameter integer C_AXI_ID_WIDTH              = 1,
   parameter integer C_AXI_ADDR_WIDTH            = 32,
   parameter integer C_AXI_DATA_WIDTH            = 32,
   parameter integer C_AXI_SUPPORTS_WRITE        = 1,
   parameter integer C_AXI_SUPPORTS_READ         = 1,
   parameter integer C_AXI_RUSER_WIDTH                = 1,
   parameter integer C_AXI_BUSER_WIDTH                = 1
   )
  (
   // System Signals
   input  wire                          ACLK,
   input  wire                          ARESETN,
   // Slave Interface Write Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_AWID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_AWADDR,
   input  wire [3-1:0]                  S_AXI_AWPROT,
   input  wire                          S_AXI_AWVALID,
   output wire                          S_AXI_AWREADY,
   // Slave Interface Write Data Ports
   input  wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,
   input  wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,
   input  wire                          S_AXI_WVALID,
   output wire                          S_AXI_WREADY,
   // Slave Interface Write Response Ports
   output wire [C_AXI_ID_WIDTH-1:0]     S_AXI_BID,
   output wire [2-1:0]                  S_AXI_BRESP,
   output wire [C_AXI_BUSER_WIDTH-1:0]  S_AXI_BUSER,    // Constant =0
   output wire                          S_AXI_BVALID,
   input  wire                          S_AXI_BREADY,
   // Slave Interface Read Address Ports
   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_ARID,
   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_ARADDR,
   input  wire [3-1:0]                  S_AXI_ARPROT,
   input  wire                          S_AXI_ARVALID,
   output wire                          S_AXI_ARREADY,
   // Slave Interface Read Data Ports
   output wire [C_AXI_ID_WIDTH-1:0]     S_AXI_RID,
   output wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA,
   output wire [2-1:0]                  S_AXI_RRESP,
   output wire                          S_AXI_RLAST,    // Constant =1
   output wire [C_AXI_RUSER_WIDTH-1:0]  S_AXI_RUSER,    // Constant =0
   output wire                          S_AXI_RVALID,
   input  wire                          S_AXI_RREADY,
   
   // Master Interface Write Address Port
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_AWADDR,
   output wire [3-1:0]                  M_AXI_AWPROT,
   output wire                          M_AXI_AWVALID,
   input  wire                          M_AXI_AWREADY,
   // Master Interface Write Data Ports
   output wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA,
   output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,
   output wire                          M_AXI_WVALID,
   input  wire                          M_AXI_WREADY,
   // Master Interface Write Response Ports
   input  wire [2-1:0]                  M_AXI_BRESP,
   input  wire                          M_AXI_BVALID,
   output wire                          M_AXI_BREADY,
   // Master Interface Read Address Port
   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_ARADDR,
   output wire [3-1:0]                  M_AXI_ARPROT,
   output wire                          M_AXI_ARVALID,
   input  wire                          M_AXI_ARREADY,
   // Master Interface Read Data Ports
   input  wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_RDATA,
   input  wire [2-1:0]                  M_AXI_RRESP,
   input  wire                          M_AXI_RVALID,
   output wire                          M_AXI_RREADY
  );

  wire s_awvalid_i;
  wire s_arvalid_i;
  wire [C_AXI_ADDR_WIDTH-1:0] m_axaddr;

  // Arbiter
  reg read_active;
  reg write_active;
  reg busy;

  wire read_req;
  wire write_req;
  wire read_complete;
  wire write_complete;
  
  reg [1:0] areset_d; // Reset delay register
  always @(posedge ACLK) begin
    areset_d <= {areset_d[0], ~ARESETN};
  end
  
  assign s_awvalid_i = S_AXI_AWVALID & (C_AXI_SUPPORTS_WRITE != 0);
  assign s_arvalid_i = S_AXI_ARVALID & (C_AXI_SUPPORTS_READ != 0);

  assign read_req  = s_arvalid_i & ~busy & ~|areset_d & ~write_active;
  assign write_req = s_awvalid_i & ~busy & ~|areset_d & ((~read_active & ~s_arvalid_i) | write_active);

  assign read_complete  = M_AXI_RVALID & S_AXI_RREADY;
  assign write_complete = M_AXI_BVALID & S_AXI_BREADY;

  always @(posedge ACLK) begin : arbiter_read_ff
    if (|areset_d)
      read_active <= 1'b0;
    else if (read_complete)
      read_active <= 1'b0;
    else if (read_req)
      read_active <= 1'b1;
  end

  always @(posedge ACLK) begin : arbiter_write_ff
    if (|areset_d)
      write_active <= 1'b0;
    else if (write_complete)
      write_active <= 1'b0;
    else if (write_req)
      write_active <= 1'b1;
  end

  always @(posedge ACLK) begin : arbiter_busy_ff
    if (|areset_d)
      busy <= 1'b0;
    else if (read_complete | write_complete)
      busy <= 1'b0;
    else if ((write_req & M_AXI_AWREADY) | (read_req & M_AXI_ARREADY))
      busy <= 1'b1;
  end

  assign M_AXI_ARVALID = read_req;
  assign S_AXI_ARREADY = M_AXI_ARREADY & read_req;

  assign M_AXI_AWVALID = write_req;
  assign S_AXI_AWREADY = M_AXI_AWREADY & write_req;

  assign M_AXI_RREADY  = S_AXI_RREADY & read_active;
  assign S_AXI_RVALID  = M_AXI_RVALID & read_active;

  assign M_AXI_BREADY  = S_AXI_BREADY & write_active;
  assign S_AXI_BVALID  = M_AXI_BVALID & write_active;

  // Address multiplexer
  assign m_axaddr = (read_req | (C_AXI_SUPPORTS_WRITE == 0)) ? S_AXI_ARADDR : S_AXI_AWADDR;

  // Id multiplexer and flip-flop
  reg [C_AXI_ID_WIDTH-1:0] s_axid;

  always @(posedge ACLK) begin : axid
    if      (read_req)  s_axid <= S_AXI_ARID;
    else if (write_req) s_axid <= S_AXI_AWID;
  end

  assign S_AXI_BID = s_axid;
  assign S_AXI_RID = s_axid;

  assign M_AXI_AWADDR = m_axaddr;
  assign M_AXI_ARADDR = m_axaddr;


  // Feed-through signals
  assign S_AXI_WREADY   = M_AXI_WREADY & ~|areset_d;
  assign S_AXI_BRESP    = M_AXI_BRESP;
  assign S_AXI_RDATA    = M_AXI_RDATA;
  assign S_AXI_RRESP    = M_AXI_RRESP;
  assign S_AXI_RLAST    = 1'b1;
  assign S_AXI_BUSER    = {C_AXI_BUSER_WIDTH{1'b0}};
  assign S_AXI_RUSER    = {C_AXI_RUSER_WIDTH{1'b0}};

  assign M_AXI_AWPROT   = S_AXI_AWPROT;
  assign M_AXI_WVALID   = S_AXI_WVALID & ~|areset_d;
  assign M_AXI_WDATA    = S_AXI_WDATA;
  assign M_AXI_WSTRB    = S_AXI_WSTRB;
  assign M_AXI_ARPROT   = S_AXI_ARPROT;

endmodule",174,481
1637,2016,0,False,False,"module adder(
        input_a,
        input_b,
        input_a_stb,
        input_b_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack,
        input_b_ack);

  input     clk;
  input     rst;

  input     [31:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  input     [31:0] input_b;
  input     input_b_stb;
  output    input_b_ack;

  output    [31:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [31:0] s_output_z;
  reg       s_input_a_ack;
  reg       s_input_b_ack;

  reg       [3:0] state;
  parameter get_a         = 4'd0,
            get_b         = 4'd1,
            unpack        = 4'd2,
            special_cases = 4'd3,
            align         = 4'd4,
            add_0         = 4'd5,
            add_1         = 4'd6,
            normalise_1   = 4'd7,
            normalise_2   = 4'd8,
            round         = 4'd9,
            pack          = 4'd10,
            put_z         = 4'd11;

  reg       [31:0] a, b, z;
  reg       [26:0] a_m, b_m;
  reg       [23:0] z_m;
  reg       [9:0] a_e, b_e, z_e;
  reg       a_s, b_s, z_s;
  reg       guard, round_bit, sticky;
  reg       [27:0] sum;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= get_b;
        end
      end

      get_b:
      begin
        s_input_b_ack <= 1;
        if (s_input_b_ack && input_b_stb) begin
          b <= input_b;
          s_input_b_ack <= 0;
          state <= unpack;
        end
      end

      unpack:
      begin
        a_m <= {a[22 : 0], 3'd0};
        b_m <= {b[22 : 0], 3'd0};
        a_e <= a[30 : 23] - 127;
        b_e <= b[30 : 23] - 127;
        a_s <= a[31];
        b_s <= b[31];
        state <= special_cases;
      end

      special_cases:
      begin
        //if a is NaN or b is NaN return NaN
        if ((a_e == 128 && a_m != 0) || (b_e == 128 && b_m != 0)) begin
          z[31] <= 1;
          z[30:23] <= 255;
          z[22] <= 1;
          z[21:0] <= 0;
          state <= put_z;
        //if a is inf return inf
        end else if (a_e == 128) begin
          z[31] <= a_s;
          z[30:23] <= 255;
          z[22:0] <= 0;
          state <= put_z;
        //if b is inf return inf
        end else if (b_e == 128) begin
          z[31] <= b_s;
          z[30:23] <= 255;
          z[22:0] <= 0;
          state <= put_z;
        //if a is zero return b
        end else if ((($signed(a_e) == -127) && (a_m == 0)) && (($signed(b_e) == -127) && (b_m == 0))) begin
          z[31] <= a_s & b_s;
          z[30:23] <= b_e[7:0] + 127;
          z[22:0] <= b_m[26:3];
          state <= put_z;
        //if a is zero return b
        end else if (($signed(a_e) == -127) && (a_m == 0)) begin
          z[31] <= b_s;
          z[30:23] <= b_e[7:0] + 127;
          z[22:0] <= b_m[26:3];
          state <= put_z;
        //if b is zero return a
        end else if (($signed(b_e) == -127) && (b_m == 0)) begin
          z[31] <= a_s;
          z[30:23] <= a_e[7:0] + 127;
          z[22:0] <= a_m[26:3];
          state <= put_z;
        end else begin
          //Denormalised Number
          if ($signed(a_e) == -127) begin
            a_e <= -126;
          end else begin
            a_m[26] <= 1;
          end
          //Denormalised Number
          if ($signed(b_e) == -127) begin
            b_e <= -126;
          end else begin
            b_m[26] <= 1;
          end
          state <= align;
        end
      end

      align:
      begin
        if ($signed(a_e) > $signed(b_e)) begin
          b_e <= b_e + 1;
          b_m <= b_m >> 1;
          b_m[0] <= b_m[0] | b_m[1];
        end else if ($signed(a_e) < $signed(b_e)) begin
          a_e <= a_e + 1;
          a_m <= a_m >> 1;
          a_m[0] <= a_m[0] | a_m[1];
        end else begin
          state <= add_0;
        end
      end

      add_0:
      begin
        z_e <= a_e;
        if (a_s == b_s) begin
          sum <= a_m + b_m;
          z_s <= a_s;
        end else begin
          if (a_m >= b_m) begin
            sum <= a_m - b_m;
            z_s <= a_s;
          end else begin
            sum <= b_m - a_m;
            z_s <= b_s;
          end
        end
        state <= add_1;
      end

      add_1:
      begin
        if (sum[27]) begin
          z_m <= sum[27:4];
          guard <= sum[3];
          round_bit <= sum[2];
          sticky <= sum[1] | sum[0];
          z_e <= z_e + 1;
        end else begin
          z_m <= sum[26:3];
          guard <= sum[2];
          round_bit <= sum[1];
          sticky <= sum[0];
        end
        state <= normalise_1;
      end

      normalise_1:
      begin
        if (z_m[23] == 0 && $signed(z_e) > -126) begin
          z_e <= z_e - 1;
          z_m <= z_m << 1;
          z_m[0] <= guard;
          guard <= round_bit;
          round_bit <= 0;
        end else begin
          state <= normalise_2;
        end
      end

      normalise_2:
      begin
        if ($signed(z_e) < -126) begin
          z_e <= z_e + 1;
          z_m <= z_m >> 1;
          guard <= z_m[0];
          round_bit <= guard;
          sticky <= sticky | round_bit;
        end else begin
          state <= round;
        end
      end

      round:
      begin
        if (guard && (round_bit | sticky | z_m[0])) begin
          z_m <= z_m + 1;
          if (z_m == 24'hffffff) begin
            z_e <=z_e + 1;
          end
        end
        state <= pack;
      end

      pack:
      begin
        z[22 : 0] <= z_m[22:0];
        z[30 : 23] <= z_e[7:0] + 127;
        z[31] <= z_s;
        if ($signed(z_e) == -126 && z_m[23] == 0) begin
          z[30 : 23] <= 0;
        end
        //if overflow occurs, return inf
        if ($signed(z_e) > 127) begin
          z[22 : 0] <= 0;
          z[30 : 23] <= 255;
          z[31] <= z_s;
        end
        state <= put_z;
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_input_b_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign input_b_ack = s_input_b_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",277,484
1345,1870,0,False,False,"module divider(
        input_a,
        input_b,
        input_a_stb,
        input_b_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack,
        input_b_ack);

  input     clk;
  input     rst;

  input     [31:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  input     [31:0] input_b;
  input     input_b_stb;
  output    input_b_ack;

  output    [31:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [31:0] s_output_z;
  reg       s_input_a_ack;
  reg       s_input_b_ack;

  reg       [3:0] state;
  parameter get_a         = 4'd0,
            get_b         = 4'd1,
            unpack        = 4'd2,
            special_cases = 4'd3,
            normalise_a   = 4'd4,
            normalise_b   = 4'd5,
            divide_0      = 4'd6,
            divide_1      = 4'd7,
            divide_2      = 4'd8,
            divide_3      = 4'd9,
            normalise_1   = 4'd10,
            normalise_2   = 4'd11,
            round         = 4'd12,
            pack          = 4'd13,
            put_z         = 4'd14;

  reg       [31:0] a, b, z;
  reg       [23:0] a_m, b_m, z_m;
  reg       [9:0] a_e, b_e, z_e;
  reg       a_s, b_s, z_s;
  reg       guard, round_bit, sticky;
  reg       [50:0] quotient, divisor, dividend, remainder;
  reg       [5:0] count;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= get_b;
        end
      end

      get_b:
      begin
        s_input_b_ack <= 1;
        if (s_input_b_ack && input_b_stb) begin
          b <= input_b;
          s_input_b_ack <= 0;
          state <= unpack;
        end
      end

      unpack:
      begin
        a_m <= a[22 : 0];
        b_m <= b[22 : 0];
        a_e <= a[30 : 23] - 127;
        b_e <= b[30 : 23] - 127;
        a_s <= a[31];
        b_s <= b[31];
        state <= special_cases;
      end

      special_cases:
      begin
        //if a is NaN or b is NaN return NaN
        if ((a_e == 128 && a_m != 0) || (b_e == 128 && b_m != 0)) begin
          z[31] <= 1;
          z[30:23] <= 255;
          z[22] <= 1;
          z[21:0] <= 0;
          state <= put_z;
          //if a is inf and b is inf return NaN
        end else if ((a_e == 128) && (b_e == 128)) begin
          z[31] <= 1;
          z[30:23] <= 255;
          z[22] <= 1;
          z[21:0] <= 0;
          state <= put_z;
        //if a is inf return inf
        end else if (a_e == 128) begin
          z[31] <= a_s ^ b_s;
          z[30:23] <= 255;
          z[22:0] <= 0;
          state <= put_z;
           //if b is zero return NaN
          if ($signed(b_e == -127) && (b_m == 0)) begin
            z[31] <= 1;
            z[30:23] <= 255;
            z[22] <= 1;
            z[21:0] <= 0;
            state <= put_z;
          end
        //if b is inf return zero
        end else if (b_e == 128) begin
          z[31] <= a_s ^ b_s;
          z[30:23] <= 0;
          z[22:0] <= 0;
          state <= put_z;
        //if a is zero return zero
        end else if (($signed(a_e) == -127) && (a_m == 0)) begin
          z[31] <= a_s ^ b_s;
          z[30:23] <= 0;
          z[22:0] <= 0;
          state <= put_z;
           //if b is zero return NaN
          if (($signed(b_e) == -127) && (b_m == 0)) begin
            z[31] <= 1;
            z[30:23] <= 255;
            z[22] <= 1;
            z[21:0] <= 0;
            state <= put_z;
          end
        //if b is zero return inf
        end else if (($signed(b_e) == -127) && (b_m == 0)) begin
          z[31] <= a_s ^ b_s;
          z[30:23] <= 255;
          z[22:0] <= 0;
          state <= put_z;
        end else begin
          //Denormalised Number
          if ($signed(a_e) == -127) begin
            a_e <= -126;
          end else begin
            a_m[23] <= 1;
          end
          //Denormalised Number
          if ($signed(b_e) == -127) begin
            b_e <= -126;
          end else begin
            b_m[23] <= 1;
          end
          state <= normalise_a;
        end
      end

      normalise_a:
      begin
        if (a_m[23]) begin
          state <= normalise_b;
        end else begin
          a_m <= a_m << 1;
          a_e <= a_e - 1;
        end
      end

      normalise_b:
      begin
        if (b_m[23]) begin
          state <= divide_0;
        end else begin
          b_m <= b_m << 1;
          b_e <= b_e - 1;
        end
      end

      divide_0:
      begin
        z_s <= a_s ^ b_s;
        z_e <= a_e - b_e;
        quotient <= 0;
        remainder <= 0;
        count <= 0;
        dividend <= a_m << 27;
        divisor <= b_m;
        state <= divide_1;
      end

      divide_1:
      begin
        quotient <= quotient << 1;
        remainder <= remainder << 1;
        remainder[0] <= dividend[50];
        dividend <= dividend << 1;
        state <= divide_2;
      end

      divide_2:
      begin
        if (remainder >= divisor) begin
          quotient[0] <= 1;
          remainder <= remainder - divisor;
        end
        if (count == 49) begin
          state <= divide_3;
        end else begin
          count <= count + 1;
          state <= divide_1;
        end
      end

      divide_3:
      begin
        z_m <= quotient[26:3];
        guard <= quotient[2];
        round_bit <= quotient[1];
        sticky <= quotient[0] | (remainder != 0);
        state <= normalise_1;
      end

      normalise_1:
      begin
        if (z_m[23] == 0 && $signed(z_e) > -126) begin
          z_e <= z_e - 1;
          z_m <= z_m << 1;
          z_m[0] <= guard;
          guard <= round_bit;
          round_bit <= 0;
        end else begin
          state <= normalise_2;
        end
      end

      normalise_2:
      begin
        if ($signed(z_e) < -126) begin
          z_e <= z_e + 1;
          z_m <= z_m >> 1;
          guard <= z_m[0];
          round_bit <= guard;
          sticky <= sticky | round_bit;
        end else begin
          state <= round;
        end
      end

      round:
      begin
        if (guard && (round_bit | sticky | z_m[0])) begin
          z_m <= z_m + 1;
          if (z_m == 24'hffffff) begin
            z_e <=z_e + 1;
          end
        end
        state <= pack;
      end

      pack:
      begin
        z[22 : 0] <= z_m[22:0];
        z[30 : 23] <= z_e[7:0] + 127;
        z[31] <= z_s;
        if ($signed(z_e) == -126 && z_m[23] == 0) begin
          z[30 : 23] <= 0;
        end
        //if overflow occurs, return inf
        if ($signed(z_e) > 127) begin
          z[22 : 0] <= 0;
          z[30 : 23] <= 255;
          z[31] <= z_s;
        end
        state <= put_z;
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_input_b_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign input_b_ack = s_input_b_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",311,485
4522,4929,0,False,False,"module multiplier(
        input_a,
        input_b,
        input_a_stb,
        input_b_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack,
        input_b_ack);

  input     clk;
  input     rst;

  input     [31:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  input     [31:0] input_b;
  input     input_b_stb;
  output    input_b_ack;

  output    [31:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [31:0] s_output_z;
  reg       s_input_a_ack;
  reg       s_input_b_ack;

  reg       [3:0] state;
  parameter get_a         = 4'd0,
            get_b         = 4'd1,
            unpack        = 4'd2,
            special_cases = 4'd3,
            normalise_a   = 4'd4,
            normalise_b   = 4'd5,
            multiply_0    = 4'd6,
            multiply_1    = 4'd7,
            normalise_1   = 4'd8,
            normalise_2   = 4'd9,
            round         = 4'd10,
            pack          = 4'd11,
            put_z         = 4'd12;

  reg       [31:0] a, b, z;
  reg       [23:0] a_m, b_m, z_m;
  reg       [9:0] a_e, b_e, z_e;
  reg       a_s, b_s, z_s;
  reg       guard, round_bit, sticky;
  reg       [49:0] product;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= get_b;
        end
      end

      get_b:
      begin
        s_input_b_ack <= 1;
        if (s_input_b_ack && input_b_stb) begin
          b <= input_b;
          s_input_b_ack <= 0;
          state <= unpack;
        end
      end

      unpack:
      begin
        a_m <= a[22 : 0];
        b_m <= b[22 : 0];
        a_e <= a[30 : 23] - 127;
        b_e <= b[30 : 23] - 127;
        a_s <= a[31];
        b_s <= b[31];
        state <= special_cases;
      end

      special_cases:
      begin
        //if a is NaN or b is NaN return NaN
        if ((a_e == 128 && a_m != 0) || (b_e == 128 && b_m != 0)) begin
          z[31] <= 1;
          z[30:23] <= 255;
          z[22] <= 1;
          z[21:0] <= 0;
          state <= put_z;
        //if a is inf return inf
        end else if (a_e == 128) begin
          z[31] <= a_s ^ b_s;
          z[30:23] <= 255;
          z[22:0] <= 0;
          state <= put_z;
           //if b is zero return NaN
          if ($signed(b_e == -127) && (b_m == 0)) begin
            z[31] <= 1;
            z[30:23] <= 255;
            z[22] <= 1;
            z[21:0] <= 0;
            state <= put_z;
          end
        //if b is inf return inf
        end else if (b_e == 128) begin
          z[31] <= a_s ^ b_s;
          z[30:23] <= 255;
          z[22:0] <= 0;
          state <= put_z;
        //if a is zero return zero
        end else if (($signed(a_e) == -127) && (a_m == 0)) begin
          z[31] <= a_s ^ b_s;
          z[30:23] <= 0;
          z[22:0] <= 0;
          state <= put_z;
        //if b is zero return zero
        end else if (($signed(b_e) == -127) && (b_m == 0)) begin
          z[31] <= a_s ^ b_s;
          z[30:23] <= 0;
          z[22:0] <= 0;
          state <= put_z;
        end else begin
          //Denormalised Number
          if ($signed(a_e) == -127) begin
            a_e <= -126;
          end else begin
            a_m[23] <= 1;
          end
          //Denormalised Number
          if ($signed(b_e) == -127) begin
            b_e <= -126;
          end else begin
            b_m[23] <= 1;
          end
          state <= normalise_a;
        end
      end

      normalise_a:
      begin
        if (a_m[23]) begin
          state <= normalise_b;
        end else begin
          a_m <= a_m << 1;
          a_e <= a_e - 1;
        end
      end

      normalise_b:
      begin
        if (b_m[23]) begin
          state <= multiply_0;
        end else begin
          b_m <= b_m << 1;
          b_e <= b_e - 1;
        end
      end

      multiply_0:
      begin
        z_s <= a_s ^ b_s;
        z_e <= a_e + b_e + 1;
        product <= a_m * b_m * 4;
        state <= multiply_1;
      end

      multiply_1:
      begin
        z_m <= product[49:26];
        guard <= product[25];
        round_bit <= product[24];
        sticky <= (product[23:0] != 0);
        state <= normalise_1;
      end

      normalise_1:
      begin
        if (z_m[23] == 0) begin
          z_e <= z_e - 1;
          z_m <= z_m << 1;
          z_m[0] <= guard;
          guard <= round_bit;
          round_bit <= 0;
        end else begin
          state <= normalise_2;
        end
      end

      normalise_2:
      begin
        if ($signed(z_e) < -126) begin
          z_e <= z_e + 1;
          z_m <= z_m >> 1;
          guard <= z_m[0];
          round_bit <= guard;
          sticky <= sticky | round_bit;
        end else begin
          state <= round;
        end
      end

      round:
      begin
        if (guard && (round_bit | sticky | z_m[0])) begin
          z_m <= z_m + 1;
          if (z_m == 24'hffffff) begin
            z_e <=z_e + 1;
          end
        end
        state <= pack;
      end

      pack:
      begin
        z[22 : 0] <= z_m[22:0];
        z[30 : 23] <= z_e[7:0] + 127;
        z[31] <= z_s;
        if ($signed(z_e) == -126 && z_m[23] == 0) begin
          z[30 : 23] <= 0;
        end
        //if overflow occurs, return inf
        if ($signed(z_e) > 127) begin
          z[22 : 0] <= 0;
          z[30 : 23] <= 255;
          z[31] <= z_s;
        end
        state <= put_z;
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_input_b_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign input_b_ack = s_input_b_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",266,486
2367,3449,0,False,False,"module double_divider(
        input_a,
        input_b,
        input_a_stb,
        input_b_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack,
        input_b_ack);

  input     clk;
  input     rst;

  input     [63:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  input     [63:0] input_b;
  input     input_b_stb;
  output    input_b_ack;

  output    [63:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [63:0] s_output_z;
  reg       s_input_a_ack;
  reg       s_input_b_ack;

  reg       [3:0] state;
  parameter get_a         = 4'd0,
            get_b         = 4'd1,
            unpack        = 4'd2,
            special_cases = 4'd3,
            normalise_a   = 4'd4,
            normalise_b   = 4'd5,
            divide_0      = 4'd6,
            divide_1      = 4'd7,
            divide_2      = 4'd8,
            divide_3      = 4'd9,
            normalise_1   = 4'd10,
            normalise_2   = 4'd11,
            round         = 4'd12,
            pack          = 4'd13,
            put_z         = 4'd14;

  reg       [63:0] a, b, z;
  reg       [52:0] a_m, b_m, z_m;
  reg       [12:0] a_e, b_e, z_e;
  reg       a_s, b_s, z_s;
  reg       guard, round_bit, sticky;
  reg       [108:0] quotient, divisor, dividend, remainder;
  reg       [6:0] count;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= get_b;
        end
      end

      get_b:
      begin
        s_input_b_ack <= 1;
        if (s_input_b_ack && input_b_stb) begin
          b <= input_b;
          s_input_b_ack <= 0;
          state <= unpack;
        end
      end

      unpack:
      begin
        a_m <= a[51 : 0];
        b_m <= b[51 : 0];
        a_e <= a[62 : 52] - 1023;
        b_e <= b[62 : 52] - 1023;
        a_s <= a[63];
        b_s <= b[63];
        state <= special_cases;
      end

      special_cases:
      begin
        //if a is NaN or b is NaN return NaN
        if ((a_e == 1024 && a_m != 0) || (b_e == 1024 && b_m != 0)) begin
          z[63] <= 1;
          z[62:52] <= 2047;
          z[51] <= 1;
          z[50:0] <= 0;
          state <= put_z;
          //if a is inf and b is inf return NaN
        end else if ((a_e == 1024) && (b_e == 1024)) begin
          z[63] <= 1;
          z[62:52] <= 2047;
          z[51] <= 1;
          z[50:0] <= 0;
          state <= put_z;
        //if a is inf return inf
        end else if (a_e == 1024) begin
          z[63] <= a_s ^ b_s;
          z[62:52] <= 2047;
          z[51:0] <= 0;
          state <= put_z;
           //if b is zero return NaN
          if ($signed(b_e == -1023) && (b_m == 0)) begin
            z[63] <= 1;
            z[62:52] <= 2047;
            z[51] <= 1;
            z[50:0] <= 0;
            state <= put_z;
          end
        //if b is inf return zero
        end else if (b_e == 1024) begin
          z[63] <= a_s ^ b_s;
          z[62:52] <= 0;
          z[51:0] <= 0;
          state <= put_z;
        //if a is zero return zero
        end else if (($signed(a_e) == -1023) && (a_m == 0)) begin
          z[63] <= a_s ^ b_s;
          z[62:52] <= 0;
          z[51:0] <= 0;
          state <= put_z;
           //if b is zero return NaN
          if (($signed(b_e) == -1023) && (b_m == 0)) begin
            z[63] <= 1;
            z[62:52] <= 2047;
            z[51] <= 1;
            z[50:0] <= 0;
            state <= put_z;
          end
        //if b is zero return inf
        end else if (($signed(b_e) == -1023) && (b_m == 0)) begin
          z[63] <= a_s ^ b_s;
          z[62:52] <= 2047;
          z[51:0] <= 0;
          state <= put_z;
        end else begin
          //Denormalised Number
          if ($signed(a_e) == -1023) begin
            a_e <= -1022;
          end else begin
            a_m[52] <= 1;
          end
          //Denormalised Number
          if ($signed(b_e) == -1023) begin
            b_e <= -1022;
          end else begin
            b_m[52] <= 1;
          end
          state <= normalise_a;
        end
      end

      normalise_a:
      begin
        if (a_m[52]) begin
          state <= normalise_b;
        end else begin
          a_m <= a_m << 1;
          a_e <= a_e - 1;
        end
      end

      normalise_b:
      begin
        if (b_m[52]) begin
          state <= divide_0;
        end else begin
          b_m <= b_m << 1;
          b_e <= b_e - 1;
        end
      end

      divide_0:
      begin
        z_s <= a_s ^ b_s;
        z_e <= a_e - b_e;
        quotient <= 0;
        remainder <= 0;
        count <= 0;
        dividend <= a_m << 56;
        divisor <= b_m;
        state <= divide_1;
      end

      divide_1:
      begin
        quotient <= quotient << 1;
        remainder <= remainder << 1;
        remainder[0] <= dividend[108];
        dividend <= dividend << 1;
        state <= divide_2;
      end

      divide_2:
      begin
        if (remainder >= divisor) begin
          quotient[0] <= 1;
          remainder <= remainder - divisor;
        end
        if (count == 107) begin
          state <= divide_3;
        end else begin
          count <= count + 1;
          state <= divide_1;
        end
      end

      divide_3:
      begin
        z_m <= quotient[55:3];
        guard <= quotient[2];
        round_bit <= quotient[1];
        sticky <= quotient[0] | (remainder != 0);
        state <= normalise_1;
      end

      normalise_1:
      begin
        if (z_m[52] == 0 && $signed(z_e) > -1022) begin
          z_e <= z_e - 1;
          z_m <= z_m << 1;
          z_m[0] <= guard;
          guard <= round_bit;
          round_bit <= 0;
        end else begin
          state <= normalise_2;
        end
      end

      normalise_2:
      begin
        if ($signed(z_e) < -1022) begin
          z_e <= z_e + 1;
          z_m <= z_m >> 1;
          guard <= z_m[0];
          round_bit <= guard;
          sticky <= sticky | round_bit;
        end else begin
          state <= round;
        end
      end

      round:
      begin
        if (guard && (round_bit | sticky | z_m[0])) begin
          z_m <= z_m + 1;
          if (z_m == 53'hffffff) begin
            z_e <=z_e + 1;
          end
        end
        state <= pack;
      end

      pack:
      begin
        z[51 : 0] <= z_m[51:0];
        z[62 : 52] <= z_e[10:0] + 1023;
        z[63] <= z_s;
        if ($signed(z_e) == -1022 && z_m[52] == 0) begin
          z[62 : 52] <= 0;
        end
        //if overflow occurs, return inf
        if ($signed(z_e) > 1023) begin
          z[51 : 0] <= 0;
          z[62 : 52] <= 2047;
          z[63] <= z_s;
        end
        state <= put_z;
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_input_b_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign input_b_ack = s_input_b_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",311,487
19541,20385,0,False,False,"module double_multiplier(
        input_a,
        input_b,
        input_a_stb,
        input_b_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack,
        input_b_ack);

  input     clk;
  input     rst;

  input     [63:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  input     [63:0] input_b;
  input     input_b_stb;
  output    input_b_ack;

  output    [63:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [63:0] s_output_z;
  reg       s_input_a_ack;
  reg       s_input_b_ack;

  reg       [3:0] state;
  parameter get_a         = 4'd0,
            get_b         = 4'd1,
            unpack        = 4'd2,
            special_cases = 4'd3,
            normalise_a   = 4'd4,
            normalise_b   = 4'd5,
            multiply_0    = 4'd6,
            multiply_1    = 4'd7,
            normalise_1   = 4'd8,
            normalise_2   = 4'd9,
            round         = 4'd10,
            pack          = 4'd11,
            put_z         = 4'd12;

  reg       [63:0] a, b, z;
  reg       [52:0] a_m, b_m, z_m;
  reg       [12:0] a_e, b_e, z_e;
  reg       a_s, b_s, z_s;
  reg       guard, round_bit, sticky;
  reg       [107:0] product;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= get_b;
        end
      end

      get_b:
      begin
        s_input_b_ack <= 1;
        if (s_input_b_ack && input_b_stb) begin
          b <= input_b;
          s_input_b_ack <= 0;
          state <= unpack;
        end
      end

      unpack:
      begin
        a_m <= a[51 : 0];
        b_m <= b[51 : 0];
        a_e <= a[62 : 52] - 1023;
        b_e <= b[62 : 52] - 1023;
        a_s <= a[63];
        b_s <= b[63];
        state <= special_cases;
      end

      special_cases:
      begin
        //if a is NaN or b is NaN return NaN
        if ((a_e == 1024 && a_m != 0) || (b_e == 1024 && b_m != 0)) begin
          z[63] <= 1;
          z[62:52] <= 2047;
          z[51] <= 1;
          z[50:0] <= 0;
          state <= put_z;
        //if a is inf return inf
        end else if (a_e == 1024) begin
          z[63] <= a_s ^ b_s;
          z[62:52] <= 2047;
          z[51:0] <= 0;
          state <= put_z;
           //if b is zero return NaN
          if ($signed(b_e == -1023) && (b_m == 0)) begin
            z[63] <= 1;
            z[62:52] <= 2047;
            z[51] <= 1;
            z[50:0] <= 0;
            state <= put_z;
          end
        //if b is inf return inf
        end else if (b_e == 1024) begin
          z[63] <= a_s ^ b_s;
          z[62:52] <= 2047;
          z[51:0] <= 0;
          state <= put_z;
        //if a is zero return zero
        end else if (($signed(a_e) == -1023) && (a_m == 0)) begin
          z[63] <= a_s ^ b_s;
          z[62:52] <= 0;
          z[51:0] <= 0;
          state <= put_z;
        //if b is zero return zero
        end else if (($signed(b_e) == -1023) && (b_m == 0)) begin
          z[63] <= a_s ^ b_s;
          z[62:52] <= 0;
          z[51:0] <= 0;
          state <= put_z;
        end else begin
          //Denormalised Number
          if ($signed(a_e) == -1023) begin
            a_e <= -1022;
          end else begin
            a_m[52] <= 1;
          end
          //Denormalised Number
          if ($signed(b_e) == -1023) begin
            b_e <= -1022;
          end else begin
            b_m[52] <= 1;
          end
          state <= normalise_a;
        end
      end

      normalise_a:
      begin
        if (a_m[52]) begin
          state <= normalise_b;
        end else begin
          a_m <= a_m << 1;
          a_e <= a_e - 1;
        end
      end

      normalise_b:
      begin
        if (b_m[52]) begin
          state <= multiply_0;
        end else begin
          b_m <= b_m << 1;
          b_e <= b_e - 1;
        end
      end

      multiply_0:
      begin
        z_s <= a_s ^ b_s;
        z_e <= a_e + b_e + 1;
        product <= a_m * b_m * 4;
        state <= multiply_1;
      end

      multiply_1:
      begin
        z_m <= product[107:55];
        guard <= product[54];
        round_bit <= product[53];
        sticky <= (product[52:0] != 0);
        state <= normalise_1;
      end

      normalise_1:
      begin
        if (z_m[52] == 0) begin
          z_e <= z_e - 1;
          z_m <= z_m << 1;
          z_m[0] <= guard;
          guard <= round_bit;
          round_bit <= 0;
        end else begin
          state <= normalise_2;
        end
      end

      normalise_2:
      begin
        if ($signed(z_e) < -1022) begin
          z_e <= z_e + 1;
          z_m <= z_m >> 1;
          guard <= z_m[0];
          round_bit <= guard;
          sticky <= sticky | round_bit;
        end else begin
          state <= round;
        end
      end

      round:
      begin
        if (guard && (round_bit | sticky | z_m[0])) begin
          z_m <= z_m + 1;
          if (z_m == 53'hffffff) begin
            z_e <=z_e + 1;
          end
        end
        state <= pack;
      end

      pack:
      begin
        z[51 : 0] <= z_m[51:0];
        z[62 : 52] <= z_e[11:0] + 1023;
        z[63] <= z_s;
        if ($signed(z_e) == -1022 && z_m[52] == 0) begin
          z[62 : 52] <= 0;
        end
        //if overflow occurs, return inf
        if ($signed(z_e) > 1023) begin
          z[51 : 0] <= 0;
          z[62 : 52] <= 2047;
          z[63] <= z_s;
        end
        state <= put_z;
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_input_b_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign input_b_ack = s_input_b_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",266,488
3001,3761,0,False,False,"module double_adder(
        input_a,
        input_b,
        input_a_stb,
        input_b_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack,
        input_b_ack);

  input     clk;
  input     rst;

  input     [63:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  input     [63:0] input_b;
  input     input_b_stb;
  output    input_b_ack;

  output    [63:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [63:0] s_output_z;
  reg       s_input_a_ack;
  reg       s_input_b_ack;

  reg       [3:0] state;
  parameter get_a         = 4'd0,
            get_b         = 4'd1,
            unpack        = 4'd2,
            special_cases = 4'd3,
            align         = 4'd4,
            add_0         = 4'd5,
            add_1         = 4'd6,
            normalise_1   = 4'd7,
            normalise_2   = 4'd8,
            round         = 4'd9,
            pack          = 4'd10,
            put_z         = 4'd11;

  reg       [63:0] a, b, z;
  reg       [55:0] a_m, b_m;
  reg       [52:0] z_m;
  reg       [12:0] a_e, b_e, z_e;
  reg       a_s, b_s, z_s;
  reg       guard, round_bit, sticky;
  reg       [56:0] sum;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= get_b;
        end
      end

      get_b:
      begin
        s_input_b_ack <= 1;
        if (s_input_b_ack && input_b_stb) begin
          b <= input_b;
          s_input_b_ack <= 0;
          state <= unpack;
        end
      end

      unpack:
      begin
        a_m <= {a[51 : 0], 3'd0};
        b_m <= {b[51 : 0], 3'd0};
        a_e <= a[62 : 52] - 1023;
        b_e <= b[62 : 52] - 1023;
        a_s <= a[63];
        b_s <= b[63];
        state <= special_cases;
      end

      special_cases:
      begin
        //if a is NaN or b is NaN return NaN
        if ((a_e == 1024 && a_m != 0) || (b_e == 1024 && b_m != 0)) begin
          z[63] <= 1;
          z[62:52] <= 2047;
          z[51] <= 1;
          z[50:0] <= 0;
          state <= put_z;
        //if a is inf return inf
        end else if (a_e == 1024) begin
          z[63] <= a_s;
          z[62:52] <= 2047;
          z[51:0] <= 0;
          state <= put_z;
        //if b is inf return inf
        end else if (b_e == 1024) begin
          z[63] <= b_s;
          z[62:52] <= 2047;
          z[51:0] <= 0;
          state <= put_z;
        //if a is zero return b
        end else if ((($signed(a_e) == -1023) && (a_m == 0)) && (($signed(b_e) == -1023) && (b_m == 0))) begin
          z[63] <= a_s & b_s;
          z[62:52] <= b_e[10:0] + 1023;
          z[51:0] <= b_m[55:3];
          state <= put_z;
        //if a is zero return b
        end else if (($signed(a_e) == -1023) && (a_m == 0)) begin
          z[63] <= b_s;
          z[62:52] <= b_e[10:0] + 1023;
          z[51:0] <= b_m[55:3];
          state <= put_z;
        //if b is zero return a
        end else if (($signed(b_e) == -1023) && (b_m == 0)) begin
          z[63] <= a_s;
          z[62:52] <= a_e[10:0] + 1023;
          z[51:0] <= a_m[55:3];
          state <= put_z;
        end else begin
          //Denormalised Number
          if ($signed(a_e) == -1023) begin
            a_e <= -1022;
          end else begin
            a_m[55] <= 1;
          end
          //Denormalised Number
          if ($signed(b_e) == -1023) begin
            b_e <= -1022;
          end else begin
            b_m[55] <= 1;
          end
          state <= align;
        end
      end

      align:
      begin
        if ($signed(a_e) > $signed(b_e)) begin
          b_e <= b_e + 1;
          b_m <= b_m >> 1;
          b_m[0] <= b_m[0] | b_m[1];
        end else if ($signed(a_e) < $signed(b_e)) begin
          a_e <= a_e + 1;
          a_m <= a_m >> 1;
          a_m[0] <= a_m[0] | a_m[1];
        end else begin
          state <= add_0;
        end
      end

      add_0:
      begin
        z_e <= a_e;
        if (a_s == b_s) begin
          sum <= {1'd0, a_m} + b_m;
          z_s <= a_s;
        end else begin
          if (a_m > b_m) begin
            sum <= {1'd0, a_m} - b_m;
            z_s <= a_s;
          end else begin
            sum <= {1'd0, b_m} - a_m;
            z_s <= b_s;
          end
        end
        state <= add_1;
      end

      add_1:
      begin
        if (sum[56]) begin
          z_m <= sum[56:4];
          guard <= sum[3];
          round_bit <= sum[2];
          sticky <= sum[1] | sum[0];
          z_e <= z_e + 1;
        end else begin
          z_m <= sum[55:3];
          guard <= sum[2];
          round_bit <= sum[1];
          sticky <= sum[0];
        end
        state <= normalise_1;
      end

      normalise_1:
      begin
        if (z_m[52] == 0 && $signed(z_e) > -1022) begin
          z_e <= z_e - 1;
          z_m <= z_m << 1;
          z_m[0] <= guard;
          guard <= round_bit;
          round_bit <= 0;
        end else begin
          state <= normalise_2;
        end
      end

      normalise_2:
      begin
        if ($signed(z_e) < -1022) begin
          z_e <= z_e + 1;
          z_m <= z_m >> 1;
          guard <= z_m[0];
          round_bit <= guard;
          sticky <= sticky | round_bit;
        end else begin
          state <= round;
        end
      end

      round:
      begin
        if (guard && (round_bit | sticky | z_m[0])) begin
          z_m <= z_m + 1;
          if (z_m == 53'h1fffffffffffff) begin
            z_e <=z_e + 1;
          end
        end
        state <= pack;
      end

      pack:
      begin
        z[51 : 0] <= z_m[51:0];
        z[62 : 52] <= z_e[10:0] + 1023;
        z[63] <= z_s;
        if ($signed(z_e) == -1022 && z_m[52] == 0) begin
          z[62 : 52] <= 0;
        end
        //if overflow occurs, return inf
        if ($signed(z_e) > 1023) begin
          z[51 : 0] <= 0;
          z[62 : 52] <= 2047;
          z[63] <= z_s;
        end
        state <= put_z;
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_input_b_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign input_b_ack = s_input_b_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",277,489
490,690,0,False,False,"module int_to_float(
        input_a,
        input_a_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack);

  input     clk;
  input     rst;

  input     [31:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  output    [31:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [31:0] s_output_z;
  reg       s_input_a_ack;
  reg       s_input_b_ack;

  reg       [2:0] state;
  parameter get_a         = 3'd0,
            convert_0     = 3'd1,
            convert_1     = 3'd2,
            convert_2     = 3'd3,
            round         = 3'd4,
            pack          = 3'd5,
            put_z         = 3'd6;

  reg [31:0] a, z, value;
  reg [23:0] z_m;
  reg [7:0] z_r;
  reg [7:0] z_e;
  reg z_s;
  reg guard, round_bit, sticky;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= convert_0;
        end
      end

      convert_0:
      begin
        if ( a == 0 ) begin
          z_s <= 0;
          z_m <= 0;
          z_e <= -127;
          state <= pack;
        end else begin
          value <= a[31] ? -a : a;
          z_s <= a[31];
          state <= convert_1;
        end
      end

      convert_1:
      begin
        z_e <= 31;
        z_m <= value[31:8];
        z_r <= value[7:0];
        state <= convert_2;
      end

      convert_2:
      begin
        if (!z_m[23]) begin
          z_e <= z_e - 1;
          z_m <= z_m << 1;
          z_m[0] <= z_r[7];
          z_r <= z_r << 1;
        end else begin
          guard <= z_r[7];
          round_bit <= z_r[6];
          sticky <= z_r[5:0] != 0;
          state <= round;
        end
      end

      round:
      begin
        if (guard && (round_bit || sticky || z_m[0])) begin
          z_m <= z_m + 1;
          if (z_m == 24'hffffff) begin
            z_e <=z_e + 1;
          end
        end
        state <= pack;
      end

      pack:
      begin
        z[22 : 0] <= z_m[22:0];
        z[30 : 23] <= z_e + 127;
        z[31] <= z_s;
        state <= put_z;
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",137,490
245,403,0,False,False,"module float_to_int(
        input_a,
        input_a_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack);

  input     clk;
  input     rst;

  input     [31:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  output    [31:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [31:0] s_output_z;
  reg       s_input_a_ack;

  reg       [2:0] state;
  parameter get_a         = 3'd0,
            special_cases = 3'd1,
            unpack        = 3'd2,
            convert       = 3'd3,
            put_z         = 3'd4;

  reg [31:0] a_m, a, z;
  reg [8:0] a_e;
  reg a_s;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= unpack;
        end
      end

      unpack:
      begin
        a_m[31:8] <= {1'b1, a[22 : 0]};
        a_m[7:0] <= 0;
        a_e <= a[30 : 23] - 127;
        a_s <= a[31];
        state <= special_cases;
      end

      special_cases:
      begin
        if ($signed(a_e) == -127) begin
          z <= 0;
          state <= put_z;
        end else if ($signed(a_e) > 31) begin
          z <= 32'h80000000;
          state <= put_z;
        end else begin
          state <= convert;
        end
      end

      convert:
      begin
        if ($signed(a_e) < 31 && a_m) begin
          a_e <= a_e + 1;
          a_m <= a_m >> 1;
        end else begin
          if (a_m[31]) begin
            z <= 32'h80000000;
          end else begin
            z <= a_s ? -a_m : a_m;
          end
          state <= put_z;
        end
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",112,491
929,1330,0,False,False,"module long_to_double(
        input_a,
        input_a_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack);

  input     clk;
  input     rst;

  input     [63:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  output    [63:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [63:0] s_output_z;
  reg       s_input_a_ack;
  reg       s_input_b_ack;

  reg       [2:0] state;
  parameter get_a         = 3'd0,
            convert_0     = 3'd1,
            convert_1     = 3'd2,
            convert_2     = 3'd3,
            round         = 3'd4,
            pack          = 3'd5,
            put_z         = 3'd6;

  reg [63:0] a, z, value;
  reg [52:0] z_m;
  reg [10:0] z_r;
  reg [10:0] z_e;
  reg z_s;
  reg guard, round_bit, sticky;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= convert_0;
        end
      end

      convert_0:
      begin
        if ( a == 0 ) begin
          z_s <= 0;
          z_m <= 0;
          z_e <= -1023;
          state <= pack;
        end else begin
          value <= a[63] ? -a : a;
          z_s <= a[63];
          state <= convert_1;
        end
      end

      convert_1:
      begin
        z_e <= 63;
        z_m <= value[63:11];
        z_r <= value[10:0];
        state <= convert_2;
      end

      convert_2:
      begin
        if (!z_m[52]) begin
          z_e <= z_e - 1;
          z_m <= z_m << 1;
          z_m[0] <= z_r[10];
          z_r <= z_r << 1;
        end else begin
          guard <= z_r[10];
          round_bit <= z_r[9];
          sticky <= z_r[8:0] != 0;
          state <= round;
        end
      end

      round:
      begin
        if (guard && (round_bit || sticky || z_m[0])) begin
          z_m <= z_m + 1;
          if (z_m == 53'h1fffffffffffff) begin
            z_e <=z_e + 1;
          end
        end
        state <= pack;
      end

      pack:
      begin
        z[51 : 0] <= z_m[51:0];
        z[62 : 52] <= z_e + 1023;
        z[63] <= z_s;
        state <= put_z;
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",137,492
456,777,0,False,False,"module double_to_long(
        input_a,
        input_a_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack);

  input     clk;
  input     rst;

  input     [63:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  output    [63:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [63:0] s_output_z;
  reg       s_input_a_ack;

  reg       [2:0] state;
  parameter get_a         = 3'd0,
            special_cases = 3'd1,
            unpack        = 3'd2,
            convert       = 3'd3,
            put_z         = 3'd4;

  reg [63:0] a_m, a, z;
  reg [11:0] a_e;
  reg a_s;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= unpack;
        end
      end

      unpack:
      begin
        a_m[63:11] <= {1'b1, a[51 : 0]};
        a_m[10:0] <= 0;
        a_e <= a[62 : 52] - 1023;
        a_s <= a[63];
        state <= special_cases;
      end

      special_cases:
      begin
        if ($signed(a_e) == -1023) begin
          //zero
          z <= 0;
          state <= put_z;
        end else if ($signed(a_e) == 1024 && a[51:0] != 0) begin
          //nan
          z <= 64'h8000000000000000;
          state <= put_z;
        end else if ($signed(a_e) > 63) begin
          //too big
          if (a_s) begin
              z <= 64'h8000000000000000;
          end else begin
              z <= 64'h0000000000000000;
          end
          state <= put_z;
        end else begin
          state <= convert;
        end
      end

      convert:
      begin
        if ($signed(a_e) < 63 && a_m) begin
          a_e <= a_e + 1;
          a_m <= a_m >> 1;
        end else begin
          if (a_m[63] && a_s) begin
            z <= 64'h8000000000000000;
          end else begin
            z <= a_s ? -a_m : a_m;
          end
          state <= put_z;
        end
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",122,493
238,511,0,False,False,"module float_to_double(
        input_a,
        input_a_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack);

  input     clk;
  input     rst;

  input     [31:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  output    [63:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [63:0] s_output_z;
  reg       s_input_a_ack;
  reg       s_input_b_ack;

  reg       [1:0] state;
  parameter get_a         = 3'd0,
            convert_0     = 3'd1,
            normalise_0   = 3'd2,
            put_z         = 3'd3;

  reg [63:0] z;
  reg [10:0] z_e;
  reg [52:0] z_m;
  reg [31:0] a;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= convert_0;
        end
      end

      convert_0:
      begin
        z[63] <= a[31];
        z[62:52] <= (a[30:23] - 127) + 1023;
        z[51:0] <= {a[22:0], 29'd0};
        if (a[30:23] == 255) begin
            z[62:52] <= 2047;
        end
        state <= put_z;
        if (a[30:23] == 0) begin
            if (a[23:0]) begin
                state <= normalise_0;
                z_e <= 897;
                z_m <= {1'd0, a[22:0], 29'd0};
            end
            z[62:52] <= 0;
        end
      end

      normalise_0:
      begin
        if (z_m[52]) begin
          z[62:52] <= z_e;
          z[51:0] <= z_m[51:0];
          state <= put_z;
        end else begin
          z_m <= {z_m[51:0], 1'd0};
          z_e <= z_e - 1;
        end
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",107,494
510,718,0,False,False,"module double_to_float(
        input_a,
        input_a_stb,
        output_z_ack,
        clk,
        rst,
        output_z,
        output_z_stb,
        input_a_ack);

  input     clk;
  input     rst;

  input     [63:0] input_a;
  input     input_a_stb;
  output    input_a_ack;

  output    [31:0] output_z;
  output    output_z_stb;
  input     output_z_ack;

  reg       s_output_z_stb;
  reg       [31:0] s_output_z;
  reg       s_input_a_ack;

  reg       [1:0] state;
  parameter get_a         = 3'd0,
            unpack        = 3'd1,
            denormalise   = 3'd2,
            put_z         = 3'd3;

  reg [63:0] a;
  reg [31:0] z;
  reg [10:0] z_e;
  reg [23:0] z_m;
  reg guard;
  reg round;
  reg sticky;

  always @(posedge clk)
  begin

    case(state)

      get_a:
      begin
        s_input_a_ack <= 1;
        if (s_input_a_ack && input_a_stb) begin
          a <= input_a;
          s_input_a_ack <= 0;
          state <= unpack;
        end
      end

      unpack:
      begin
        z[31] <= a[63];
        state <= put_z;
        if (a[62:52] == 0) begin
            z[30:23] <= 0;
            z[22:0] <= 0;
        end else if (a[62:52] < 897) begin
            z[30:23] <= 0;
            z_m <= {1'd1, a[51:29]};
            z_e <= a[62:52];
            guard <= a[28];
            round <= a[27];
            sticky <= a[26:0] != 0;
            state <= denormalise;
        end else if (a[62:52] == 2047) begin
            z[30:23] <= 255;
            z[22:0] <= 0;
            if (a[51:0]) begin
                z[22] <= 1;
            end
        end else if (a[62:52] > 1150) begin
            z[30:23] <= 255;
            z[22:0] <= 0;
        end else begin
            z[30:23] <= (a[62:52] - 1023) + 127;
            if (a[28] && (a[27] || a[26:0])) begin
                z[22:0] <= a[51:29] + 1;
            end else begin
                z[22:0] <= a[51:29];
            end
        end
      end

      denormalise:
      begin
        if (z_e == 897 || (z_m == 0 && guard == 0)) begin
            state <= put_z;
            z[22:0] <= z_m;
            if (guard && (round || sticky)) begin
                z[22:0] <= z_m + 1;
            end
        end else begin
            z_e <= z_e + 1;
            z_m <= {1'd0, z_m[23:1]};
            guard <= z_m[0];
            round <= guard;
            sticky <= sticky | round;
        end
      end

      put_z:
      begin
        s_output_z_stb <= 1;
        s_output_z <= z;
        if (s_output_z_stb && output_z_ack) begin
          s_output_z_stb <= 0;
          state <= get_a;
        end
      end

    endcase

    if (rst == 1) begin
      state <= get_a;
      s_input_a_ack <= 0;
      s_output_z_stb <= 0;
    end

  end
  assign input_a_ack = s_input_a_ack;
  assign output_z_stb = s_output_z_stb;
  assign output_z = s_output_z;

endmodule",129,495
4,2,0,False,False,"module synch_2 #(parameter WIDTH = 1) (
   input  wire [WIDTH-1:0] i,      // input signal
   output reg  [WIDTH-1:0] o,      // synchronized output
   input  wire             clk     // clock to synchronize on
);

reg [WIDTH-1:0] stage_1;
always @(posedge clk)
   {o, stage_1} <= {stage_1, i};

endmodule",11,498
5,3,0,False,False,"module synch_3 #(parameter WIDTH = 1) (
   input  wire [WIDTH-1:0] i,     // input signal
   output reg  [WIDTH-1:0] o,     // synchronized output
   input  wire             clk    // clock to synchronize on
);

reg [WIDTH-1:0] stage_1;
reg [WIDTH-1:0] stage_2;
reg [WIDTH-1:0] stage_3;

always @(posedge clk) 
   {stage_3, o, stage_2, stage_1} <= {o, stage_2, stage_1, i};
   
endmodule",14,499
7,5,0,False,False,"module synch_3r #(parameter WIDTH = 1) (
   input  wire [WIDTH-1:0] i,     // input signal
   output reg  [WIDTH-1:0] o,     // synchronized output
   input  wire             clk,   // clock to synchronize on
   output wire             rise   // one-cycle rising edge pulse
);

reg [WIDTH-1:0] stage_1;
reg [WIDTH-1:0] stage_2;
reg [WIDTH-1:0] stage_3;

assign rise = (WIDTH == 1) ? (o & ~stage_3) : 1'b0;
always @(posedge clk) 
   {stage_3, o, stage_2, stage_1} <= {o, stage_2, stage_1, i};
   
endmodule",16,500
20,20,0,True,False,"module _multiplier(
		  input			     clk,
		  input [WIDTH - 1 : 0]      a,
		  input [WIDTH - 1 : 0]      b,
		  output [WIDTH * 2 - 1 : 0] c
		  );

   parameter WIDTH = 2;

   localparam M_WIDTH = WIDTH;
   localparam P_WIDTH = 2 * M_WIDTH;

   reg [P_WIDTH - 1 : 0] 		     P [M_WIDTH : 0];
   reg signed [M_WIDTH - 1 : 0] 	     M [M_WIDTH : 0];
   reg [M_WIDTH - 1 : 0] 			     Q;

   assign c = P[M_WIDTH];

   always @(a, b)
     begin
	P[0] <= { {(P_WIDTH){1'b0}}, {a} };
	M[0] <= b;
     end

   always @(posedge clk)
     begin
	if (P[0][0])
	  begin
	     P[1] <= sub_shift_right(P[0], M[0]);
	  end
	else
	  begin
	     P[1] <= shift_right(P[0]);
	  end
	Q[0] <= P[0][0];
	M[1] <= M[0];
     end // always @ (posedge clk)

   genvar	    i;
   generate
      for (i = 1; i < M_WIDTH; i = i + 1)
	begin
	   always @(posedge clk)
	     begin
		Q[i] <= P[i][0];
		M[i + 1] <= M[i];
		case( { P[i][0], Q[i - 1] } )

		  2'b01:
		    P[i + 1] <= add_shift_right(P[i], M[i]);

		  2'b10:
		    P[i + 1] <= sub_shift_right(P[i], M[i]);

		  default:
		    P[i + 1] <= shift_right(P[i]);

		endcase
	     end
	end // for (i = 0; i < WIDTH; i = i + 1)
   endgenerate

   function [P_WIDTH - 1 : 0] shift_right(input [P_WIDTH - 1 : 0] x);
      shift_right = { {x[P_WIDTH - 1]}, x[P_WIDTH - 1 : 1] };
   endfunction // shift_right

   function [P_WIDTH - 1 : 0] add_shift_right(input [P_WIDTH - 1 : 0] x, input signed [M_WIDTH - 1 : 0] y);
      add_shift_right = shift_right({ {x[P_WIDTH - 1 : M_WIDTH] + y}, {x[M_WIDTH - 1 : 0]} });
   endfunction // add_shift_right

   function [2 * WIDTH - 1 : 0] sub_shift_right(input [P_WIDTH - 1 : 0] x, input signed [M_WIDTH - 1 : 0] y);
      sub_shift_right = shift_right({ {x[P_WIDTH - 1 : M_WIDTH] - y}, {x[M_WIDTH - 1 : 0]} });;
   endfunction // sub_shift_right

endmodule",75,505
40,44,0,False,False,"module Decodificador(
   input [6:0] Cuenta,
	output reg [7:0] catodo1,catodo2,catodo3,catodo4
    );
    
	 always @(*)
	    begin
	    case (Cuenta)
		    6'd0: begin
			           catodo1 <= 8'b00000011;
						  catodo2 <= 8'b00000011;
					     catodo3 <= 8'b00000011;
					     catodo4 <= 8'b00000011;
			        end 
			 6'd1: begin
						 catodo1 <= 8'b10011111;
						 catodo2 <= 8'b00000011;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011; 
			        end 
			 6'd2: begin
						 catodo1 <= 8'b00100101;
						 catodo2 <= 8'b00000011;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd3: begin
						 catodo1 <= 8'b00001101;
						 catodo2 <= 8'b00000011;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd4: begin
						 catodo1 <= 8'b10011001;
						 catodo2 <= 8'b00000011;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd5: begin
						 catodo1 <= 8'b01001001;
						 catodo2 <= 8'b00000011;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd6: begin
						 catodo1 <= 8'b01000001;
						 catodo2 <= 8'b00000011;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd7: begin
						 catodo1 <= 8'b00011111;
						 catodo2 <= 8'b00000011;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd8: begin
						 catodo1 <= 8'b00000001;
						 catodo2 <= 8'b00000011;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd9: begin
						 catodo1 <= 8'b00011001;
						 catodo2 <= 8'b00000011;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd10: begin
						 catodo1 <= 8'b00000011;
						 catodo2 <= 8'b10011111;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd11: begin
						 catodo1 <= 8'b10011111;
						 catodo2 <= 8'b10011111;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd12: begin
						 catodo1 <= 8'b00100101;
						 catodo2 <= 8'b10011111;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd13: begin
						 catodo1 <= 8'b00001101;
						 catodo2 <= 8'b10011111;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd14: begin
						 catodo1 <= 8'b10011001;
						 catodo2 <= 8'b10011111;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 6'd15: begin
						 catodo1 <= 8'b01001001;
						 catodo2 <= 8'b10011111;
						 catodo3 <= 8'b00000011;
						 catodo4 <= 8'b00000011;
			        end 
			 default: begin
						 catodo1 <= 8'b10011111;
						 catodo2 <= 8'b10011111;
						 catodo3 <= 8'b10011111; 
						 catodo4 <= 8'b10011111;
                   end 	
        endcase		
		end	 
endmodule",113,506
10,6,0,False,False,"module bmu (cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7);

   // outputs
   output [1:0] bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7;

   // inputs
   input  	cx0, cx1;

   // registers
   reg [1:0] 	bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7;

   always@ (cx0 or cx1)
	 begin
	    if (cx0==0 && cx1==0)
	      begin
	        bm0 <= 2'd0; // this is going from 00 to 00
	    	bm1 <= 2'd2; // this is going from 00 to 10
	   		bm2 <= 2'd2; // this is going from 01 to 00
	    	bm3 <= 2'd0; // this is going from 01 to 10
	    	bm4 <= 2'd1; // this is going from 10 to 01
	    	bm5 <= 2'd1; // this is going from 10 to 11
	    	bm6 <= 2'd1; // this is going from 11 to 01
	    	bm7 <= 2'd1; // this is going from 11 to 11
	      end
	    else if (cx0==0 && cx1==1)
	      begin
	        bm0 <= 2'd1; // this is going from 00 to 00
	    	bm1 <= 2'd1; // this is going from 00 to 10
	   		bm2 <= 2'd1; // this is going from 01 to 00
	    	bm3 <= 2'd1; // this is going from 01 to 10
	    	bm4 <= 2'd2; // this is going from 10 to 01
	    	bm5 <= 2'd0; // this is going from 10 to 11
	    	bm6 <= 2'd0; // this is going from 11 to 01
	    	bm7 <= 2'd2; // this is going from 11 to 11
	      end
	    else if (cx0==1 && cx1==0)
	      begin
	        bm0 <= 2'd1; // this is going from 00 to 00
	    	bm1 <= 2'd1; // this is going from 00 to 10
	   		bm2 <= 2'd1; // this is going from 01 to 00
	    	bm3 <= 2'd1; // this is going from 01 to 10
	    	bm4 <= 2'd0; // this is going from 10 to 01
	    	bm5 <= 2'd2; // this is going from 10 to 11
	    	bm6 <= 2'd2; // this is going from 11 to 01
	    	bm7 <= 2'd0; // this is going from 11 to 11
	      end
	    else // if (cx0==1 && cx1==1)
	      begin
	        bm0 <= 2'd2; // this is going from 00 to 00
	    	bm1 <= 2'd0; // this is going from 00 to 10
	   		bm2 <= 2'd0; // this is going from 01 to 00
	    	bm3 <= 2'd2; // this is going from 01 to 10
	    	bm4 <= 2'd1; // this is going from 10 to 01
	    	bm5 <= 2'd1; // this is going from 10 to 11
	    	bm6 <= 2'd1; // this is going from 11 to 01
	    	bm7 <= 2'd1; // this is going from 11 to 11
	      end

	 end // always @ (posedge clk)
endmodule",60,507
43,283,0,True,False,"module custom(
    input RESET,
    input CLK,
    input [2:0] COL,
    output [3:0] ROW,
    output OPEN,
	 output [255:0] W,
	 output [7:0] DEBUG
    );

nand(OPEN,W[240],W[242]);
nand(ROW[0],W[9],W[9]);
nand(ROW[1],W[8],W[8]);
nand(ROW[2],W[6],W[6]);
nand(ROW[3],W[2],W[2]);
nand(W[0],CLK,CLK);
nand(W[1],W[0],W[0]);
nand(W[2],W[3],W[4]);
nand(W[3],W[198],W[200]);
nand(W[4],W[205],W[207]);
nand(W[5],W[3],W[3]);
nand(W[6],W[5],W[4]);
nand(W[7],W[4],W[4]);
nand(W[8],W[3],W[7]);
nand(W[9],W[5],W[7]);
nand(W[10],RESET,RESET);
nand(W[11],COL[0],COL[0]);
nand(W[12],COL[1],COL[1]);
nand(W[13],COL[2],COL[2]);
nand(W[14],W[13],W[12]);
nand(W[15],W[14],W[14]);
nand(W[16],W[15],W[11]);
nand(W[17],W[16],W[10]);
nand(W[18],W[17],W[17]);
nand(W[19],W[20],W[20]);
nand(W[20],W[191],W[193]);
nand(W[21],W[16],W[19]);
nand(W[22],W[21],W[21]);
nand(W[23],W[24],W[25]);
nand(W[24],W[233],W[235]);
nand(W[25],W[226],W[228]);
nand(W[26],W[23],W[23]);
nand(W[27],COL[2],W[12]);
nand(W[28],W[27],W[27]);
nand(W[29],W[28],W[26]);
nand(W[30],W[29],W[29]);
nand(W[31],W[32],W[33]);
nand(W[32],W[212],W[214]);
nand(W[33],W[219],W[221]);
nand(W[34],W[31],W[31]);
nand(W[35],W[34],ROW[1]);
nand(W[36],W[35],W[35]);
nand(W[37],W[36],W[10]);
nand(W[38],W[37],W[37]);
nand(W[39],W[38],W[30]);
nand(W[40],W[39],W[39]);
nand(W[41],W[40],W[22]);
nand(W[42],W[41],W[41]);
nand(W[43],W[21],W[32]);
nand(W[44],W[15],ROW[0]);
nand(W[45],W[44],W[44]);
nand(W[46],W[33],W[33]);
nand(W[47],W[32],W[32]);
nand(W[48],W[47],W[46]);
nand(W[49],W[48],W[48]);
nand(W[50],W[49],W[26]);
nand(W[51],W[50],W[50]);
nand(W[52],W[51],W[45]);
nand(W[53],W[47],W[33]);
nand(W[54],W[53],W[53]);
nand(W[55],W[54],ROW[0]);
nand(W[56],W[55],W[55]);
nand(W[57],W[56],W[30]);
nand(W[58],W[57],W[52]);
nand(W[59],W[58],W[58]);
nand(W[60],W[25],W[25]);
nand(W[61],W[24],W[60]);
nand(W[62],W[61],W[61]);
nand(W[63],W[62],W[45]);
nand(W[64],W[63],W[63]);
nand(W[65],W[64],W[47]);
nand(W[66],W[65],W[59]);
nand(W[67],W[66],W[66]);
nand(W[68],W[13],COL[1]);
nand(W[69],W[68],W[68]);
nand(W[70],W[69],ROW[2]);
nand(W[71],W[70],W[70]);
nand(W[72],W[24],W[24]);
nand(W[73],W[72],W[25]);
nand(W[74],W[73],W[73]);
nand(W[75],W[74],W[49]);
nand(W[76],W[75],W[75]);
nand(W[77],W[76],W[71]);
nand(W[78],W[72],W[60]);
nand(W[79],W[78],W[78]);
nand(W[80],W[79],W[49]);
nand(W[81],W[80],W[80]);
nand(W[82],W[81],W[71]);
nand(W[83],W[82],W[77]);
nand(W[84],W[83],W[83]);
nand(W[85],W[74],W[15]);
nand(W[86],W[85],W[85]);
nand(W[87],W[54],ROW[2]);
nand(W[88],W[87],W[87]);
nand(W[89],W[88],W[86]);
nand(W[90],W[79],W[54]);
nand(W[91],W[90],W[90]);
nand(W[92],W[91],W[45]);
nand(W[93],W[92],W[89]);
nand(W[94],W[93],W[93]);
nand(W[95],W[94],W[84]);
nand(W[96],W[95],W[95]);
nand(W[97],W[96],W[67]);
nand(W[98],W[97],W[22]);
nand(W[99],W[98],W[43]);
nand(W[100],W[99],W[10]);
nand(W[101],W[100],W[100]);
nand(W[102],W[21],W[33]);
nand(W[103],W[15],W[25]);
nand(W[104],W[103],W[103]);
nand(W[105],W[32],W[46]);
nand(W[106],W[105],W[105]);
nand(W[107],W[106],ROW[0]);
nand(W[108],W[107],W[107]);
nand(W[109],W[108],W[104]);
nand(W[110],W[62],W[54]);
nand(W[111],W[110],W[110]);
nand(W[112],W[111],W[45]);
nand(W[113],W[112],W[57]);
nand(W[114],W[113],W[113]);
nand(W[115],W[114],W[109]);
nand(W[116],W[115],W[115]);
nand(W[117],W[62],W[15]);
nand(W[118],W[117],W[117]);
nand(W[119],W[106],ROW[2]);
nand(W[120],W[119],W[119]);
nand(W[121],W[120],W[118]);
nand(W[122],W[28],W[72]);
nand(W[123],W[122],W[122]);
nand(W[124],W[123],W[120]);
nand(W[125],W[124],W[121]);
nand(W[126],W[125],W[125]);
nand(W[127],W[126],W[94]);
nand(W[128],W[127],W[127]);
nand(W[129],W[128],W[116]);
nand(W[130],W[129],W[22]);
nand(W[131],W[130],W[102]);
nand(W[132],W[131],W[10]);
nand(W[133],W[132],W[132]);
nand(W[134],W[21],W[25]);
nand(W[135],W[69],W[62]);
nand(W[136],W[135],W[135]);
nand(W[137],W[136],W[36]);
nand(W[138],W[137],W[109]);
nand(W[139],W[138],W[138]);
nand(W[140],W[139],W[59]);
nand(W[141],W[140],W[140]);
nand(W[142],W[15],ROW[2]);
nand(W[143],W[142],W[142]);
nand(W[144],W[79],W[34]);
nand(W[145],W[144],W[144]);
nand(W[146],W[145],W[143]);
nand(W[147],W[77],W[89]);
nand(W[148],W[147],W[147]);
nand(W[149],W[148],W[146]);
nand(W[150],W[149],W[149]);
nand(W[151],W[150],W[141]);
nand(W[152],W[151],W[22]);
nand(W[153],W[152],W[134]);
nand(W[154],W[153],W[10]);
nand(W[155],W[154],W[154]);
nand(W[156],W[21],W[24]);
nand(W[157],W[26],W[15]);
nand(W[158],W[157],W[157]);
nand(W[159],W[108],W[158]);
nand(W[160],W[159],W[121]);
nand(W[161],W[160],W[160]);
nand(W[162],W[86],W[36]);
nand(W[163],W[162],W[137]);
nand(W[164],W[163],W[163]);
nand(W[165],W[164],W[161]);
nand(W[166],W[165],W[165]);
nand(W[167],W[166],W[67]);
nand(W[168],W[167],W[22]);
nand(W[169],W[168],W[156]);
nand(W[170],W[169],W[10]);
nand(W[171],W[170],W[170]);
nand(W[172],W[16],W[16]);
nand(W[173],W[19],W[5]);
nand(W[174],W[173],W[172]);
nand(W[175],W[16],W[5]);
nand(W[176],W[175],W[10]);
nand(W[177],W[176],W[176]);
nand(W[178],W[177],W[174]);
nand(W[179],W[178],W[178]);
nand(W[180],W[174],W[4]);
nand(W[181],ROW[1],W[19]);
nand(W[182],W[181],W[181]);
nand(W[183],W[182],W[172]);
nand(W[184],W[183],W[180]);
nand(W[185],W[184],W[10]);
nand(W[186],W[185],W[185]);
nand(W[187],W[0],W[18]);
nand(W[188],W[0],W[187]);
nand(W[189],W[188],W[190]);
nand(W[190],W[187],W[189]);
nand(W[191],W[1],W[190]);
nand(W[192],W[1],W[191]);
nand(W[193],W[192],W[20]);
nand(W[194],W[0],W[179]);
nand(W[195],W[0],W[194]);
nand(W[196],W[195],W[197]);
nand(W[197],W[194],W[196]);
nand(W[198],W[1],W[197]);
nand(W[199],W[1],W[198]);
nand(W[200],W[199],W[3]);
nand(W[201],W[0],W[186]);
nand(W[202],W[0],W[201]);
nand(W[203],W[202],W[204]);
nand(W[204],W[201],W[203]);
nand(W[205],W[1],W[204]);
nand(W[206],W[1],W[205]);
nand(W[207],W[206],W[4]);
nand(W[208],W[0],W[101]);
nand(W[209],W[0],W[208]);
nand(W[210],W[209],W[211]);
nand(W[211],W[208],W[210]);
nand(W[212],W[1],W[211]);
nand(W[213],W[1],W[212]);
nand(W[214],W[213],W[32]);
nand(W[215],W[0],W[133]);
nand(W[216],W[0],W[215]);
nand(W[217],W[216],W[218]);
nand(W[218],W[215],W[217]);
nand(W[219],W[1],W[218]);
nand(W[220],W[1],W[219]);
nand(W[221],W[220],W[33]);
nand(W[222],W[0],W[155]);
nand(W[223],W[0],W[222]);
nand(W[224],W[223],W[225]);
nand(W[225],W[222],W[224]);
nand(W[226],W[1],W[225]);
nand(W[227],W[1],W[226]);
nand(W[228],W[227],W[25]);
nand(W[229],W[0],W[171]);
nand(W[230],W[0],W[229]);
nand(W[231],W[230],W[232]);
nand(W[232],W[229],W[231]);
nand(W[233],W[1],W[232]);
nand(W[234],W[1],W[233]);
nand(W[235],W[234],W[24]);
nand(W[236],W[0],W[42]);
nand(W[237],W[0],W[236]);
nand(W[238],W[237],W[239]);
nand(W[239],W[236],W[238]);
nand(W[240],W[1],W[239]);
nand(W[241],W[1],W[240]);
nand(W[242],W[241],OPEN);

assign DEBUG = {ROW[3:0],COL[2:0],CLK};

assign W[243] = 1;
assign W[244] = RESET;
assign W[245] = CLK;
assign W[249:246] = ROW;
assign W[252:250] = COL;
assign W[253] = OPEN;
assign W[254] = OPEN;
assign W[255] = OPEN;


endmodule",272,534
131,228,0,True,False,"module alink_slave(
    // system clock and reset
    input                        clk         ,
    input                        rst         ,
    
    // wishbone interface signals
    input                        ALINK_CYC_I ,//NC
    input                        ALINK_STB_I ,
    input                        ALINK_WE_I  ,
    input                        ALINK_LOCK_I,//NC
    input  [2:0]                 ALINK_CTI_I ,//NC
    input  [1:0]                 ALINK_BTE_I ,//NC
    input  [5:0]                 ALINK_ADR_I ,
    input  [31:0]                ALINK_DAT_I ,
    input  [3:0]                 ALINK_SEL_I ,//NC
    output reg                   ALINK_ACK_O ,
    output                       ALINK_ERR_O ,//const 0
    output                       ALINK_RTY_O ,//const 0
    output reg [31:0]            ALINK_DAT_O ,

    output reg                   txfifo_push ,
    output reg [31:0]            txfifo_din  ,

    input  [9:0]                 rxcnt       ,
    input                        rxempty     ,
    input  [10:0]                txcnt       ,
    output                       reg_flush   ,
    input                        txfull      ,

    output reg [31:0]            reg_mask    ,
    output reg                   reg_scan    ,
    input  [31:0]                busy        ,

    output                       rxfifo_pop  ,
    input  [31:0]                rxfifo_dout   
);

parameter ALINK_TXFIFO  = 6'h00 ;
parameter ALINK_STATE   = 6'h04 ;
parameter ALINK_MASK    = 6'h08 ;
parameter ALINK_BUSY    = 6'h0c ;
parameter ALINK_RXFIFO  = 6'h10 ;

//-----------------------------------------------------
// WB bus ACK
//-----------------------------------------------------
always @ ( posedge clk or posedge rst ) begin
        if( rst )
                ALINK_ACK_O <= 1'b0 ;
        else if( ALINK_STB_I && (~ALINK_ACK_O) )
                ALINK_ACK_O <= 1'b1 ;
        else 
                ALINK_ACK_O <= 1'b0 ;
end


//-----------------------------------------------------
// ADDR MUX
//-----------------------------------------------------

wire alink_txfifo_wr_en = ALINK_STB_I & ALINK_WE_I  & ( ALINK_ADR_I == ALINK_TXFIFO ) & ~ALINK_ACK_O ;
wire alink_txfifo_rd_en = ALINK_STB_I & ~ALINK_WE_I & ( ALINK_ADR_I == ALINK_TXFIFO ) & ~ALINK_ACK_O ;

wire alink_state_wr_en = ALINK_STB_I & ALINK_WE_I  & ( ALINK_ADR_I == ALINK_STATE ) & ~ALINK_ACK_O ;
wire alink_state_rd_en = ALINK_STB_I & ~ALINK_WE_I & ( ALINK_ADR_I == ALINK_STATE ) & ~ALINK_ACK_O ;

wire alink_mask_wr_en = ALINK_STB_I & ALINK_WE_I  & ( ALINK_ADR_I == ALINK_MASK ) & ~ALINK_ACK_O ;
wire alink_mask_rd_en = ALINK_STB_I & ~ALINK_WE_I & ( ALINK_ADR_I == ALINK_MASK ) & ~ALINK_ACK_O ;

wire alink_busy_wr_en = ALINK_STB_I & ALINK_WE_I  & ( ALINK_ADR_I == ALINK_BUSY ) & ~ALINK_ACK_O ;
wire alink_busy_rd_en = ALINK_STB_I & ~ALINK_WE_I & ( ALINK_ADR_I == ALINK_BUSY ) & ~ALINK_ACK_O ;

wire alink_rxfifo_wr_en = ALINK_STB_I & ALINK_WE_I  & ( ALINK_ADR_I == ALINK_RXFIFO ) & ~ALINK_ACK_O ;
wire alink_rxfifo_rd_en = ALINK_STB_I & ~ALINK_WE_I & ( ALINK_ADR_I == ALINK_RXFIFO ) & ~ALINK_ACK_O ;


//-----------------------------------------------------
// Register.txfifo
//-----------------------------------------------------
always @ ( posedge clk ) begin
	txfifo_push <= alink_txfifo_wr_en ;
	txfifo_din  <= ALINK_DAT_I ;
end

//-----------------------------------------------------
// Register.state
//-----------------------------------------------------
reg [3:0] reg_flush_r ;
wire [31:0] rd_state = {reg_scan,1'b0,rxcnt[9:0],3'b0,rxempty,
			1'b0,txcnt[10:0],2'b0,reg_flush,txfull} ;

always @ ( posedge clk ) begin
	if( alink_state_wr_en )
		reg_flush_r <= {3'b0,ALINK_DAT_I[1]} ;
	else
		reg_flush_r <= reg_flush_r << 1 ;
end

always @ ( posedge clk ) begin
	if( rst )
		reg_scan <= 1'b0 ;
	else if( alink_state_wr_en )
		reg_scan <= ALINK_DAT_I[31] ;
end

assign reg_flush = |reg_flush_r ;

//-----------------------------------------------------
// Register.mask
//-----------------------------------------------------
always @ ( posedge clk ) begin
	if( alink_mask_wr_en )
		reg_mask <= ALINK_DAT_I ;
end

//-----------------------------------------------------
// Register.busy
//-----------------------------------------------------
wire [31:0] rd_busy = busy[31:0] ;

//-----------------------------------------------------
// Register.rxfifo
//-----------------------------------------------------
wire [31:0] rd_rxfifo = rxfifo_dout[31:0] ;

//-----------------------------------------------------
// WB read
//-----------------------------------------------------
assign rxfifo_pop = alink_rxfifo_rd_en ;

always @ ( posedge clk ) begin
	case( 1'b1 )
		alink_state_rd_en  : ALINK_DAT_O <= rd_state  ;
		alink_busy_rd_en   : ALINK_DAT_O <= rd_busy   ;
		alink_rxfifo_rd_en : ALINK_DAT_O <= rd_rxfifo ;
		default: ALINK_DAT_O <= 32'hdeaddead ; 
	endcase
end


endmodule",141,536
31,35,0,False,False,"module BCD7segment(
    input [3:0] IN,
	 input select,
    output reg [6:0] OUT
	 
    );

always @ (IN or select)
begin
if(select)
begin
	case (IN)
0: OUT = 7'b0000001;
1: OUT = 7'b1001111;
2: OUT = 7'b0010010;
3: OUT = 7'b0000110;
4: OUT = 7'b1001100;
5: OUT = 7'b0100100;
6: OUT = 7'b0100000;
7: OUT = 7'b0001111;
8: OUT = 7'b0000000;
9: OUT = 7'b0000100;
10: OUT = 7'b0001000;
11: OUT = 7'b0000000;
12: OUT = 7'b0110001;
13: OUT = 7'b0000001;
14: OUT = 7'b0110000;
15: OUT = 7'b0111000;
endcase
end
else
	OUT = 7'b1111110;
end

// 4 enable switches //

endmodule",37,545
320,331,0,False,False,"module log2_table
	(
	input	     	clk,			// Drawing engine clock.
	input		trilinear_en, 		// Trilinear Enable.
	input	[31:0]	val, 			// Current Largest delta 23.9.

	output	[9:0]	log2
	);


	reg	[3:0]	int_mm_no;
	reg	[5:0]	lod_fract;

	wire		 over_flow;
	wire	[9:0]	 log_in;

	// assign log_in = val[26:17];
	// assign over_flow = |val[39:27];
	assign log_in = val[17:8];
	assign over_flow = |val[31:18];



// 17    = 9
// 16    = 8
// 15    = 7
//
// 9     = 1
// 8     = 0
// 7     = -1
// 6     = -2
// 5     = -3
// Mipmap Number Generation
// Select Mipmap based on delta and if mipmapping is on.
// Determine the largest delta value.
// Extract LOD 
always @(posedge clk) begin
	// casex (largest_delta_AM2[17:8])
	casex ({over_flow, log_in})
		11'b0_10xxxxxxx_x, 11'b0_011xxxxxx_x:	begin // 192.0 <= l < 384.0
			if(trilinear_en && log_in[9]) begin
				int_mm_no <= 4'h9; 
				lod_fract <= val[16:11];
			end 
			else begin
				int_mm_no <= 4'h8;
				lod_fract <= val[15:10];
			end
		end	
		11'b0_010xxxxxx_x, 11'b0_0011xxxxx_x: begin // 96.0 <= l < 192.0
			if(trilinear_en && log_in[8]) begin
				int_mm_no <= 4'h8; 
				lod_fract <= val[15:10];
			end 
			else begin
				int_mm_no <= 4'h7;
				lod_fract <= val[14:9];
			end
		end
		11'b0_0010xxxxx_x, 11'b0_00011xxxx_x:	begin // 48.0 <= l < 96.0
			if(trilinear_en && log_in[7]) begin
				int_mm_no <= 4'h7; 
				lod_fract <= val[14:9];
			end 
			else begin
				int_mm_no <= 4'h6;
				lod_fract <= val[13:8];
			end
		end
		11'b0_00010xxxx_x, 11'b0_000011xxx_x:	begin // 24.0 <= l < 48.0
			if(trilinear_en && log_in[6]) begin
				int_mm_no <= 4'h6; 
				lod_fract <= val[13:8];
			end 
			else begin
				int_mm_no <= 4'h5;
				lod_fract <= val[12:7];
			end
		end
		11'b0_000010xxx_x, 11'b0_0000011xx_x:	begin // 12.0 <= l < 24.0
			if(trilinear_en && log_in[5]) begin
				int_mm_no <= 4'h5; 
				lod_fract <= val[12:7];
			end 
			else begin
				int_mm_no <= 4'h4;
				lod_fract <= val[11:6];
			end
		end
		11'b0_0000010xx_x, 11'b0_00000011x_x:	begin // 6.0 <= l < 12.0
			if(trilinear_en && log_in[4]) begin
				int_mm_no <= 4'h4; 
				lod_fract <= val[11:6];
			end 
			else begin
				int_mm_no <= 4'h3;
				lod_fract <= val[10:5];
			end
		end
		11'b0_00000010x_x, 11'b0_000000011_x:	begin // 3.0 <= l < 6.0
			if(trilinear_en && log_in[3]) begin
				int_mm_no <= 4'h3; 
				lod_fract <= val[10:5];
			end 
			else begin
				int_mm_no <= 4'h2;
				lod_fract <= val[9:4];
			end
		end
		11'b0_000000010_x, 11'b0_000000001_1:	begin // 1.5 <= l < 3.0
			if(trilinear_en && log_in[2]) begin
				int_mm_no <= 4'h2; 
				lod_fract <= val[9:4];
			end 
			else begin
				int_mm_no <= 4'h1;
				lod_fract <= val[8:3];
			end
		end
		11'b0_000000001_0, 11'b0_000000000_x:	begin // 0.0 <= l < 1.5
			if(trilinear_en && log_in[1]) begin
				int_mm_no <= 4'h1; 
				lod_fract <= val[8:3];
			end 
			else begin
				int_mm_no <= 4'h0;
				lod_fract <= val[7:2];
			end
		end
		// 384.0 <= l < infinity
		default: begin
				int_mm_no <= 4'h9; 
				lod_fract <= val[16:11];
		end
	endcase
end

assign log2 = {int_mm_no, lod_fract};


endmodule",141,549
21,11,0,False,False,"module TBCTRL_2 (
  input HRESETn,
  input HCLK,
// input
  input HREADYin,
  input HREADYout,
  input HWRITEin,
  input HWRITEout,
  input HSEL,
  //input [3:0] HMASTER,
  input HGRANT,
// Output
  output MAPSn,
  output MDPSn,
  output DENn,
  output SDPSn,
  output SRSn
);
// Master
wire  MasterReadData;
wire  SlaveAddrPhaseSel;
wire					MasterAddrPhaseSel;
reg						MasterDataPhaseSel;
reg						MRWSel;
reg           reg_HGRANT;
// Slave
reg SlaveDataPhaseSel;
reg RWSel;


always@(posedge HCLK or negedge HRESETn)
begin
	 if(!HRESETn)
	   reg_HGRANT<=1'd0;
	 else 
	   reg_HGRANT<=HGRANT;
end

//assign DENn= MDPSn & SDPSn;
assign DENn = (MDPSn)?SDPSn:MDPSn;

// ----------------------------------------------------------
// ------ Master Control ------------------------------------
// ----------------------------------------------------------
// Control Logic
assign MAPSn = ~MasterAddrPhaseSel;
assign MDPSn = ~(MasterDataPhaseSel & MRWSel);
// Master Address Phase
//assign MasterAddrPhaseSel = (HMASTER == 4'd4)?(1'b1):(1'b0);
assign MasterAddrPhaseSel = reg_HGRANT;
// Master Data Phase
assign MasterReadData  =  MasterDataPhaseSel & (~MRWSel); 


always @(posedge HCLK or negedge HRESETn)
begin
  if (!HRESETn)
    MasterDataPhaseSel  <= 1'b1;
  else
    begin
      if  (HREADYin)
        MasterDataPhaseSel <= MasterAddrPhaseSel ;
    end 
end   

always @(posedge HCLK or negedge HRESETn)
begin
  if (!HRESETn)
    MRWSel <= 1'b0;
  else
  begin
    if (HREADYin)
      MRWSel <= HWRITEout;
  end
end
//---------END MASTER CONTROL -------------------------------

// ----------------------------------------------------------
// ------ Slave  Control ------------------------------------
// ----------------------------------------------------------
// Slave Address Phase
  assign SlaveAddrPhaseSel  = HSEL;  
  assign SDPSn   =   ~(SlaveDataPhaseSel & RWSel);
  assign SRSn   =  ~SlaveDataPhaseSel;

  always @(posedge HCLK or negedge HRESETn)
  begin
    if (!HRESETn)
      SlaveDataPhaseSel <= 1'b1;
    else
    begin
      if (HREADYin)
        SlaveDataPhaseSel <= SlaveAddrPhaseSel ;
      else 
       SlaveDataPhaseSel <= SlaveDataPhaseSel;
    end
  end  
  
 
// Read Write Select
  always @(posedge HCLK or negedge HRESETn)
  begin
    if (!HRESETn)
      RWSel <= 1'b0;
    else
    begin
      if (HREADYin)
        RWSel <= ~HWRITEin ;
      else 
        RWSel <=RWSel;
    end
  end
  
endmodule",114,552
947,1031,0,False,False,"module LCD(
    input clk,
    input rst,
    input [127:0] row_A,
    input [127:0] row_B,
    output LCD_E,
    output LCD_RS,
    output LCD_RW,
    output [3:0] LCD_D
    );
 reg lcd_inited;
 reg [3:0] init_d,icode,tcode,text_d;
 reg init_rs,init_rw,init_e;
 reg text_rs,text_rw,text_e;

 reg [23:0]init_count,text_count;
 
 assign LCD_E=(lcd_inited)?text_e:init_e;
 assign LCD_RS=(lcd_inited)?text_rs:init_rs;
 assign LCD_RW=(lcd_inited)?text_rw:init_rw;
 assign LCD_D=(lcd_inited)?text_d:init_d;
 
 always@(posedge clk or posedge rst) begin
    if(rst)begin
        init_count<=0;
        init_rs<=0;
        init_rw<=1;
        init_e<=0;
        init_d<=0;
        icode<=0;
        lcd_inited<=0;
    end
    else if(!lcd_inited)begin
        init_count<=init_count+1;
        init_e<=init_count[19];
        init_rw<=0;
        init_rs<=0;
        init_d<=icode;
        case(init_count[23:20])
        0:icode<=4'h3;
        1:icode<=4'h3;
        2:icode<=4'h3;
        3:icode<=4'h2;
        
        4:icode<=4'h2;
        5:icode<=4'h8;
        
        6:icode<=4'h0;
        7:icode<=4'h6;
        
        8:icode<=4'h0;
        9:icode<=4'hC;
        
        10:icode<=4'h0;
        11:icode<=4'h1;
        default:{init_rw,lcd_inited}<=2'b11;
        endcase
    end
 end
 
 always@(posedge clk or posedge rst)begin
    if(rst)begin
        text_e<=0;
        text_rs<=0;
        text_rw<=1;
        text_count<=0;
        text_d<=0;
        tcode<=0;
    end
    else if (lcd_inited)begin
        text_count<=(text_count[23:17]<68)?text_count+1:0;
        text_e<=text_count[16];
        text_rs<=1;
        text_rw<=0;
        text_d<=tcode;
        case(text_count[23:17])
        0:{text_rs,text_rw,tcode}<=6'b001000;
        1:{text_rs,text_rw,tcode}<=6'b000000;
        
        2:tcode<=row_A[127:124];
        3:tcode<=row_A[123:120];
        4:tcode<=row_A[119:116];
        5:tcode<=row_A[115:112];
        6:tcode<=row_A[111:108];
        7:tcode<=row_A[107:104];
        8:tcode<=row_A[103:100];
        9:tcode<=row_A[99:96];
        10:tcode<=row_A[95:92];
        11:tcode<=row_A[91:88];
        12:tcode<=row_A[87:84];
        13:tcode<=row_A[83:80];
        14:tcode<=row_A[79:76];
        15:tcode<=row_A[75:72];
        16:tcode<=row_A[71:68];
        17:tcode<=row_A[67:64];
        18:tcode<=row_A[63:60];
        19:tcode<=row_A[59:56];
        20:tcode<=row_A[55:52];
        21:tcode<=row_A[51:48];
        22:tcode<=row_A[47:44];
        23:tcode<=row_A[43:40];
        24:tcode<=row_A[39:36];
        25:tcode<=row_A[35:32];
        26:tcode<=row_A[31:28];
        27:tcode<=row_A[27:24];
        28:tcode<=row_A[23:20];
        29:tcode<=row_A[19:16];
        30:tcode<=row_A[15:12];
        31:tcode<=row_A[11:8];
        32:tcode<=row_A[7:4];
        33:tcode<=row_A[3:0];
        
        34:{text_rs,text_rw,tcode}<=6'b001100;
        35:{text_rs,text_rw,tcode}<=6'b000000;
        
        36:tcode<=row_B[127:124];
        37:tcode<=row_B[123:120];
        38:tcode<=row_B[119:116];
        39:tcode<=row_B[115:112];
        40:tcode<=row_B[111:108];
        41:tcode<=row_B[107:104];
        42:tcode<=row_B[103:100];
        43:tcode<=row_B[99:96];
        44:tcode<=row_B[95:92];
        45:tcode<=row_B[91:88];
        46:tcode<=row_B[87:84];
        47:tcode<=row_B[83:80];
        48:tcode<=row_B[79:76];
        49:tcode<=row_B[75:72];
        50:tcode<=row_B[71:68];
        51:tcode<=row_B[67:64];
        52:tcode<=row_B[63:60];
        53:tcode<=row_B[59:56];
        54:tcode<=row_B[55:52];
        55:tcode<=row_B[51:48];
        56:tcode<=row_B[47:44];
        57:tcode<=row_B[43:40];
        58:tcode<=row_B[39:36];
        59:tcode<=row_B[35:32];
        60:tcode<=row_B[31:28];
        61:tcode<=row_B[27:24];
        62:tcode<=row_B[23:20];
        63:tcode<=row_B[19:16];
        64:tcode<=row_B[15:12];
        65:tcode<=row_B[11:8];
        66:tcode<=row_B[7:4];
        67:tcode<=row_B[3:0];
        default:{text_rs,text_rw,tcode}<=6'h10;
        endcase
    end
 end


endmodule",154,557
258,382,0,False,False,"module clock_divider(
    input clk,
    input rst,
    output reg clk_div
    );
    
   localparam constantNumber = 8_000;
   
   reg [63:0] count;

    
   always @ (posedge(clk) or posedge(rst))
   begin
       if (rst == 1'b1)
           count <= 32'd0;
       else if (count == (constantNumber - 32'd1))
           count <= 32'd0;
       else
           count <= count + 32'b1;
   end
   
   always @ (posedge(clk) or posedge(rst))
   begin
       if (rst == 1'b1)
           clk_div <= 1'b0;
       else if (count == (constantNumber - 1))
           clk_div <= ~clk_div;
       else
           clk_div <= clk_div;
   end 
    
endmodule",32,558
6,2,0,False,False,"module sky130_fd_sc_ls__a21oi (
    Y ,
    A1,
    A2,
    B1
);

    // Module ports
    output Y ;
    input  A1;
    input  A2;
    input  B1;

    // Local signals
    wire and0_out  ;
    wire nor0_out_Y;

    //  Name  Output      Other arguments
    and and0 (and0_out  , A1, A2         );
    nor nor0 (nor0_out_Y, B1, and0_out   );
    buf buf0 (Y         , nor0_out_Y     );

endmodule",23,567
236,240,0,False,False,"module encoder(in,out);
input [39:0] in;
output [5:0] out;

assign out =  (in[0]==1'b1)?6'd0:
              (in[1]==1'b1)?6'd1:
			  (in[2]==1'b1)?6'd2:
			  (in[3]==1'b1)?6'd3:
			  (in[4]==1'b1)?6'd4:
			  (in[5]==1'b1)?6'd5:
			  (in[6]==1'b1)?6'd6:
			  (in[7]==1'b1)?6'd7:
			  (in[8]==1'b1)?6'd8:
			  (in[9]==1'b1)?6'd9:
			  (in[10]==1'b1)?6'd10:
			  (in[11]==1'b1)?6'd11:
			  (in[12]==1'b1)?6'd12:
			  (in[13]==1'b1)?6'd13:
			  (in[14]==1'b1)?6'd14:
			  (in[15]==1'b1)?6'd15:
			  (in[16]==1'b1)?6'd16:
			  (in[17]==1'b1)?6'd17:
			  (in[18]==1'b1)?6'd18:
			  (in[19]==1'b1)?6'd19:
			  (in[20]==1'b1)?6'd20:
			  (in[21]==1'b1)?6'd21:
			  (in[22]==1'b1)?6'd22:
			  (in[23]==1'b1)?6'd23:
			  (in[24]==1'b1)?6'd24:
			  (in[25]==1'b1)?6'd25:
			  (in[26]==1'b1)?6'd26:
			  (in[27]==1'b1)?6'd27:
			  (in[28]==1'b1)?6'd28:
			  (in[29]==1'b1)?6'd29:
			  (in[30]==1'b1)?6'd30:
			  (in[31]==1'b1)?6'd31:
			  (in[32]==1'b1)?6'd32:
			  (in[33]==1'b1)?6'd33:
			  (in[34]==1'b1)?6'd34:
			  (in[35]==1'b1)?6'd35:
			  (in[36]==1'b1)?6'd36:
			  (in[37]==1'b1)?6'd37:
			  (in[38]==1'b1)?6'd38:
			  (in[39]==1'b1)?6'd39:
			  6'b000000;
endmodule",46,575
9,9,0,False,False,"module soc_system_key_pio (
                            // inputs:
                             address,
                             clk,
                             in_port,
                             reset_n,

                            // outputs:
                             readdata
                          )
;

  output  [ 31: 0] readdata;
  input   [  1: 0] address;
  input            clk;
  input   [  3: 0] in_port;
  input            reset_n;

  wire             clk_en;
  wire    [  3: 0] data_in;
  wire    [  3: 0] read_mux_out;
  reg     [ 31: 0] readdata;
  assign clk_en = 1;
  //s1, which is an e_avalon_slave
  assign read_mux_out = {4 {(address == 0)}} & data_in;
  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          readdata <= 0;
      else if (clk_en)
          readdata <= {32'b0 | read_mux_out};
    end


  assign data_in = in_port;

endmodule",37,577
6,2,0,False,False,"module sky130_fd_sc_ls__and3 (
    X,
    A,
    B,
    C
);

    // Module ports
    output X;
    input  A;
    input  B;
    input  C;

    // Local signals
    wire and0_out_X;

    //  Name  Output      Other arguments
    and and0 (and0_out_X, C, A, B        );
    buf buf0 (X         , and0_out_X     );

endmodule",21,585
4,1,0,False,False,"module sky130_fd_sc_ms__nor2 (
    Y,
    A,
    B
);

    // Module ports
    output Y;
    input  A;
    input  B;

    // Local signals
    wire nor0_out_Y;

    //  Name  Output      Other arguments
    nor nor0 (nor0_out_Y, A, B           );
    buf buf0 (Y         , nor0_out_Y     );

endmodule",19,587
9733,17720,0,False,False,"module rf_2p_be (
				clka    ,  
				cena_i  ,
		        addra_i ,
		        dataa_o ,
				clkb    ,     
				cenb_i  ,   
				wenb_i  ,   
				addrb_i	,  
				datab_i
);

// ********************************************
//                                             
//    Parameter DECLARATION                    
//                                             
// ********************************************
parameter     		Word_Width=32;
parameter	  		Addr_Width=8;
parameter			Byte_Width=(Word_Width>>3);

// ********************************************
//                                             
//    Input/Output DECLARATION                    
//                                             
// ********************************************
// A port
input                     clka;      // clock input
input   		          cena_i;    // chip enable, low active
input   [Addr_Width-1:0]  addra_i;   // address input
output	[Word_Width-1:0]  dataa_o;   // data output

// B Port
input                     clkb;      // clock input                     
input   		          cenb_i;    // chip enable, low active      
input   [Byte_Width-1:0]  wenb_i;    // write enable, low active       
input   [Addr_Width-1:0]  addrb_i;   // address input                   
input   [Word_Width-1:0]  datab_i;   // data input                     

// ********************************************
//                                             
//    Register DECLARATION                 
//                                             
// ********************************************
reg    [Word_Width-1:0]   mem_array[(1<<Addr_Width)-1:0];

// ********************************************
//                                             
//    Wire DECLARATION                 
//                                             
// ********************************************
reg	   [Word_Width-1:0]  dataa_r;

reg	   [Word_Width-1:0]  datab_w;
wire   [Word_Width-1:0]  datab_m;
// ********************************************
//                                             
//    Logic DECLARATION                 
//                                             
// ********************************************
// -- A Port --//
always @(posedge clka) begin
	if (!cena_i)
		dataa_r <= mem_array[addra_i];
	else
		dataa_r <= 'bx;
end

assign dataa_o = dataa_r;

// -- B Port --//
assign datab_m = mem_array[addrb_i];

genvar j;
generate
	for (j=0; j<Byte_Width; j=j+1) begin:j_n
		always@(*) begin
			datab_w[(j+1)*8-1:j*8] = wenb_i[j] ? datab_m[(j+1)*8-1:j*8]:datab_i[(j+1)*8-1:j*8];
		end
	end
endgenerate

always @(posedge clkb) begin                
	if(!cenb_i && !(&wenb_i)) 
		mem_array[addrb_i] <= datab_w;
end

endmodule",88,591
240,374,0,False,False,"module Computer_Datapath_RegisterFile(

	output reg [WORD_WIDTH-1:0] ADDR_bus_out,
	output reg [WORD_WIDTH-1:0] B_data_out,
	input [CNTRL_WIDTH-1:0] CNTRL_bus_in,
	input [WORD_WIDTH-1:0] D_bus_in,
	input CLK,
	input RST

	);

parameter WORD_WIDTH = 16;
parameter DR_WIDTH = 3;
parameter SA_WIDTH = DR_WIDTH;
parameter SB_WIDTH = DR_WIDTH;
parameter OPCODE_WIDTH = 7;
parameter FS_WIDTH = 4;
parameter CNTRL_FLAGS_WIDTH = 7;
parameter CNTRL_WIDTH = DR_WIDTH+SA_WIDTH+SB_WIDTH+FS_WIDTH+CNTRL_FLAGS_WIDTH;

wire RW = CNTRL_bus_in[4];

wire [SA_WIDTH-1:0] DA = CNTRL_bus_in[19:17];
wire [SA_WIDTH-1:0] AA = CNTRL_bus_in[16:14];
wire [SA_WIDTH-1:0] BA = CNTRL_bus_in[13:11];

reg [WORD_WIDTH-1:0] SYNC_RAM0 [2**DR_WIDTH-1:0];
reg [WORD_WIDTH-1:0] SYNC_RAM1 [2**DR_WIDTH-1:0];

reg [DR_WIDTH-1:0] i;

always@(posedge CLK) begin
	/*
	if (!RST)
		for (i=3'b0;i<2**DR_WIDTH-3'b1;i = i + 3'b1) begin
			SYNC_RAM1[i] <= 0;
			SYNC_RAM0[i] <= 0;
		end
		else if (RW) begin
		*/
	if(RW) begin
		SYNC_RAM0[DA] <= D_bus_in;
		SYNC_RAM1[DA] <= D_bus_in;
	end
end

always@(*) begin
	ADDR_bus_out <= SYNC_RAM0[AA];
	B_data_out <= SYNC_RAM1[BA];
end

endmodule",52,594
240,404,0,True,False,"module ac97_out_fifo(clk, rst, en, mode, din, we, dout, re, status, full, empty);

input		clk, rst;
input		en;
input	[1:0]	mode;
input	[31:0]	din;
input		we;
output	[19:0]	dout;
input		re;
output	[1:0]	status;
output		full;
output		empty;


////////////////////////////////////////////////////////////////////
//
// Local Wires
//

reg	[31:0]	mem[0:3];

reg	[2:0]	wp;
reg	[3:0]	rp;

wire	[2:0]	wp_p1;

reg	[1:0]	status;
reg	[19:0]	dout;
wire	[31:0]	dout_tmp;
wire	[15:0]	dout_tmp1;
wire		m16b;
reg		empty;

////////////////////////////////////////////////////////////////////
//
// Misc Logic
//

assign m16b = (mode == 2'h0);	// 16 Bit Mode

always @(posedge clk)
	if(!en)		wp <= #1 3'h0;
	else
	if(we)		wp <= #1 wp_p1;

assign wp_p1 = wp + 3'h1;

always @(posedge clk)
	if(!en)		rp <= #1 4'h0;
	else
	if(re & m16b)	rp <= #1 rp + 4'h1;
	else
	if(re & !m16b)	rp <= #1 rp + 4'h2;

always @(posedge clk)
	status <= #1 (wp[1:0] - rp[2:1]) - 2'h1;

wire	[3:0]	rp_p1 = rp[3:0] + 4'h1;

always @(posedge clk)
	empty <= #1 (rp_p1[3:1] == wp[2:0]) & (m16b ? rp_p1[0] : 1'b1);

assign full  = (wp[1:0] == rp[2:1]) & (wp[2] != rp[3]);

// Fifo Output
assign dout_tmp = mem[ rp[2:1] ];

// Fifo Output Half Word Select
assign dout_tmp1 = rp[0] ? dout_tmp[31:16] : dout_tmp[15:0];

always @(posedge clk)
	if(!en)		dout <= #1 20'h0;
	else
	if(re)
		case(mode)	// synopsys parallel_case full_case
		   2'h0: dout <= #1 {dout_tmp1, 4'h0};		// 16 Bit Output
		   2'h1: dout <= #1 {dout_tmp[17:0], 2'h0};	// 18 bit Output
		   2'h2: dout <= #1 dout_tmp[19:0];		// 20 Bit Output
		endcase

always @(posedge clk)
	if(we)	mem[wp[1:0]] <= #1 din;

endmodule",84,602
397,689,0,True,False,"module ac97_out_fifo(clk, rst, en, mode, din, we, dout, re, status, full, empty);

input		clk, rst;
input		en;
input	[1:0]	mode;
input	[31:0]	din;
input		we;
output	[19:0]	dout;
input		re;
output	[1:0]	status;
output		full;
output		empty;


////////////////////////////////////////////////////////////////////
//
// Local Wires
//

reg	[31:0]	mem[0:7];

reg	[3:0]	wp;
reg	[4:0]	rp;

wire	[3:0]	wp_p1;

reg	[1:0]	status;
reg	[19:0]	dout;
wire	[31:0]	dout_tmp;
wire	[15:0]	dout_tmp1;
wire		m16b;
reg		empty;

////////////////////////////////////////////////////////////////////
//
// Misc Logic
//

assign m16b = (mode == 2'h0);	// 16 Bit Mode

always @(posedge clk)
	if(!en)		wp <= #1 4'h0;
	else
	if(we)		wp <= #1 wp_p1;

assign wp_p1 = wp + 4'h1;

always @(posedge clk)
	if(!en)		rp <= #1 5'h0;
	else
	if(re & m16b)	rp <= #1 rp + 5'h1;
	else
	if(re & !m16b)	rp <= #1 rp + 5'h2;

always @(posedge clk)
	status <= #1 (wp[2:1] - rp[3:2]) - 2'h1;

wire	[4:0]	rp_p1 = rp[4:0] + 5'h1;

always @(posedge clk)
	empty <= #1 (rp_p1[4:1] == wp[3:0]) & (m16b ? rp_p1[0] : 1'b1);

assign full  = (wp[2:0] == rp[3:1]) & (wp[3] != rp[4]);

// Fifo Output
assign dout_tmp = mem[ rp[3:1] ];

// Fifo Output Half Word Select
assign dout_tmp1 = rp[0] ? dout_tmp[31:16] : dout_tmp[15:0];

always @(posedge clk)
	if(!en)		dout <= #1 20'h0;
	else
	if(re)
		case(mode)	// synopsys parallel_case full_case
		   2'h0: dout <= #1 {dout_tmp1, 4'h0};		// 16 Bit Output
		   2'h1: dout <= #1 {dout_tmp[17:0], 2'h0};	// 18 bit Output
		   2'h2: dout <= #1 dout_tmp[19:0];		// 20 Bit Output
		endcase


always @(posedge clk)
	if(we)	mem[wp[2:0]] <= #1 din;

endmodule",85,603
692,1236,0,True,False,"module ac97_out_fifo(clk, rst, en, mode, din, we, dout, re, status, full, empty);

input		clk, rst;
input		en;
input	[1:0]	mode;
input	[31:0]	din;
input		we;
output	[19:0]	dout;
input		re;
output	[1:0]	status;
output		full;
output		empty;


////////////////////////////////////////////////////////////////////
//
// Local Wires
//

reg	[31:0]	mem[0:15];

reg	[4:0]	wp;
reg	[5:0]	rp;

wire	[4:0]	wp_p1;

reg	[1:0]	status;
reg	[19:0]	dout;
wire	[31:0]	dout_tmp;
wire	[15:0]	dout_tmp1;
wire		m16b;
reg		empty;

////////////////////////////////////////////////////////////////////
//
// Misc Logic
//

assign m16b = (mode == 2'h0);	// 16 Bit Mode

always @(posedge clk)
	if(!en)		wp <= #1 5'h0;
	else
	if(we)		wp <= #1 wp_p1;

assign wp_p1 = wp + 4'h1;

always @(posedge clk)
	if(!en)		rp <= #1 6'h0;
	else
	if(re & m16b)	rp <= #1 rp + 6'h1;
	else
	if(re & !m16b)	rp <= #1 rp + 6'h2;

always @(posedge clk)
	status <= #1 (wp[3:2] - rp[4:3]) - 2'h1;

wire	[5:0]	rp_p1 = rp[5:0] + 6'h1;

always @(posedge clk)
	empty <= #1 (rp_p1[5:1] == wp[4:0]) & (m16b ? rp_p1[0] : 1'b1);

assign full  = (wp[3:0] == rp[4:1]) & (wp[4] != rp[5]);

// Fifo Output
assign dout_tmp = mem[ rp[4:1] ];

// Fifo Output Half Word Select
assign dout_tmp1 = rp[0] ? dout_tmp[31:16] : dout_tmp[15:0];

always @(posedge clk)
	if(!en)		dout <= #1 20'h0;
	else
	if(re)
		case(mode)	// synopsys parallel_case full_case
		   2'h0: dout <= #1 {dout_tmp1, 4'h0};		// 16 Bit Output
		   2'h1: dout <= #1 {dout_tmp[17:0], 2'h0};	// 18 bit Output
		   2'h2: dout <= #1 dout_tmp[19:0];		// 20 Bit Output
		endcase


always @(posedge clk)
	if(we)	mem[wp[3:0]] <= #1 din;

endmodule",85,604
10,4,0,False,False,"module sky130_fd_sc_ls__a2111oi (
    Y ,
    A1,
    A2,
    B1,
    C1,
    D1
);

    // Module ports
    output Y ;
    input  A1;
    input  A2;
    input  B1;
    input  C1;
    input  D1;

    // Local signals
    wire and0_out  ;
    wire nor0_out_Y;

    //  Name  Output      Other arguments
    and and0 (and0_out  , A1, A2              );
    nor nor0 (nor0_out_Y, B1, C1, D1, and0_out);
    buf buf0 (Y         , nor0_out_Y          );

endmodule",27,612
214,273,0,False,False,"module dyn_pll_ctrl # (parameter SPEED_MHZ = 25, parameter SPEED_LIMIT = 100, parameter SPEED_MIN = 25, parameter OSC_MHZ = 100)
	(clk,
	clk_valid,
	speed_in,
	start,
	progclk,
	progdata,
	progen,
	reset,
	locked,
	status);

	input clk;				// NB Assumed to be 12.5MHz uart_clk
	input clk_valid;		// Drive from LOCKED output of first dcm (ie uart_clk valid)
	input [7:0] speed_in;
	input start;
	output reg progclk = 0;
	output reg progdata = 0;
	output reg progen = 0;
	output reg reset = 0;
	input locked;
	input [2:1] status;

	// NB spec says to use (dval-1) and (mval-1), but I don't think we need to be that accurate
	//    and this saves an adder. Feel free to amend it.
	reg [23:0] watchdog = 0;
	reg [7:0] state = 0;
	reg [7:0] dval = OSC_MHZ;	// Osc clock speed (hence mval scales in MHz)
	reg [7:0] mval = SPEED_MHZ;
	reg start_d1 = 0;
	
	always @ (posedge clk)
	begin
		progclk <= ~progclk;
		start_d1 <= start;
		reset <= 1'b0;
		
		// Watchdog is just using locked, perhaps also need | ~status[2]
		if (locked)
			watchdog <= 0;
		else
			watchdog <= watchdog + 1'b1;
		
		if (watchdog[23])		// Approx 670mS at 12.5MHz - NB spec is 5ms to lock at >50MHz CLKIN (50ms at <50MHz CLKIN)
		begin					// but allow longer just in case
			watchdog <= 0;
			reset <= 1'b1;		// One cycle at 12.5MHz should suffice (requirment is 3 CLKIN at 100MHz)
		end
		
		if (~clk_valid)			// Try not to run while clk is unstable
		begin
			progen <= 0;
			progdata <= 0;
			state <= 0;
		end
		else
		begin
		
			// The documentation is unclear as to whether the DCM loads data on positive or negative edge. The timing
			// diagram unhelpfully shows data changing on the positive edge, which could mean either its sampled on
			// negative, or it was clocked on positive! However the following (WRONGLY) says NEGATIVE ...
			// http://forums.xilinx.com/t5/Spartan-Family-FPGAs/Spartan6-DCM-CLKGEN-does-PROGCLK-have-a-maximum-period-minimum/td-p/175642
			// BUT this can lock up the DCM, positive clock seems more reliable (but it can still lock up for low values of M, eg 2).
			// Added SPEED_MIN to prevent this (and positive clock is correct, after looking at other implementations eg ztex/theseven)
		
			if ((start || start_d1) && state==0 && speed_in >= SPEED_MIN && speed_in <= SPEED_LIMIT && progclk==1)	// positive clock
			// if ((start || start_d1) && state==0 && speed_in >= SPEED_MIN && speed_in <= SPEED_LIMIT && progclk==0)	// negative clock
			begin
				progen <= 0;
				progdata <= 0;
				mval <= speed_in;
				dval <= OSC_MHZ;
				state <= 1;
			end
			if (state != 0)
				state <= state + 1'd1;
			case (state)		// Even values to sync with progclk
				// Send D
				2: begin
					progen <= 1;
					progdata <= 1;
				end
				4: begin
					progdata <= 0;
				end
				6,8,10,12,14,16,18,20: begin
					progdata <= dval[0];
					dval[6:0] <= dval[7:1];
				end
				22: begin
					progen <= 0;
					progdata <= 0;
				end
				// Send M
				32: begin
					progen <= 1;
					progdata <= 1;
				end
				36,38,40,42,44,46,48,50: begin
					progdata <= mval[0];
					mval[6:0] <= mval[7:1];
				end
				52: begin
					progen <= 0;
					progdata <= 0;
				end
				// Send GO - NB 1 clock cycle
				62: begin
					progen <= 1;
				end
				64: begin
					progen <= 0;
				end
				// We should wait on progdone/locked, but just go straight back to idle
				254: begin
					state <= 0;
				end
			endcase
		end
	end
endmodule",121,623
665,838,0,False,False,"module fillbox_act (
	input wire [27:0] vram,
	input wire [9:0] width,
	input wire [9:0] height,
	input wire start,
	output wire done,

	// AXI4 stuff
	input wire clk,
	input wire bready,
	output reg [27:0] awaddr,
	output reg burst_start,
	output reg [7:0] awlen,
	output reg [3:0] wstrb
);

// X/Y axis state machine
parameter IDLE = 2'h0,
	START = 2'h1,
	WAIT = 2'h2;
localparam SCREEN_WIDTH = 28'd1280;

reg [27:0] vram_y = 0;
reg [10:0] offset = 0;
reg [10:0] delta = 0;
reg [9:0] width_work = 0;
reg [9:0] height_work = 0;
reg [9:0] expected_count = 0;
reg [9:0] real_count = 0;
reg [1:0] state_x = IDLE, state_y = IDLE;
reg	start_x = 0;
reg	end_x = 0;
reg	done_ff1 = 0;
reg	done_ff2 = 0;
wire [27:0] awaddr_tmp = vram_y + {17'b0, offset};
assign	done = done_ff1 && ~done_ff2;

// end of accelarator action
always @(posedge clk) begin
	done_ff2 <= done_ff1;
	done_ff1 <= (width_work == 10'd0 && height_work == 10'd0 && expected_count == real_count);
	awaddr <= {awaddr_tmp[27:2], 2'b0};
end

// real access count
always @(posedge clk) begin
  if (start_x == 'b0)
    real_count <= 10'd0;
  else if (bready)
    real_count <= real_count + 10'd1;
  else
    real_count <= real_count;
end

// Y axis action
always @(posedge clk) begin
  case (state_y)
    IDLE:
      begin
        if (start) begin
          state_y <= START;
          height_work <= height;
          vram_y <= vram;
        end
        else begin
          state_y <= state_y;
          height_work <= height_work;
          vram_y <= vram_y;
        end
        start_x <= 'b0;
      end
    START:
      begin
        if (height_work == 10'd0) begin
          state_y <= IDLE;
          height_work <= 10'd0;
          vram_y <= vram_y;
          start_x <= 'b0;
        end
        else begin
          state_y <= WAIT;
          height_work <= height_work;
          vram_y <= vram_y;
          start_x <= 'b1;
        end
      end
    WAIT:
      begin
        if (end_x) begin
          state_y <= START;
          height_work <= height_work - 10'd1;
          vram_y <= vram_y + SCREEN_WIDTH;
          start_x <= 'b0;
        end
        else begin
          state_y <= state_y;
          height_work <= height_work;
          vram_y <= vram_y;
          start_x <= start_x;
        end
      end
    default:
      begin
        state_y <= IDLE;
        height_work <= height_work;
        vram_y <= vram_y;
        start_x <= 'b0;
      end
  endcase
end

// X axis action
always @(posedge clk) begin
  if (start_x == 'b0) begin
    end_x <= 'b0;
    expected_count = 10'd0;
    width_work <= 10'd0;
    offset <= 11'd0;
    delta <= 11'd0;
    burst_start <= 'b0;
    awlen <= 8'd0;
    wstrb <= 4'b0000;
    state_x <= IDLE;
  end
  else begin
    case (state_x)
      IDLE:
        begin
          end_x <= 'b0;
          expected_count <= 10'd0;
          width_work <= width;
          offset <= 11'd0;
          delta <= 11'd0;
          burst_start <= 'b0;
          awlen <= 8'd0;
          wstrb <= 4'b0000;
          state_x <= START;
        end
      START:
        begin
          if (width_work == 10'd0) begin
            end_x <= 'b1;
            expected_count <= expected_count;
            width_work <= width_work;
            offset <= offset;
            delta <= delta;
            burst_start <= 'b0;
            awlen <= awlen;
            wstrb <= wstrb;
            state_x <= IDLE;
          end
          else begin
            if (awaddr_tmp[1]) begin
              // address not divisable by 4
              // width_work greater than 0
              width_work <= width_work - 10'd1;
              delta <= 11'd2;
              wstrb <= 4'b1100;
              awlen <= 8'd0;
            end
            else if (width_work == 10'd1) begin
              // address divisable by 4
              // width_work equal to 1
              width_work <= width_work - 10'd1;
              delta <= 11'd2;
              wstrb <= 4'b0011;
              awlen <= 8'd0;
            end
            else if (awaddr_tmp[2] || width_work <= 10'd3) begin
              // address not divisable by 8
              // width_work greater than 1, less than 4
              width_work <= width_work - 10'd2;
              delta <= 11'd4;
              wstrb <= 4'b1111;
              awlen <= 8'd0;
            end
            else if (awaddr_tmp[3] || width_work <= 10'd7) begin
              // address not divisable by 16
              // width_work greater than 3, less than 8
              width_work <= width_work - 10'd4;
              delta <= 11'd8;
              wstrb <= 4'b1111;
              awlen <= 8'd1;
            end
            else if (awaddr_tmp[4] || width_work <= 10'd15) begin
              // address not divisable by 32
              // width_work greater than 7, less than 16
              width_work <= width_work - 10'd8;
              delta <= 11'd16;
              wstrb <= 4'b1111;
              awlen <= 8'd3;
            end
            else if (awaddr_tmp[5] || width_work <= 10'd31) begin
              // address not divisable by 64
              // width_work greater thean 15, less than 32
              width_work <= width_work - 10'd16;
              delta <= 11'd32;
              wstrb <= 4'b1111;
              awlen <= 8'd7;
            end
            else begin
              // address divisable by 64
              // width_work greater than 31
              width_work <= width_work - 10'd32;
              delta <= 11'd64;
              wstrb <= 4'b1111;
              awlen <= 8'd15;
            end
            end_x <= 'b0;
            expected_count <= expected_count + 10'd1;
            offset <= offset;
            burst_start <= 'b1;
            state_x <= WAIT;
          end
        end
      WAIT:
        begin
          if (bready) begin
            offset <= offset + delta;
            delta <= 11'd0;
            state_x <= START;
          end
          else begin
            offset <= offset;
            delta <= delta;
            state_x <= state_x;
          end
          awlen <= awlen;
          wstrb <= wstrb;
          burst_start <= 'b0;
          end_x <= 'b0;
          expected_count <= expected_count;
          width_work <= width_work;
        end
      default:
        begin
          end_x <= 'b0;
          expected_count <= expected_count;
          width_work <= width_work;
          offset <= offset;
          delta <= delta;
          burst_start <= 'b0;
          awlen <= awlen;
          wstrb <= wstrb;
          state_x <= IDLE;
        end
    endcase
  end
end

endmodule",251,638
44,37,0,True,False,"module trng_debug_ctrl(
                       // Clock and reset.
                       input wire           clk,
                       input wire           reset_n,
                       
                       // Control.
                       input wire           cs,
                       input wire           we,
              
                       // Data ports.
                       input wire  [7 : 0]  address,
                       input wire  [31 : 0] write_data,
                       output wire [31 : 0] read_data,
                       output wire          error,

                       // Debug and control ports
                       output wire          csprng_debug_mode,
                       output wire [4 : 0]  csprng_num_rounds,
                       output wire          csprng_reseed,
                       input wire           csprng_error,
            
                       output wire          security_error
                      );

  
  //----------------------------------------------------------------
  // Internal constant and parameter definitions.
  //----------------------------------------------------------------
  parameter ADDR_NAME0         = 8'h00;
  parameter ADDR_NAME1         = 8'h01;
  parameter ADDR_VERSION       = 8'h02;
  
  parameter CORE_NAME0         = 32'h73686132; // ""sha2""
  parameter CORE_NAME1         = 32'h2d323536; // ""-512""
  parameter CORE_VERSION       = 32'h302e3830; // ""0.80""

  
  //----------------------------------------------------------------
  // Registers including update variables and write enable.
  //----------------------------------------------------------------

  
  //----------------------------------------------------------------
  // Wires.
  //----------------------------------------------------------------
  reg [31 : 0] tmp_read_data;
  reg          tmp_error;
  
  
  //----------------------------------------------------------------
  // Concurrent connectivity for ports etc.
  //----------------------------------------------------------------
  assign read_data = tmp_read_data;
  assign error     = tmp_error;
  
             
  //----------------------------------------------------------------
  // core instantiation.
  //----------------------------------------------------------------
  
  
  //----------------------------------------------------------------
  // reg_update
  //
  // Update functionality for all registers in the core.
  // All registers are positive edge triggered with synchronous
  // active low reset. All registers have write enable.
  //----------------------------------------------------------------
  always @ (posedge clk)
    begin
      if (!reset_n)
        begin

        end
      else
        begin

        end
    end // reg_update


  //----------------------------------------------------------------
  // api_logic
  //
  // Implementation of the api logic. If cs is enabled will either 
  // try to write to or read from the internal registers.
  //----------------------------------------------------------------
  always @*
    begin : api_logic
      tmp_read_data = 32'h00000000;
      tmp_error     = 0;
      
      if (cs)
        begin
          if (we)
            begin
              case (address)
                // Write operations.
                
                default:
                  begin
                    tmp_error = 1;
                  end
              endcase // case (address)
            end // if (we)

          else
            begin
              case (address)
                // Read operations.
                ADDR_NAME0:
                  begin
                    tmp_read_data = CORE_NAME0;
                  end

                ADDR_NAME1:
                  begin
                    tmp_read_data = CORE_NAME1;
                  end
                
                ADDR_VERSION:
                  begin
                    tmp_read_data = CORE_VERSION;
                  end
                
                default:
                  begin
                    tmp_error = 1;
                  end
              endcase // case (address)
            end
        end
    end // addr_decoder
endmodule",134,642
395,442,0,False,False,"module mips_pipeline    (
                        input             clk,
                        input             rst,

                        input             pl_stall_mem,
                        input             pl_stall_branch,
                        input             pl_stall_multdiv,
                        input             pl_stall_eret,
                        input             exception,

                        output[5:0]       ifield_fstage_opcode,
                        output[4:0]       ifield_fstage_d,
                        output[4:0]       ifield_fstage_t,
                        output[4:0]       ifield_fstage_s,
                        output[4:0]       ifield_fstage_shift,
                        output[5:0]       ifield_fstage_func,

                        input             pmem_cmdok,
                        input[31:0]       pmem_cmd,
                        input             pmem_branch_ended,

                        input             alu_multdiv_ready,

                        output reg        pl_cause_bd,
                        output reg        pl_pcpause
                        );




  reg[31:0]   pl_instr_fstage;
  reg[31:0]   pl_instr_fstage_d;
  reg[1:0]    cpu_state;
  reg[1:0]    cpu_state_d;

  reg         pl_pcpause_d;
  reg         instr_next;
  reg         instr_next_d;
  reg         pl_branch_excpt;
  reg         pl_branch_excpt_d;
  reg         branch_stall_was;
  reg         branch_stall_was_d;
  localparam  NORMAL=         2'b00,
              STALL_BRANCH=   2'b01,
              STALL_MEM=      2'b10,
              STALL_MULTDIV=  2'b11;




  assign ifield_fstage_opcode= pl_instr_fstage_d[31:26];
  assign ifield_fstage_s= pl_instr_fstage_d[25:21];
  assign ifield_fstage_t= pl_instr_fstage_d[20:16];
  assign ifield_fstage_d= pl_instr_fstage_d[15:11];
  assign ifield_fstage_shift= pl_instr_fstage_d[10:6];
  assign ifield_fstage_func= pl_instr_fstage_d[5:0];

  always @*
  begin
  pl_instr_fstage= pmem_cmd;
  cpu_state= NORMAL;
  instr_next= instr_next_d;
  pl_pcpause= pl_pcpause_d;
  branch_stall_was= branch_stall_was_d;
  pl_cause_bd= 1'b0;
  pl_branch_excpt= pl_branch_excpt_d;

  case(cpu_state_d)
  NORMAL:
    begin
    pl_pcpause= 1'b0;
    branch_stall_was= 1'b0;
    if(exception | ((pl_stall_eret | pl_stall_branch) & !pl_stall_mem))
      begin
      instr_next= !pmem_cmdok & !(pl_stall_eret | exception);
                  //DELAY SLOT HOW NOP
      pl_instr_fstage= pl_stall_eret | exception | !pmem_cmdok ? 32'd0 :
                       pmem_cmd;
      cpu_state= STALL_BRANCH;
      end
    else if(pl_stall_mem | pl_stall_multdiv)
      begin
      pl_pcpause= 1'b1;
      pl_instr_fstage= pl_instr_fstage_d;
      cpu_state= pl_stall_mem ? STALL_MEM : STALL_MULTDIV;
      end
    else if(!pmem_cmdok) pl_instr_fstage= 32'd0;
    end
  STALL_BRANCH:
    begin
    branch_stall_was= 1'b1;
    if(pmem_cmdok)
      begin
      instr_next= 1'b0;
      pl_branch_excpt= 1'b0;
      end

    if(exception | ((pl_stall_eret | pl_stall_branch) & !pl_stall_mem))
      begin
      pl_instr_fstage= 32'd0;
      pl_cause_bd= 1'b1;
      pl_branch_excpt= 1'b1;
      cpu_state= STALL_BRANCH;
      end
    else if(pl_stall_mem | pl_stall_multdiv)
      begin
      pl_pcpause= 1'b1;
      pl_instr_fstage= pl_instr_fstage_d;
      cpu_state= pl_stall_mem ? STALL_MEM : STALL_MULTDIV;
      end
    else
      begin
      pl_instr_fstage= (instr_next_d | pmem_branch_ended) &
                       pmem_cmdok  & !pl_branch_excpt_d ? pmem_cmd : 32'd0;
      cpu_state= pmem_branch_ended & !pl_branch_excpt_d ? NORMAL : STALL_BRANCH;
      end
    end
  STALL_MEM:
    begin
    if(exception | ((pl_stall_eret | pl_stall_branch) & !pl_stall_mem))
      begin
      pl_pcpause= 1'b0;
      if(branch_stall_was_d) pl_cause_bd= 1'b1;
      instr_next= !pmem_cmdok & !(pl_stall_eret | exception);
                  //DELAY SLOT HOW NOP
      pl_instr_fstage= pl_stall_eret | exception | !pmem_cmdok ? 32'd0 :
                       pmem_cmd;
      cpu_state= STALL_BRANCH;
      end
    else if(pl_stall_mem | pl_stall_multdiv)
      begin
      pl_pcpause= 1'b1;
      pl_instr_fstage= pl_instr_fstage_d;
      cpu_state= pl_stall_mem ? STALL_MEM : STALL_MULTDIV;
      end
    else
      begin
      pl_pcpause= 1'b0;
      pl_instr_fstage= pmem_cmdok ? pmem_cmd : 32'd0;
      end
    end
  STALL_MULTDIV:
    begin
    if(exception)
      begin
      if(branch_stall_was_d) pl_cause_bd= 1'b1;
      instr_next= !pmem_cmdok & !(pl_stall_eret | exception);
                  //DELAY SLOT HOW NOP
      pl_instr_fstage= pl_stall_eret | exception | !pmem_cmdok ? 32'd0 :
                       pmem_cmd;
      cpu_state= STALL_BRANCH;
      end
    else
      begin
      if(!alu_multdiv_ready)
        begin
        pl_pcpause= 1'b1;
        pl_instr_fstage= pl_instr_fstage_d;
        cpu_state= STALL_MULTDIV;
        end
      else
        begin
        pl_pcpause= 1'b0;
        pl_instr_fstage= pmem_cmdok ? pmem_cmd : 32'd0;
        end
      end
    end
  endcase
  end

  always @(posedge clk)
  begin
  if(rst)
    begin
    instr_next_d<= 1'b0;
    pl_pcpause_d<= 1'b0;
    pl_branch_excpt_d<= 1'b0;
    branch_stall_was_d<= 1'b0;
    pl_instr_fstage_d<= 32'd0;
    cpu_state_d<= NORMAL;
    end
  else
    begin
    instr_next_d<= instr_next;
    pl_pcpause_d<= pl_pcpause;
    pl_branch_excpt_d<= pl_branch_excpt;
    branch_stall_was_d<= branch_stall_was;
    pl_instr_fstage_d<= pl_instr_fstage;
    cpu_state_d<= cpu_state;
    end
  end




endmodule",196,646
19,6,0,False,False,"module wb_drp #
(
    parameter ADDR_WIDTH = 16
)
(
    input  wire                    clk,
    input  wire                    rst,

    /*
     * Wishbone interface
     */
    input  wire [ADDR_WIDTH-1:0]   wb_adr_i,   // ADR_I() address
    input  wire [15:0]             wb_dat_i,   // DAT_I() data in
    output wire [15:0]             wb_dat_o,   // DAT_O() data out
    input  wire                    wb_we_i,    // WE_I write enable input
    input  wire                    wb_stb_i,   // STB_I strobe input
    output wire                    wb_ack_o,   // ACK_O acknowledge output
    input  wire                    wb_cyc_i,   // CYC_I cycle input

    /*
     * DRP interface
     */
    output wire [ADDR_WIDTH-1:0]   drp_addr,
    output wire [15:0]             drp_do,
    input  wire [15:0]             drp_di,
    output wire                    drp_en,
    output wire                    drp_we,
    input  wire                    drp_rdy
);

reg cycle = 1'b0;

assign drp_addr = wb_adr_i;
assign drp_do = wb_dat_i;
assign wb_dat_o = drp_di;
assign drp_en = wb_cyc_i & wb_stb_i & ~cycle;
assign drp_we = wb_cyc_i & wb_stb_i & wb_we_i & ~cycle;
assign wb_ack_o = drp_rdy;

always @(posedge clk) begin
    cycle <= wb_cyc_i & wb_stb_i & ~drp_rdy;

    if (rst) begin
        cycle <= 1'b0;
    end
end

endmodule",48,648
8,1,0,False,False,"module sky130_fd_sc_hvl__nor2 (
    Y,
    A,
    B
);

    // Module ports
    output Y;
    input  A;
    input  B;

    // Module supplies
    supply1 VPWR;
    supply0 VGND;
    supply1 VPB ;
    supply0 VNB ;

    // Local signals
    wire nor0_out_Y;

    //  Name  Output      Other arguments
    nor nor0 (nor0_out_Y, A, B           );
    buf buf0 (Y         , nor0_out_Y     );

endmodule",25,651
539,592,0,False,False,"module pfpu_f2i(
	input sys_clk,
	input alu_rst,
	
	input [31:0] a,
	input valid_i,
	
	output reg [31:0] r,
	output reg valid_o
);

wire		a_sign = a[31];
wire [7:0]	a_expn = a[30:23];
wire [23:0]	a_mant = {1'b1, a[22:0]};

reg [30:0] shifted;
always @(*) begin
	if(a_expn >= 8'd150)
		shifted = a_mant << (a_expn - 8'd150);
	else
		shifted = a_mant >> (8'd150 - a_expn);
end

always @(posedge sys_clk) begin
	if(alu_rst)
		valid_o <= 1'b0;
	else
		valid_o <= valid_i;
	if(a_sign)
		r <= 32'd0 - {1'b0, shifted};
	else
		r <= {1'b0, shifted};
end

endmodule",35,664
15,6,0,True,False,"module usdrx1_spi (

  spi_afe_csn,
  spi_clk_csn,
  spi_clk,
  spi_mosi,
  spi_miso,

  spi_afe_sdio,
  spi_clk_sdio);

  // 4 wire

  input   [ 3:0]  spi_afe_csn;
  input           spi_clk_csn;
  input           spi_clk;
  input           spi_mosi;
  output          spi_miso;

  // 3 wire

  inout           spi_afe_sdio;
  inout           spi_clk_sdio;

  // internal registers

  reg     [ 5:0]  spi_count = 'd0;
  reg             spi_rd_wr_n = 'd0;
  reg             spi_enable = 'd0;

  // internal signals

  wire    [ 1:0]  spi_csn_3_s;
  wire            spi_csn_s;
  wire            spi_enable_s;
  wire            spi_afe_miso_s;
  wire            spi_clk_miso_s;

  // check on rising edge and change on falling edge

  assign spi_csn_3_s[1] = & spi_afe_csn;
  assign spi_csn_3_s[0] = spi_clk_csn;
  assign spi_csn_s = & spi_csn_3_s;
  assign spi_enable_s = spi_enable & ~spi_csn_s;

  always @(posedge spi_clk or posedge spi_csn_s) begin
    if (spi_csn_s == 1'b1) begin
      spi_count <= 6'd0;
      spi_rd_wr_n <= 1'd0;
    end else begin
      spi_count <= spi_count + 1'b1;
      if (spi_count == 6'd0) begin
        spi_rd_wr_n <= spi_mosi;
      end
    end
  end

  always @(negedge spi_clk or posedge spi_csn_s) begin
    if (spi_csn_s == 1'b1) begin
      spi_enable <= 1'b0;
    end else begin
      if (((spi_count == 6'd16)  && (spi_csn_3_s[1] == 1'b0)) ||
          ((spi_count == 6'd16) && (spi_csn_3_s[0] == 1'b0))) begin
        spi_enable <= spi_rd_wr_n;
      end
    end
  end

  assign spi_miso =  ((spi_afe_miso_s  & ~spi_csn_3_s[1]) |
                      (spi_clk_miso_s  & ~spi_csn_3_s[0]));

  // io buffers

  assign spi_afe_miso_s = spi_afe_sdio;
  assign spi_afe_sdio = (spi_enable_s == 1'b1) ? 1'bz : spi_mosi;

  assign spi_clk_miso_s = spi_clk_sdio;
  assign spi_clk_sdio = (spi_enable_s == 1'b1) ? 1'bz : spi_mosi;

endmodule",80,669
55,64,0,False,False,"module spi_slave(
    input clk,
    input rst,
    input ss,
    input mosi,
    output miso,
    input sck,
    output done,
    input [7:0] din,
    input din_update,
    output [7:0] dout
    );

reg mosi_d, mosi_q;
reg ss_d, ss_q;
reg sck_d, sck_q;
reg sck_old_d, sck_old_q;
reg [7:0] data_d, data_q;
reg done_d, done_q;
reg [2:0] bit_ct_d, bit_ct_q;
reg [7:0] dout_d, dout_q;
reg miso_d, miso_q;

assign miso = miso_q;
assign done = done_q;
assign dout = dout_q;

always @(*) begin
    ss_d = ss;
    mosi_d = mosi;
    miso_d = miso_q;
    sck_d = sck;
    sck_old_d = sck_q;
    data_d = data_q;
    done_d = 1'b0;
    bit_ct_d = bit_ct_q;
    dout_d = dout_q;

    if (ss_q) begin
        bit_ct_d = 3'b0;
        data_d = din;
        miso_d = data_q[7];
    end else begin
        if (!sck_old_q && sck_q) begin // rising edge
            miso_d = data_q[7];
            data_d = {data_q[6:0], mosi_q};
            bit_ct_d = bit_ct_q + 1'b1;
            if (bit_ct_q == 3'b111) begin
                dout_d = {data_q[6:0], mosi_q};
                done_d = 1'b1;
                data_d = din;
            end
	end else if (din_update) begin
            data_d = din;
        end
    end
end

always @(posedge clk) begin
    if (rst) begin
        done_q <= 1'b0;
        bit_ct_q <= 3'b0;
        dout_q <= 8'b0;
        miso_q <= 1'b1;
    end else begin
        done_q <= done_d;
        bit_ct_q <= bit_ct_d;
        dout_q <= dout_d;
        miso_q <= miso_d;
    end

    sck_q <= sck_d;
    mosi_q <= mosi_d;
    ss_q <= ss_d;
    data_q <= data_d;
    sck_old_q <= sck_old_d;

end


endmodule",81,672
92,146,0,False,False,"module spi_slave(
clk,sck,mosi,miso,ssel,rst_n,recived_status
);

input clk;
input rst_n;
input sck,mosi,ssel;
output miso;
output recived_status;

reg recived_status;
reg[2:0] sckr;
reg[2:0] sselr;
reg[1:0] mosir;
reg[2:0] bitcnt;
reg[7:0] bytecnt;
reg byte_received;  // high when a byte has been received
reg [7:0] byte_data_received;
reg[7:0] received_memory;
reg [7:0] byte_data_sent;
reg [7:0] cnt;

wire ssel_active;
wire sck_risingedge;
wire sck_fallingedge;
wire ssel_startmessage;
wire ssel_endmessage;
wire mosi_data;
/*******************************************************************************
*detect the rising edge and falling edge of sck
*******************************************************************************/
always @(posedge clk or negedge rst_n)begin
	if(!rst_n)
		sckr <= 3'h0;
	else
		sckr <= {sckr[1:0],sck};
end

assign sck_risingedge = (sckr[2:1] == 2'b01) ? 1'b1 : 1'b0;
assign sck_fallingedge = (sckr[2:1] == 2'b10) ? 1'b1 : 1'b0;

/*******************************************************************************
*detect starts at falling edge and stops at rising edge of ssel
*******************************************************************************/
always @(posedge clk or negedge rst_n)begin
	if(!rst_n)
		sselr <= 3'h0;
	else
		sselr <= {sselr[1:0],ssel};
end

assign  ssel_active = (~sselr[1]) ? 1'b1 : 1'b0;  // SSEL is active low
assign  ssel_startmessage = (sselr[2:1]==2'b10) ? 1'b1 : 1'b0;  // message starts at falling edge
assign  ssel_endmessage = (sselr[2:1]==2'b01) ? 1'b1 : 1'b0;  // message stops at rising edge

/*******************************************************************************
*read from mosi
*******************************************************************************/
always @(posedge clk or negedge rst_n)begin
	if(!rst_n)
		mosir <= 2'h0;
	else
		mosir <={mosir[0],mosi};
end

assign mosi_data = mosir[1];

/*******************************************************************************
*SPI slave reveive in 8-bits format
*******************************************************************************/
always @(posedge clk or negedge rst_n)begin
  if(!rst_n)begin
	bitcnt <= 3'b000;
	byte_data_received <= 8'h0;
  end
  else begin
   if(~ssel_active)
     bitcnt <= 3'b000;
   else begin
      if(sck_risingedge)begin
        bitcnt <= bitcnt + 3'b001;
        byte_data_received <= {byte_data_received[6:0], mosi_data};
      end
		else begin
		  bitcnt <= bitcnt;
        byte_data_received <= byte_data_received;
		end
	  end
  end
end

always @(posedge clk or negedge rst_n) begin
	if(!rst_n)
		byte_received <= 1'b0;
	else
		byte_received <= ssel_active && sck_risingedge && (bitcnt==3'b111);
end

always @(posedge clk or negedge rst_n) begin
	if(!rst_n)begin
		bytecnt <= 8'h0;
		received_memory <= 8'h0;
	end
   else begin 
	 if(byte_received) begin
		  bytecnt <= bytecnt + 1'b1;
	     received_memory <= (byte_data_received == bytecnt) ? (received_memory + 1'b1) : received_memory;
	 end
	 else begin
		  bytecnt <= bytecnt;
	     received_memory <= received_memory;
	 end
	end
end

/*******************************************************************************
*SPI  slave send date 
*******************************************************************************/
always @(posedge clk or negedge rst_n) begin
	 if(!rst_n)
	  cnt<= 8'h0;
	 else begin
     if(byte_received) 
			cnt<=cnt+8'h1;  // count the messages
		else
			cnt<=cnt;
    end
end

always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
		byte_data_sent <= 8'h0;
	 else begin
      if(ssel_active && sck_fallingedge) begin
          if(bitcnt==3'b001)
               byte_data_sent <= cnt;  // after that, we send 0s
           else
               byte_data_sent <= {byte_data_sent[6:0], 1'b0};
		end
		else
			byte_data_sent <= byte_data_sent;
	end
end

assign miso = byte_data_sent[7];  // send MSB first

always @(posedge clk or negedge rst_n) begin
	 if(!rst_n)
	  recived_status <= 1'b0;
	 else 
	  recived_status <= (received_memory == 8'd64) ? 1'b1 : 1'b0;
end

endmodule",154,681
8655,10312,0,False,False,"module ecc_merge_enc
  #(
    parameter TCQ = 100,
    parameter PAYLOAD_WIDTH         = 64,
    parameter CODE_WIDTH            = 72,
    parameter DATA_BUF_ADDR_WIDTH   = 4,
    parameter DATA_BUF_OFFSET_WIDTH = 1,
    parameter DATA_WIDTH            = 64,
    parameter DQ_WIDTH              = 72,
    parameter ECC_WIDTH             = 8,
    parameter nCK_PER_CLK           = 4
   )
   (
    /*AUTOARG*/
  // Outputs
  mc_wrdata, mc_wrdata_mask,
  // Inputs
  clk, rst, wr_data, wr_data_mask, rd_merge_data, h_rows, raw_not_ecc
  );

  input clk;
  input rst;

  input [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] wr_data;
  input [2*nCK_PER_CLK*DATA_WIDTH/8-1:0] wr_data_mask;
  input [2*nCK_PER_CLK*DATA_WIDTH-1:0] rd_merge_data;
  
  reg [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] wr_data_r;
  reg [2*nCK_PER_CLK*DATA_WIDTH/8-1:0] wr_data_mask_r;
  reg [2*nCK_PER_CLK*DATA_WIDTH-1:0] rd_merge_data_r;

  always @(posedge clk) wr_data_r <= #TCQ wr_data;
  always @(posedge clk) wr_data_mask_r <= #TCQ wr_data_mask;
  always @(posedge clk) rd_merge_data_r <= #TCQ rd_merge_data;
  
  // Merge new data with memory read data.
  wire [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] merged_data;
  genvar h;
  genvar i;
  generate
    for (h=0; h<2*nCK_PER_CLK; h=h+1) begin : merge_data_outer
      for (i=0; i<DATA_WIDTH/8; i=i+1) begin : merge_data_inner
        assign merged_data[h*PAYLOAD_WIDTH+i*8+:8] =  
                wr_data_mask_r[h*DATA_WIDTH/8+i]
                  ? rd_merge_data_r[h*DATA_WIDTH+i*8+:8]               
                  : wr_data_r[h*PAYLOAD_WIDTH+i*8+:8];
      end
      if (PAYLOAD_WIDTH > DATA_WIDTH)
        assign merged_data[(h+1)*PAYLOAD_WIDTH-1-:PAYLOAD_WIDTH-DATA_WIDTH]=
                      wr_data_r[(h+1)*PAYLOAD_WIDTH-1-:PAYLOAD_WIDTH-DATA_WIDTH];
                                                                   
    end
  endgenerate

  // Generate ECC and overlay onto mc_wrdata.
  input [CODE_WIDTH*ECC_WIDTH-1:0] h_rows;
  input [2*nCK_PER_CLK-1:0] raw_not_ecc;
  reg [2*nCK_PER_CLK-1:0] raw_not_ecc_r;
  always @(posedge clk) raw_not_ecc_r <= #TCQ raw_not_ecc;
  output reg [2*nCK_PER_CLK*DQ_WIDTH-1:0] mc_wrdata;
  genvar j;
  integer k;
  generate
    for (j=0; j<2*nCK_PER_CLK; j=j+1) begin : ecc_word
      always @(/*AS*/h_rows or merged_data or raw_not_ecc_r) begin
        mc_wrdata[j*DQ_WIDTH+:DQ_WIDTH] =
          {{DQ_WIDTH-PAYLOAD_WIDTH{1'b0}},
           merged_data[j*PAYLOAD_WIDTH+:PAYLOAD_WIDTH]};
        for (k=0; k<ECC_WIDTH; k=k+1)
          if (~raw_not_ecc_r[j])
            mc_wrdata[j*DQ_WIDTH+CODE_WIDTH-k-1] =
              ^(merged_data[j*PAYLOAD_WIDTH+:DATA_WIDTH] & 
                h_rows[k*CODE_WIDTH+:DATA_WIDTH]);
      end
    end
  endgenerate

  // Set all DRAM masks to zero.
  output wire[2*nCK_PER_CLK*DQ_WIDTH/8-1:0] mc_wrdata_mask;
  assign mc_wrdata_mask = {2*nCK_PER_CLK*DQ_WIDTH/8{1'b0}};

endmodule",82,682
49,98,0,True,False,"module  int16_float32_altbarrel_shift_gof
	( 
	aclr,
	clk_en,
	clock,
	data,
	distance,
	result) ;
	input   aclr;
	input   clk_en;
	input   clock;
	input   [15:0]  data;
	input   [3:0]  distance;
	output   [15:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clk_en;
	tri0   clock;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[1:0]	dir_pipe;
	reg	[15:0]	sbit_piper1d;
	reg	[15:0]	sbit_piper2d;
	reg	sel_pipec2r1d;
	reg	sel_pipec3r1d;
	wire  [4:0]  dir_w;
	wire  direction_w;
	wire  [7:0]  pad_w;
	wire  [79:0]  sbit_w;
	wire  [3:0]  sel_w;
	wire  [63:0]  smux_w;

	// synopsys translate_off
	initial
		dir_pipe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) dir_pipe <= 2'b0;
		else if  (clk_en == 1'b1)   dir_pipe <= {dir_w[3], dir_w[1]};
	// synopsys translate_off
	initial
		sbit_piper1d = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) sbit_piper1d <= 16'b0;
		else if  (clk_en == 1'b1)   sbit_piper1d <= smux_w[31:16];
	// synopsys translate_off
	initial
		sbit_piper2d = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) sbit_piper2d <= 16'b0;
		else if  (clk_en == 1'b1)   sbit_piper2d <= smux_w[63:48];
	// synopsys translate_off
	initial
		sel_pipec2r1d = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) sel_pipec2r1d <= 1'b0;
		else if  (clk_en == 1'b1)   sel_pipec2r1d <= distance[2];
	// synopsys translate_off
	initial
		sel_pipec3r1d = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) sel_pipec3r1d <= 1'b0;
		else if  (clk_en == 1'b1)   sel_pipec3r1d <= distance[3];
	assign
		dir_w = {dir_pipe[1], dir_w[2], dir_pipe[0], dir_w[0], direction_w},
		direction_w = 1'b0,
		pad_w = {8{1'b0}},
		result = sbit_w[79:64],
		sbit_w = {sbit_piper2d, smux_w[47:32], sbit_piper1d, smux_w[15:0], data},
		sel_w = {sel_pipec3r1d, sel_pipec2r1d, distance[1:0]},
		smux_w = {((({16{(sel_w[3] & (~ dir_w[3]))}} & {sbit_w[55:48], pad_w[7:0]}) | ({16{(sel_w[3] & dir_w[3])}} & {pad_w[7:0], sbit_w[63:56]})) | ({16{(~ sel_w[3])}} & sbit_w[63:48])), ((({16{(sel_w[2] & (~ dir_w[2]))}} & {sbit_w[43:32], pad_w[3:0]}) | ({16{(sel_w[2] & dir_w[2])}} & {pad_w[3:0], sbit_w[47:36]})) | ({16{(~ sel_w[2])}} & sbit_w[47:32])), ((({16{(sel_w[1] & (~ dir_w[1]))}} & {sbit_w[29:16], pad_w[1:0]}) | ({16{(sel_w[1] & dir_w[1])}} & {pad_w[1:0], sbit_w[31:18]})) | ({16{(~ sel_w[1])}} & sbit_w[31:16])), ((({16{(sel_w[0] & (~ dir_w[0]))}} & {sbit_w[14:0], pad_w[0]}) | ({16{(sel_w[0] & dir_w[0])}} & {pad_w[0], sbit_w[15:1]})) | ({16{(~ sel_w[0])}} & sbit_w[15:0]))};
endmodule",80,690
3,1,0,False,False,"module  int16_float32_altpriority_encoder_3e8
	( 
	data,
	q,
	zero) ;
	input   [1:0]  data;
	output   [0:0]  q;
	output   zero;


	assign
		q = {data[1]},
		zero = (~ (data[0] | data[1]));
endmodule",14,692
2042,3090,0,False,False,"module picosoc_regs (
	input clk, wen,
	input [5:0] waddr,
	input [5:0] raddr1,
	input [5:0] raddr2,
	input [31:0] wdata,
	output [31:0] rdata1,
	output [31:0] rdata2
);
	reg [31:0] regs [0:31];

	always @(posedge clk)
		if (wen) regs[waddr[4:0]] <= wdata;

	assign rdata1 = regs[raddr1[4:0]];
	assign rdata2 = regs[raddr2[4:0]];
endmodule",17,716
18,9,0,False,False,"module sky130_fd_sc_ms__fa (
    COUT,
    SUM ,
    A   ,
    B   ,
    CIN
);

    // Module ports
    output COUT;
    output SUM ;
    input  A   ;
    input  B   ;
    input  CIN ;

    // Module supplies
    supply1 VPWR;
    supply0 VGND;
    supply1 VPB ;
    supply0 VNB ;

    // Local signals
    wire or0_out     ;
    wire and0_out    ;
    wire and1_out    ;
    wire and2_out    ;
    wire nor0_out    ;
    wire nor1_out    ;
    wire or1_out_COUT;
    wire or2_out_SUM ;

    //  Name  Output        Other arguments
    or  or0  (or0_out     , CIN, B            );
    and and0 (and0_out    , or0_out, A        );
    and and1 (and1_out    , B, CIN            );
    or  or1  (or1_out_COUT, and1_out, and0_out);
    buf buf0 (COUT        , or1_out_COUT      );
    and and2 (and2_out    , CIN, A, B         );
    nor nor0 (nor0_out    , A, or0_out        );
    nor nor1 (nor1_out    , nor0_out, COUT    );
    or  or2  (or2_out_SUM , nor1_out, and2_out);
    buf buf1 (SUM         , or2_out_SUM       );

endmodule",44,720
101,220,0,False,False,"module XORSHIFT #(parameter               WIDTH = 32,
                  parameter               SEED  = 1)
                 (input  wire             CLK,
                  input  wire             RST,
                  input  wire             EN,
                  output wire [WIDTH-1:0] RAND_VAL);

  reg  [WIDTH-1:0] x;
  reg  [WIDTH-1:0] y;
  reg  [WIDTH-1:0] z;
  reg  [WIDTH-1:0] w;
  wire [WIDTH-1:0] t = x^(x<<11);
  
  // Mask MSB for not generating the maximum value
  assign RAND_VAL = {1'b0, w[WIDTH-2:0]};
  
  reg ocen;
  always @(posedge CLK) ocen <= RST;

  always @(posedge CLK) begin
    if (RST) begin
      x <= 123456789;
      y <= 362436069;
      z <= 521288629;
      w <= 88675123 ^ SEED;
    end else begin
      if (EN || ocen) begin
        x <= y;
        y <= z;
        z <= w;
        w <= (w^(w>>19))^(t^(t>>8));
      end
    end
  end
endmodule",35,721
391,377,0,False,False,"module sirv_qspi_physical_2(
  input   clock,
  input   reset,
  output  io_port_sck,
  input   io_port_dq_0_i,
  output  io_port_dq_0_o,
  output  io_port_dq_0_oe,
  input   io_port_dq_1_i,
  output  io_port_dq_1_o,
  output  io_port_dq_1_oe,
  input   io_port_dq_2_i,
  output  io_port_dq_2_o,
  output  io_port_dq_2_oe,
  input   io_port_dq_3_i,
  output  io_port_dq_3_o,
  output  io_port_dq_3_oe,
  output  io_port_cs_0,
  input  [11:0] io_ctrl_sck_div,
  input   io_ctrl_sck_pol,
  input   io_ctrl_sck_pha,
  input  [1:0] io_ctrl_fmt_proto,
  input   io_ctrl_fmt_endian,
  input   io_ctrl_fmt_iodir,
  output  io_op_ready,
  input   io_op_valid,
  input   io_op_bits_fn,
  input   io_op_bits_stb,
  input  [7:0] io_op_bits_cnt,
  input  [7:0] io_op_bits_data,
  output  io_rx_valid,
  output [7:0] io_rx_bits
);
  reg [11:0] ctrl_sck_div;
  reg [31:0] GEN_2;
  reg  ctrl_sck_pol;
  reg [31:0] GEN_31;
  reg  ctrl_sck_pha;
  reg [31:0] GEN_52;
  reg [1:0] ctrl_fmt_proto;
  reg [31:0] GEN_67;
  reg  ctrl_fmt_endian;
  reg [31:0] GEN_68;
  reg  ctrl_fmt_iodir;
  reg [31:0] GEN_69;
  wire  proto_0;
  wire  proto_1;
  wire  proto_2;
  wire  accept;
  wire  sample;
  wire  setup;
  wire  last;
  reg  setup_d;
  reg [31:0] GEN_70;
  reg  T_119;
  reg [31:0] GEN_71;
  reg  T_120;
  reg [31:0] GEN_72;
  reg  sample_d;
  reg [31:0] GEN_73;
  reg  T_122;
  reg [31:0] GEN_74;
  reg  T_123;
  reg [31:0] GEN_75;
  reg  last_d;
  reg [31:0] GEN_76;
  reg [7:0] scnt;
  reg [31:0] GEN_77;
  reg [11:0] tcnt;
  reg [31:0] GEN_78;
  wire  stop;
  wire  beat;
  wire [11:0] T_127;
  wire [12:0] T_129;
  wire [11:0] decr;
  wire  sched;
  wire [11:0] T_130;
  reg  sck;
  reg [31:0] GEN_79;
  reg  cref;
  reg [31:0] GEN_80;
  wire  cinv;
  wire [1:0] T_133;
  wire [1:0] T_134;
  wire [3:0] rxd;
  wire  samples_0;
  wire [1:0] samples_1;
  reg [7:0] buffer;
  reg [31:0] GEN_81;
  wire  T_135;
  wire  T_136;
  wire  T_137;
  wire  T_138;
  wire  T_139;
  wire  T_140;
  wire  T_141;
  wire  T_142;
  wire  T_143;
  wire [1:0] T_144;
  wire [1:0] T_145;
  wire [3:0] T_146;
  wire [1:0] T_147;
  wire [1:0] T_148;
  wire [3:0] T_149;
  wire [7:0] T_150;
  wire [7:0] buffer_in;
  wire  T_151;
  wire  shift;
  wire [6:0] T_152;
  wire [6:0] T_153;
  wire [6:0] T_154;
  wire  T_155;
  wire  T_157;
  wire [7:0] T_158;
  wire [5:0] T_159;
  wire [5:0] T_160;
  wire [5:0] T_161;
  wire [1:0] T_162;
  wire [1:0] T_163;
  wire [7:0] T_164;
  wire [3:0] T_165;
  wire [3:0] T_166;
  wire [3:0] T_167;
  wire [3:0] T_169;
  wire [7:0] T_170;
  wire [7:0] T_172;
  wire [7:0] T_174;
  wire [7:0] T_176;
  wire [7:0] T_178;
  wire [7:0] T_179;
  wire [7:0] T_180;
  reg [3:0] txd;
  reg [31:0] GEN_82;
  wire [3:0] T_182;
  wire [3:0] txd_in;
  wire [1:0] T_184;
  wire  txd_sel_0;
  wire  txd_sel_1;
  wire  txd_sel_2;
  wire  txd_shf_0;
  wire [1:0] txd_shf_1;
  wire  T_186;
  wire [1:0] T_188;
  wire [3:0] T_190;
  wire [1:0] GEN_65;
  wire [1:0] T_192;
  wire [3:0] GEN_66;
  wire [3:0] T_193;
  wire [3:0] T_194;
  wire [3:0] GEN_0;
  wire  T_195;
  wire  T_196;
  wire  txen_1;
  wire  txen_0;
  wire  T_202_0;
  wire  T_206;
  wire  T_207;
  wire  T_208;
  wire  T_209;
  reg  done;
  reg [31:0] GEN_83;
  wire  T_212;
  wire  T_213;
  wire  T_215;
  wire  T_216;
  wire  T_217;
  wire  T_218;
  wire  T_219;
  wire  T_220;
  wire  T_221;
  wire [1:0] T_222;
  wire [1:0] T_223;
  wire [3:0] T_224;
  wire [1:0] T_225;
  wire [1:0] T_226;
  wire [3:0] T_227;
  wire [7:0] T_228;
  wire [7:0] T_229;
  reg  xfr;
  reg [31:0] GEN_84;
  wire  GEN_1;
  wire  T_234;
  wire  T_236;
  wire  T_237;
  wire  GEN_3;
  wire  GEN_4;
  wire  GEN_5;
  wire [11:0] GEN_6;
  wire  GEN_7;
  wire  GEN_8;
  wire  GEN_9;
  wire  GEN_10;
  wire [11:0] GEN_11;
  wire  GEN_12;
  wire  GEN_13;
  wire  GEN_14;
  wire  GEN_15;
  wire [11:0] GEN_16;
  wire  T_243;
  wire  T_244;
  wire  T_245;
  wire  T_248;
  wire  GEN_17;
  wire  GEN_18;
  wire  GEN_19;
  wire  GEN_20;
  wire  GEN_21;
  wire  GEN_22;
  wire  GEN_23;
  wire  T_251;
  wire [1:0] GEN_24;
  wire  GEN_25;
  wire  GEN_26;
  wire  T_254;
  wire  T_257;
  wire [7:0] GEN_27;
  wire  GEN_28;
  wire  GEN_29;
  wire  GEN_30;
  wire  GEN_32;
  wire [11:0] GEN_33;
  wire  GEN_34;
  wire  GEN_35;
  wire  GEN_36;
  wire [11:0] GEN_37;
  wire  GEN_38;
  wire  GEN_39;
  wire [11:0] GEN_40;
  wire [1:0] GEN_41;
  wire  GEN_42;
  wire  GEN_43;
  wire  GEN_44;
  wire [7:0] GEN_45;
  wire  GEN_46;
  wire  GEN_47;
  wire  GEN_48;
  wire [11:0] GEN_49;
  wire  GEN_50;
  wire  GEN_51;
  wire [11:0] GEN_53;
  wire [1:0] GEN_54;
  wire  GEN_55;
  wire  GEN_56;
  wire  GEN_57;
  wire [7:0] GEN_58;
  wire  GEN_59;
  wire  GEN_60;
  wire  GEN_61;
  wire [11:0] GEN_62;
  wire  GEN_63;
  wire  GEN_64;
  assign io_port_sck = sck;
  assign io_port_dq_0_o = T_206;
  assign io_port_dq_0_oe = txen_0;
  assign io_port_dq_1_o = T_207;
  assign io_port_dq_1_oe = txen_1;
  assign io_port_dq_2_o = T_208;
  assign io_port_dq_2_oe = T_196;
  assign io_port_dq_3_o = T_209;
  assign io_port_dq_3_oe = io_port_dq_2_oe;
  assign io_port_cs_0 = T_202_0;
  assign io_op_ready = T_251;
  assign io_rx_valid = done;
  assign io_rx_bits = T_229;
  assign proto_0 = 2'h0 == ctrl_fmt_proto;
  assign proto_1 = 2'h1 == ctrl_fmt_proto;
  assign proto_2 = 2'h2 == ctrl_fmt_proto;
  assign accept = GEN_21;
  assign sample = GEN_14;
  assign setup = GEN_60;
  assign last = GEN_20;
  assign stop = scnt == 8'h0;
  assign beat = tcnt == 12'h0;
  assign T_127 = beat ? {{4'd0}, scnt} : tcnt;
  assign T_129 = T_127 - 12'h1;
  assign decr = T_129[11:0];
  assign sched = GEN_1;
  assign T_130 = sched ? ctrl_sck_div : decr;
  assign cinv = ctrl_sck_pha ^ ctrl_sck_pol;
  assign T_133 = {io_port_dq_1_i,io_port_dq_0_i};
  assign T_134 = {io_port_dq_3_i,io_port_dq_2_i};
  assign rxd = {T_134,T_133};
  assign samples_0 = rxd[1];
  assign samples_1 = rxd[1:0];
  assign T_135 = io_ctrl_fmt_endian == 1'h0;
  assign T_136 = io_op_bits_data[0];
  assign T_137 = io_op_bits_data[1];
  assign T_138 = io_op_bits_data[2];
  assign T_139 = io_op_bits_data[3];
  assign T_140 = io_op_bits_data[4];
  assign T_141 = io_op_bits_data[5];
  assign T_142 = io_op_bits_data[6];
  assign T_143 = io_op_bits_data[7];
  assign T_144 = {T_142,T_143};
  assign T_145 = {T_140,T_141};
  assign T_146 = {T_145,T_144};
  assign T_147 = {T_138,T_139};
  assign T_148 = {T_136,T_137};
  assign T_149 = {T_148,T_147};
  assign T_150 = {T_149,T_146};
  assign buffer_in = T_135 ? io_op_bits_data : T_150;
  assign T_151 = sample_d & stop;
  assign shift = setup_d | T_151;
  assign T_152 = buffer[6:0];
  assign T_153 = buffer[7:1];
  assign T_154 = shift ? T_152 : T_153;
  assign T_155 = buffer[0];
  assign T_157 = sample_d ? samples_0 : T_155;
  assign T_158 = {T_154,T_157};
  assign T_159 = buffer[5:0];
  assign T_160 = buffer[7:2];
  assign T_161 = shift ? T_159 : T_160;
  assign T_162 = buffer[1:0];
  assign T_163 = sample_d ? samples_1 : T_162;
  assign T_164 = {T_161,T_163};
  assign T_165 = buffer[3:0];
  assign T_166 = buffer[7:4];
  assign T_167 = shift ? T_165 : T_166;
  assign T_169 = sample_d ? rxd : T_165;
  assign T_170 = {T_167,T_169};
  assign T_172 = proto_0 ? T_158 : 8'h0;
  assign T_174 = proto_1 ? T_164 : 8'h0;
  assign T_176 = proto_2 ? T_170 : 8'h0;
  assign T_178 = T_172 | T_174;
  assign T_179 = T_178 | T_176;
  assign T_180 = T_179;
  assign T_182 = buffer_in[7:4];
  assign txd_in = accept ? T_182 : T_166;
  assign T_184 = accept ? io_ctrl_fmt_proto : ctrl_fmt_proto;
  assign txd_sel_0 = 2'h0 == T_184;
  assign txd_sel_1 = 2'h1 == T_184;
  assign txd_sel_2 = 2'h2 == T_184;
  assign txd_shf_0 = txd_in[3];
  assign txd_shf_1 = txd_in[3:2];
  assign T_186 = txd_sel_0 ? txd_shf_0 : 1'h0;
  assign T_188 = txd_sel_1 ? txd_shf_1 : 2'h0;
  assign T_190 = txd_sel_2 ? txd_in : 4'h0;
  assign GEN_65 = {{1'd0}, T_186};
  assign T_192 = GEN_65 | T_188;
  assign GEN_66 = {{2'd0}, T_192};
  assign T_193 = GEN_66 | T_190;
  assign T_194 = T_193;
  assign GEN_0 = setup ? T_194 : txd;
  assign T_195 = proto_1 & ctrl_fmt_iodir;
  assign T_196 = proto_2 & ctrl_fmt_iodir;
  assign txen_1 = T_195 | T_196;
  assign txen_0 = proto_0 | txen_1;
  assign T_202_0 = 1'h1;
  assign T_206 = txd[0];
  assign T_207 = txd[1];
  assign T_208 = txd[2];
  assign T_209 = txd[3];
  assign T_212 = done | last_d;
  assign T_213 = ctrl_fmt_endian == 1'h0;
  assign T_215 = buffer[1];
  assign T_216 = buffer[2];
  assign T_217 = buffer[3];
  assign T_218 = buffer[4];
  assign T_219 = buffer[5];
  assign T_220 = buffer[6];
  assign T_221 = buffer[7];
  assign T_222 = {T_220,T_221};
  assign T_223 = {T_218,T_219};
  assign T_224 = {T_223,T_222};
  assign T_225 = {T_216,T_217};
  assign T_226 = {T_155,T_215};
  assign T_227 = {T_226,T_225};
  assign T_228 = {T_227,T_224};
  assign T_229 = T_213 ? buffer : T_228;
  assign GEN_1 = stop ? 1'h1 : beat;
  assign T_234 = stop == 1'h0;
  assign T_236 = cref == 1'h0;
  assign T_237 = cref ^ cinv;
  assign GEN_3 = xfr ? T_237 : sck;
  assign GEN_4 = xfr ? cref : 1'h0;
  assign GEN_5 = xfr ? T_236 : 1'h0;
  assign GEN_6 = T_236 ? decr : {{4'd0}, scnt};
  assign GEN_7 = beat ? T_236 : cref;
  assign GEN_8 = beat ? GEN_3 : sck;
  assign GEN_9 = beat ? GEN_4 : 1'h0;
  assign GEN_10 = beat ? GEN_5 : 1'h0;
  assign GEN_11 = beat ? GEN_6 : {{4'd0}, scnt};
  assign GEN_12 = T_234 ? GEN_7 : cref;
  assign GEN_13 = T_234 ? GEN_8 : sck;
  assign GEN_14 = T_234 ? GEN_9 : 1'h0;
  assign GEN_15 = T_234 ? GEN_10 : 1'h0;
  assign GEN_16 = T_234 ? GEN_11 : {{4'd0}, scnt};
  assign T_243 = scnt == 8'h1;
  assign T_244 = beat & cref;
  assign T_245 = T_244 & xfr;
  assign T_248 = beat & T_236;
  assign GEN_17 = T_248 ? 1'h1 : stop;
  assign GEN_18 = T_248 ? 1'h0 : GEN_15;
  assign GEN_19 = T_248 ? ctrl_sck_pol : GEN_13;
  assign GEN_20 = T_243 ? T_245 : 1'h0;
  assign GEN_21 = T_243 ? GEN_17 : stop;
  assign GEN_22 = T_243 ? GEN_18 : GEN_15;
  assign GEN_23 = T_243 ? GEN_19 : GEN_13;
  assign T_251 = accept & done;
  assign GEN_24 = io_op_bits_stb ? io_ctrl_fmt_proto : ctrl_fmt_proto;
  assign GEN_25 = io_op_bits_stb ? io_ctrl_fmt_endian : ctrl_fmt_endian;
  assign GEN_26 = io_op_bits_stb ? io_ctrl_fmt_iodir : ctrl_fmt_iodir;
  assign T_254 = 1'h0 == io_op_bits_fn;
  assign T_257 = io_op_bits_cnt == 8'h0;
  assign GEN_27 = T_254 ? buffer_in : T_180;
  assign GEN_28 = T_254 ? cinv : GEN_23;
  assign GEN_29 = T_254 ? 1'h1 : GEN_22;
  assign GEN_30 = T_254 ? T_257 : T_212;
  assign GEN_32 = io_op_bits_stb ? io_ctrl_sck_pol : GEN_28;
  assign GEN_33 = io_op_bits_stb ? io_ctrl_sck_div : ctrl_sck_div;
  assign GEN_34 = io_op_bits_stb ? io_ctrl_sck_pol : ctrl_sck_pol;
  assign GEN_35 = io_op_bits_stb ? io_ctrl_sck_pha : ctrl_sck_pha;
  assign GEN_36 = io_op_bits_fn ? GEN_32 : GEN_28;
  assign GEN_37 = io_op_bits_fn ? GEN_33 : ctrl_sck_div;
  assign GEN_38 = io_op_bits_fn ? GEN_34 : ctrl_sck_pol;
  assign GEN_39 = io_op_bits_fn ? GEN_35 : ctrl_sck_pha;
  assign GEN_40 = io_op_valid ? {{4'd0}, io_op_bits_cnt} : GEN_16;
  assign GEN_41 = io_op_valid ? GEN_24 : ctrl_fmt_proto;
  assign GEN_42 = io_op_valid ? GEN_25 : ctrl_fmt_endian;
  assign GEN_43 = io_op_valid ? GEN_26 : ctrl_fmt_iodir;
  assign GEN_44 = io_op_valid ? T_254 : xfr;
  assign GEN_45 = io_op_valid ? GEN_27 : T_180;
  assign GEN_46 = io_op_valid ? GEN_36 : GEN_23;
  assign GEN_47 = io_op_valid ? GEN_29 : GEN_22;
  assign GEN_48 = io_op_valid ? GEN_30 : T_212;
  assign GEN_49 = io_op_valid ? GEN_37 : ctrl_sck_div;
  assign GEN_50 = io_op_valid ? GEN_38 : ctrl_sck_pol;
  assign GEN_51 = io_op_valid ? GEN_39 : ctrl_sck_pha;
  assign GEN_53 = T_251 ? GEN_40 : GEN_16;
  assign GEN_54 = T_251 ? GEN_41 : ctrl_fmt_proto;
  assign GEN_55 = T_251 ? GEN_42 : ctrl_fmt_endian;
  assign GEN_56 = T_251 ? GEN_43 : ctrl_fmt_iodir;
  assign GEN_57 = T_251 ? GEN_44 : xfr;
  assign GEN_58 = T_251 ? GEN_45 : T_180;
  assign GEN_59 = T_251 ? GEN_46 : GEN_23;
  assign GEN_60 = T_251 ? GEN_47 : GEN_22;
  assign GEN_61 = T_251 ? GEN_48 : T_212;
  assign GEN_62 = T_251 ? GEN_49 : ctrl_sck_div;
  assign GEN_63 = T_251 ? GEN_50 : ctrl_sck_pol;
  assign GEN_64 = T_251 ? GEN_51 : ctrl_sck_pha;

  always @(posedge clock or posedge reset)
  if (reset) begin
    ctrl_sck_div <= 12'b0;
    ctrl_sck_pol <= 1'b0;
    ctrl_sck_pha <= 1'b0;
    ctrl_fmt_proto <= 2'b0;
    ctrl_fmt_endian <= 1'b0;
    ctrl_fmt_iodir <= 1'b0;
    setup_d <= 1'b0;
    tcnt <= 12'b0;
    sck <= 1'b0;
    buffer <= 8'b0;
    xfr <= 1'b0;
  end
  else begin
    if (T_251) begin
      if (io_op_valid) begin
        if (io_op_bits_fn) begin
          if (io_op_bits_stb) begin
            ctrl_sck_div <= io_ctrl_sck_div;
          end
        end
      end
    end
    if (T_251) begin
      if (io_op_valid) begin
        if (io_op_bits_fn) begin
          if (io_op_bits_stb) begin
            ctrl_sck_pol <= io_ctrl_sck_pol;
          end
        end
      end
    end
    if (T_251) begin
      if (io_op_valid) begin
        if (io_op_bits_fn) begin
          if (io_op_bits_stb) begin
            ctrl_sck_pha <= io_ctrl_sck_pha;
          end
        end
      end
    end
    if (T_251) begin
      if (io_op_valid) begin
        if (io_op_bits_stb) begin
          ctrl_fmt_proto <= io_ctrl_fmt_proto;
        end
      end
    end
    if (T_251) begin
      if (io_op_valid) begin
        if (io_op_bits_stb) begin
          ctrl_fmt_endian <= io_ctrl_fmt_endian;
        end
      end
    end
    if (T_251) begin
      if (io_op_valid) begin
        if (io_op_bits_stb) begin
          ctrl_fmt_iodir <= io_ctrl_fmt_iodir;
        end
      end
    end
    setup_d <= setup;




    if (sched) begin
      tcnt <= ctrl_sck_div;
    end else begin
      tcnt <= decr;
    end
    if (T_251) begin
      if (io_op_valid) begin
        if (io_op_bits_fn) begin
          if (io_op_bits_stb) begin
            sck <= io_ctrl_sck_pol;
          end else begin
            if (T_254) begin
              sck <= cinv;
            end else begin
              if (T_243) begin
                if (T_248) begin
                  sck <= ctrl_sck_pol;
                end else begin
                  if (T_234) begin
                    if (beat) begin
                      if (xfr) begin
                        sck <= T_237;
                      end
                    end
                  end
                end
              end else begin
                if (T_234) begin
                  if (beat) begin
                    if (xfr) begin
                      sck <= T_237;
                    end
                  end
                end
              end
            end
          end
        end else begin
          if (T_254) begin
            sck <= cinv;
          end else begin
            if (T_243) begin
              if (T_248) begin
                sck <= ctrl_sck_pol;
              end else begin
                if (T_234) begin
                  if (beat) begin
                    if (xfr) begin
                      sck <= T_237;
                    end
                  end
                end
              end
            end else begin
              if (T_234) begin
                if (beat) begin
                  if (xfr) begin
                    sck <= T_237;
                  end
                end
              end
            end
          end
        end
      end else begin
        if (T_243) begin
          if (T_248) begin
            sck <= ctrl_sck_pol;
          end else begin
            sck <= GEN_13;
          end
        end else begin
          sck <= GEN_13;
        end
      end
    end else begin
      if (T_243) begin
        if (T_248) begin
          sck <= ctrl_sck_pol;
        end else begin
          sck <= GEN_13;
        end
      end else begin
        sck <= GEN_13;
      end
    end



    if (T_251) begin
      if (io_op_valid) begin
        if (T_254) begin
          if (T_135) begin
            buffer <= io_op_bits_data;
          end else begin
            buffer <= T_150;
          end
        end else begin
          buffer <= T_180;
        end
      end else begin
        buffer <= T_180;
      end
    end else begin
      buffer <= T_180;
    end

    if (T_251) begin
      if (io_op_valid) begin
        xfr <= T_254;
      end
    end

  end


  always @(posedge clock or posedge reset)
    if (reset) begin
      cref <= 1'h1;
    end else begin
      if (T_234) begin
        if (beat) begin
          cref <= T_236;
        end
      end
    end


  always @(posedge clock or posedge reset)
    if (reset) begin
      txd <= 4'h0;
    end else begin
      if (setup) begin
        txd <= T_194;
      end
    end

  always @(posedge clock or posedge reset)
    if (reset) begin
      done <= 1'h1;
    end else begin
      if (T_251) begin
        if (io_op_valid) begin
          if (T_254) begin
            done <= T_257;
          end else begin
            done <= T_212;
          end
        end else begin
          done <= T_212;
        end
      end else begin
        done <= T_212;
      end
    end



  always @(posedge clock or posedge reset)
    if (reset) begin
      T_119 <= 1'h0;
    end else begin
      T_119 <= sample;
    end

  always @(posedge clock or posedge reset)
    if (reset) begin
      T_120 <= 1'h0;
    end else begin
      T_120 <= T_119;
    end

  always @(posedge clock or posedge reset)
    if (reset) begin
      sample_d <= 1'h0;
    end else begin
      sample_d <= T_120;
    end

  always @(posedge clock or posedge reset)
    if (reset) begin
      T_122 <= 1'h0;
    end else begin
      T_122 <= last;
    end

  always @(posedge clock or posedge reset)
    if (reset) begin
      T_123 <= 1'h0;
    end else begin
      T_123 <= T_122;
    end

  always @(posedge clock or posedge reset)
    if (reset) begin
      last_d <= 1'h0;
    end else begin
      last_d <= T_123;
    end

  always @(posedge clock or posedge reset)
    if (reset) begin
      scnt <= 8'h0;
    end else begin
      scnt <= GEN_53[7:0];
    end

endmodule",716,730
2,1,0,False,False,"module INV(input A, output Z);
	assign Z = !A;

	specify
		(A => Z) = 10;
	endspecify
endmodule",7,742
5,1,0,False,False,"module FD1P3BX(input D, CK, SP, PD, output reg Q);
	parameter GSR = ""DISABLED"";
	initial Q = 1'b1;
	always @(posedge CK or posedge PD)
		if (PD)
			Q <= 1'b1;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(PD, posedge CK, 224);
`ifndef YOSYS
		if (PD) (posedge CLK => (Q : 1)) = 0;
`else
		if (PD) (PD => Q) = 0; 	// Technically, this should be an edge sensitive path
								// but for facilitating a bypass box, let's pretend it's
								// a simple path
`endif
		if (!PD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule",22,749
5,1,0,False,False,"module FD1P3DX(input D, CK, SP, CD, output reg Q);
	parameter GSR = ""DISABLED"";
	initial Q = 1'b0;
	always @(posedge CK or posedge CD)
		if (CD)
			Q <= 1'b0;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(CD, posedge CK, 224);
`ifndef YOSYS
		if (CD) (posedge CLK => (Q : 0)) = 0;
`else
		if (CD) (CD => Q) = 0; 	// Technically, this should be an edge sensitive path
								// but for facilitating a bypass box, let's pretend it's
								// a simple path
`endif
		if (!CD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule",22,750
5,1,0,False,False,"module FD1P3IX(input D, CK, SP, CD, output reg Q);
	parameter GSR = ""DISABLED"";
	initial Q = 1'b0;
	always @(posedge CK)
		if (CD)
			Q <= 1'b0;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(CD, posedge CK, 224);
		if (!CD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule",15,751
5,1,0,False,False,"module FD1P3JX(input D, CK, SP, PD, output reg Q);
	parameter GSR = ""DISABLED"";
	initial Q = 1'b1;
	always @(posedge CK)
		if (PD)
			Q <= 1'b1;
		else if (SP)
			Q <= D;
	specify
		$setup(D, posedge CK, 0);
		$setup(SP, posedge CK, 212);
		$setup(PD, posedge CK, 224);
		if (!PD && SP) (posedge CK => (Q : D)) = 336;
	endspecify
endmodule",15,752
10,1,0,False,False,"module OXIDE_FF(input CLK, LSR, CE, DI, M, output reg Q);
	parameter GSR = ""ENABLED"";
	parameter [127:0] CEMUX = ""1"";
	parameter CLKMUX = ""CLK"";
	parameter LSRMUX = ""LSR"";
	parameter REGDDR = ""DISABLED"";
	parameter SRMODE = ""LSR_OVER_CE"";
	parameter REGSET = ""RESET"";
	parameter [127:0] LSRMODE = ""LSR"";

	wire muxce;
	generate
		case (CEMUX)
			""1"": assign muxce = 1'b1;
			""0"": assign muxce = 1'b0;
			""INV"": assign muxce = ~CE;
			default: assign muxce = CE;
		endcase
	endgenerate

	wire muxlsr = (LSRMUX == ""INV"") ? ~LSR : LSR;
	wire muxclk = (CLKMUX == ""INV"") ? ~CLK : CLK;
	wire srval;
	generate
		if (LSRMODE == ""PRLD"")
			assign srval = M;
		else
			assign srval = (REGSET == ""SET"") ? 1'b1 : 1'b0;
	endgenerate

	initial Q = srval;

	generate
		if (REGDDR == ""ENABLED"") begin
			if (SRMODE == ""ASYNC"") begin
				always @(posedge muxclk, negedge muxclk, posedge muxlsr)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end else begin
				always @(posedge muxclk, negedge muxclk)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end
		end else begin
			if (SRMODE == ""ASYNC"") begin
				always @(posedge muxclk, posedge muxlsr)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end else begin
				always @(posedge muxclk)
					if (muxlsr)
						Q <= srval;
					else if (muxce)
						Q <= DI;
			end
		end
	endgenerate
endmodule",64,755
24,1,0,False,False,"module OXIDE_COMB(
	input A, B, C, D, // LUT inputs
	input SEL, // mux select input
	input F1, // output from LUT 1 for mux
	input FCI, // carry input
	input WAD0, WAD1, WAD2, WAD3, // LUTRAM write address inputs
	input WD, // LUTRAM write data input
	input WCK, WRE, // LUTRAM write clock and enable
	output F, // LUT/carry output
	output OFX // mux output
);
	parameter MODE = ""LOGIC""; // LOGIC, CCU2, DPRAM
	parameter [15:0] INIT = 16'h0000;
	parameter INJECT = ""YES"";

	localparam inject_p = (INJECT == ""YES"") ? 1'b1 : 1'b0;

	reg [15:0] lut = INIT;

	wire [7:0] s3 = D ?     INIT[15:8] :     INIT[7:0];
	wire [3:0] s2 = C ?       s3[ 7:4] :       s3[3:0];
	wire [1:0] s1 = B ?       s2[ 3:2] :       s2[1:0];
	wire Z =        A ?          s1[1] :         s1[0];

	wire [3:0] s2_3 = C ?   INIT[ 7:4] :     INIT[3:0];
	wire [1:0] s1_3 = B ?   s2_3[ 3:2] :     s2_3[1:0];
	wire Z3 =         A ?      s1_3[1] :       s1_3[0];

	generate
		if (MODE == ""DPRAM"") begin
			always @(posedge WCK)
				if (WRE)
					lut[{WAD3, WAD2, WAD1, WAD0}] <= WD;
		end
		if (MODE == ""CCU2"") begin
			assign F = Z ^ (FCI & ~inject_p);
			assign FCO = Z ? FCI : (Z3 & ~inject_p);
		end else begin
			assign F = Z;
		end
	endgenerate

	assign OFX = SEL ? F1 : F;

endmodule",45,756
5,18,0,False,False,"module OXIDE_DSP_REG #(
	parameter W = 18,
	parameter USED = ""REGISTER"",
	parameter RESETMODE = ""SYNC""
) (
	input CLK, CE, RST,
	input [W-1:0] D,
	output reg [W-1:0] Q
);
	generate
		if (USED == ""BYPASS"")
			always @* Q = D;
		else if (USED == ""REGISTER"") begin
			initial Q = 0;
			if (RESETMODE == ""ASYNC"")
				always @(posedge CLK, posedge RST) begin
					if (RST)
						Q <= 0;
					else if (CE)
						Q <= D;
				end
			else if (RESETMODE == ""SYNC"")
				always @(posedge CLK) begin
					if (RST)
						Q <= 0;
					else if (CE)
						Q <= D;
				end
		end
	endgenerate
endmodule",31,757
137,165,0,False,False,"module shiftll (busSLL, busA, sel, zSLL, oSLL, cSLL, nSLL);
	output [31:0] busSLL;
	input  [31:0] busA, sel;
    output zSLL, nSLL;
    output reg oSLL, cSLL;

    assign busSLL = busA << sel[2:0];

    assign zSLL = ~|busSLL[31:0];
    assign nSLL = busSLL[31];
    always @(*) begin
    	if (sel[2:0] == 3'b0) begin
    		cSLL = 1'b0;
    		oSLL = 1'b0;
    	end else if (sel[2:0] == 3'b1) begin
    		cSLL = busSLL[31];
    		oSLL = busSLL[31];
    	end else if (sel[2:0] == 3'b10) begin
    		cSLL = busSLL[30];
            oSLL = |busSLL[31:30];
        end else if (sel[2:0] == 3'b11) begin
            cSLL = busSLL[29];
            oSLL = |busSLL[31:29];
        end else if (sel[2:0] == 3'b100) begin
            cSLL = busSLL[28];
            oSLL = |busSLL[31:28];
        end else if (sel[2:0] == 3'b101) begin
            cSLL = busSLL[27];
            oSLL = |busSLL[31:27];
        end else if (sel[2:0] == 3'b110) begin
            cSLL = busSLL[26];
            oSLL = |busSLL[31:26];
    	end	else begin
    		cSLL = busSLL[25];
    		oSLL = |busSLL[31:25];
    	end
    end
endmodule",38,768
29,25,0,False,False,"module control (
    input [5:0] op,
    output [1:0] alu_op,
    output regDst, aluSrc, memToReg, regWrite,
    output memRead, memWrite, branch
  );

wire int0, op0_bar, op1_bar, op2_bar, op3_bar, op4_bar, op5_bar;

not (op0_bar, op[0]);
not (op1_bar, op[1]);
not (op2_bar, op[2]);
not (op3_bar, op[3]);
not (op4_bar, op[4]);
not (op5_bar, op[5]);

and (alu_op[0], op5_bar, op4_bar, op3_bar, op[2]  , op1_bar, op0_bar); 
and (alu_op[1], op5_bar, op4_bar, op3_bar, op2_bar, op1_bar, op0_bar); 
and (regDst   , op5_bar, op4_bar, op3_bar, op2_bar, op1_bar, op0_bar); 
and (memToReg , op[5]  , op4_bar, op3_bar, op2_bar, op[1]  , op[0]  );
and (memRead  , op[5]  , op4_bar, op3_bar, op2_bar, op[1]  , op[0]  ); 
and (memWrite , op[5]  , op4_bar, op[3]  , op2_bar, op[1]  , op[0]  ); 
and (branch   , op5_bar, op4_bar, op3_bar, op[2]  , op1_bar, op0_bar); 
and (int0     , op[5]  , op4_bar, op3_bar, op2_bar, op[1]  , op[0]  );
and (aluSrc   , op[5]  , op4_bar, op2_bar, op[1]  , op[0] ); 
or  (regWrite , int0   , alu_op[1]);

endmodule",28,779
8,1,0,False,False,"module sky130_fd_sc_ms__or2 (
    X,
    A,
    B
);

    // Module ports
    output X;
    input  A;
    input  B;

    // Module supplies
    supply1 VPWR;
    supply0 VGND;
    supply1 VPB ;
    supply0 VNB ;

    // Local signals
    wire or0_out_X;

    //  Name  Output     Other arguments
    or  or0  (or0_out_X, B, A           );
    buf buf0 (X        , or0_out_X      );

endmodule",25,780
8,1,0,False,False,"module sky130_fd_sc_hdll__or2 (
    X,
    A,
    B
);

    // Module ports
    output X;
    input  A;
    input  B;

    // Module supplies
    supply1 VPWR;
    supply0 VGND;
    supply1 VPB ;
    supply0 VNB ;

    // Local signals
    wire or0_out_X;

    //  Name  Output     Other arguments
    or  or0  (or0_out_X, B, A           );
    buf buf0 (X        , or0_out_X      );

endmodule",25,790
10908,11444,0,True,False,"module bitec_reconfig_avalon_mm_master 
#(
  parameter XCVR = 1  // Usage: 0 = TXPLL, 1 = XCVR 
)
(

  input wire clk,
  input wire reset,

  // Command strobes
  input wire rcnf_req_cbus,               // Assert for 1 clk cycle to get access to internal config bus
  input wire rcnf_rel_cbus,               // Assert for 1 clk cycle to release internal config bus
  input wire rcnf_wcalib,                 // Assert for 1 clk cycle to wait for calibration end
  input wire rcnf_scalib,                 // Assert for 1 clk cycle to save linkrate related calibration results
  input wire rcnf_lcalib,                 // Assert for 1 clk cycle to load back linkrate related calibration results
  input wire rcnf_reconfig,               // Assert for 1 clk cycle to reconfig a single register
  input wire rcnf_en,                     // Must be asserted for command strobes to be accepted

  // Command parameters  
  input wire [1:0] rcnf_logical_ch,       // Logical channel number
  input wire [9:0] rcnf_address,          // Register address
  input wire [31:0] rcnf_data,            // Value of data to write
  input wire [31:0] rcnf_mask,            // Mask for data to write (bits at 1 get written)
  input wire [1:0] rcnf_linkrate,         // Link rate: 0 = RBR .... 3 = HBR3
  output wire rcnf_busy,                  // Asserted while operation is taking place

  // Reconfig management interface
  output reg [1:0] mgmt_chnum,
  output reg [9:0] mgmt_address,
  output reg [31:0] mgmt_writedata,
  input wire [31:0] mgmt_readdata,
  output reg mgmt_write,
  output reg mgmt_read,
  input  wire mgmt_waitrequest,
  input  wire cal_busy
);

// XCVR Reconfiguration controller register addresses
localparam ADDR_XCVR_BUS_ARB                = 10'h000,
           ADDR_XCVR_CDR_VCO_SPEED_FIX_7_6  = 10'h132,
           ADDR_XCVR_CHGPMP_PD_UP           = 10'h133,
           ADDR_XCVR_CDR_VCO_SPEED_FIX_4    = 10'h134,
           ADDR_XCVR_LF_PD_PFD              = 10'h135,  //VCO_SPEED_FIX_5
           ADDR_XCVR_CDR_VCO_SPEED_FIX      = 10'h136,  //VCO_SPEED_FIX_3_0
           ADDR_XCVR_CDR_VCO_SPEED          = 10'h137,
           ADDR_XCVR_CHGPMP_PD_DN           = 10'h139,
           ADDR_XCVR_CAL_BUSY               = 10'h281;

// TXPLL Reconfiguration controller register masks
localparam  MASK_XCVR_LF_PD_PFD             = 32'h0000_004f,
            MASK_XCVR_CDR_VCO_SPEED_FIX_7_6 = 32'h0000_00F7,
            MASK_XCVR_CDR_VCO_SPEED_FIX_4   = 32'h0000_00F7,
            MASK_XCVR_CDR_VCO_SPEED_FIX     = 32'h0000_000f,
            MASK_XCVR_CDR_VCO_SPEED         = 32'h0000_007c,
            MASK_XCVR_CHGPMP_PD_UP          = 32'h0000_00E0,
            MASK_XCVR_CHGPMP_PD_DN          = 32'h0000_00BF;

// TXPLL Reconfiguration controller register addresses
localparam ADDR_TXPLL_BUS_ARB           = 10'h000,
           ADDR_TXPLL_VCO_BAND1         = 10'h10A,
           ADDR_TXPLL_VCO_BAND2         = 10'h10B,
           ADDR_TXPLL_CAL_BUSY          = 10'h280;

// TXPLL Reconfiguration controller register masks
localparam  MASK_TXPLL_VCO_BAND1        = 32'h0000_001f,
            MASK_TXPLL_VCO_BAND2        = 32'h0000_00f8;

// State variables
localparam  FSM_IDLE       = 6'd0,
            FSM_REQBUS_RD  = 6'd1,
            FSM_REQBUS_WR  = 6'd2,
            FSM_RELBUS_RD  = 6'd3,
            FSM_RELBUS_WR  = 6'd4,
            FSM_WCAL_RD    = 6'd5,
            FSM_WCAL_TST   = 6'd6,
            FSM_SCAL_RD1   = 6'd7,
            FSM_SCAL_RD2   = 6'd8,
            FSM_SCAL_RD3   = 6'd9,
            FSM_SCAL_RD4   = 6'd10,
            FSM_SCAL_RD5   = 6'd11,
            FSM_SCAL_RD6   = 6'd12,
            FSM_SCAL_RD7   = 6'd13,
            FSM_SCAL_RD8   = 6'd14,
            FSM_SCAL_RD9   = 6'd15,
            FSM_LCAL_RD1   = 6'd16,
            FSM_LCAL_WR1   = 6'd17,
            FSM_LCAL_RD2   = 6'd18,
            FSM_LCAL_WR2   = 6'd19,
            FSM_LCAL_RD3   = 6'd20,
            FSM_LCAL_WR3   = 6'd21,
            FSM_LCAL_RD4   = 6'd22,
            FSM_LCAL_WR4   = 6'd23,
            FSM_LCAL_RD5   = 6'd24,
            FSM_LCAL_WR5   = 6'd25,
            FSM_LCAL_RD6   = 6'd26,
            FSM_LCAL_WR6   = 6'd27,
            FSM_LCAL_RD7   = 6'd28,
            FSM_LCAL_WR7   = 6'd29,
            FSM_LCAL_RD8   = 6'd30,
            FSM_LCAL_WR8   = 6'd31,
            FSM_LCAL_RD9   = 6'd32,
            FSM_LCAL_WR9   = 6'd33,
            FSM_READ       = 6'd34,
            FSM_WRITE      = 6'd35,
            FSM_END        = 6'd36;

localparam CALIB_RATES = 4; // 4 link rates
localparam CALIB_LANES = XCVR ? 4 : 1; // max 4 lanes
localparam CALIB_VALUES = XCVR ? 7 : 2; // number of calib result registers to store
localparam CALIB_RES_SIZE = CALIB_RATES * CALIB_LANES * CALIB_VALUES;

reg [5:0] state;
reg [7:0] calib_res [CALIB_RES_SIZE-1:0];

always @ (posedge clk or posedge reset) 
  if(reset) 
  begin
    state <= FSM_IDLE;
    mgmt_chnum  <= 2'd0;
    mgmt_address  <= 10'd0;
    mgmt_write <= 1'b0;
    mgmt_read <= 1'b0;
    mgmt_writedata <= 32'd0;
  end
  else
  begin
  
    mgmt_write <= 1'b0;  
    mgmt_read <= 1'b0;

    case (state)
      FSM_IDLE:
        if(rcnf_en)
        begin
          if(rcnf_req_cbus)
            state <= FSM_REQBUS_RD;
          if(rcnf_reconfig)
            state <= FSM_READ;
          if(rcnf_rel_cbus)
            state <= FSM_RELBUS_RD;
          if(rcnf_wcalib)
            state <= FSM_WCAL_RD;
          if(rcnf_scalib)
            state <= XCVR ? FSM_SCAL_RD3 : FSM_SCAL_RD1;
          if(rcnf_lcalib)
            state <= XCVR ? FSM_LCAL_RD3 : FSM_LCAL_RD1;
        end
      
      FSM_REQBUS_RD: // Grab AVMM control (read)
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_REQBUS_WR;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= XCVR ? ADDR_XCVR_BUS_ARB : ADDR_TXPLL_BUS_ARB;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_REQBUS_WR: // Grab AVMM control (modify-write)
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_IDLE;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~32'h0000_0001) | 32'h0000_0000;
            mgmt_write      <= 1'b1;  
          end
        end
    
      FSM_RELBUS_RD: // Release AVMM control (read)
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_RELBUS_WR;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= XCVR ? ADDR_XCVR_BUS_ARB : ADDR_TXPLL_BUS_ARB;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_RELBUS_WR: // Release AVMM control (modify-write)
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_IDLE;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~32'h0000_0001) | 32'h0000_0001;
            mgmt_write      <= 1'b1;  
          end
        end

      FSM_WCAL_RD: // Read calibration status
        if(~cal_busy)
          state <= FSM_IDLE; // rx_cal_busy or pll_cal_busy is 0
        else
          state <= FSM_WCAL_RD; // Still calibrating
      
      FSM_SCAL_RD1: // Read TXPLL calibration results
        begin
          if(mgmt_read & !mgmt_waitrequest) 
          begin
            calib_res[rcnf_linkrate*CALIB_VALUES+0] <= (mgmt_readdata[7:0] & MASK_TXPLL_VCO_BAND1[7:0]);
            state <= FSM_SCAL_RD2;
          end
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_TXPLL_VCO_BAND1;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_SCAL_RD2:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
          begin
            calib_res[rcnf_linkrate*CALIB_VALUES+1] <= (mgmt_readdata[7:0] & MASK_TXPLL_VCO_BAND2[7:0]);
            state <= FSM_IDLE;
          end
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_TXPLL_VCO_BAND2;
            mgmt_read      <= 1'b1;  
          end
        end

      FSM_SCAL_RD3: // Read XCVR calibration results
        begin
          if(mgmt_read & !mgmt_waitrequest) 
          begin
            calib_res[rcnf_linkrate*CALIB_VALUES+rcnf_logical_ch*CALIB_RATES*CALIB_VALUES+0] <= (mgmt_readdata[7:0] & MASK_XCVR_CDR_VCO_SPEED[7:0]);
            state <= FSM_SCAL_RD4;
          end
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CDR_VCO_SPEED;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_SCAL_RD4:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
          begin
            calib_res[rcnf_linkrate*CALIB_VALUES+rcnf_logical_ch*CALIB_RATES*CALIB_VALUES+1] <= (mgmt_readdata[7:0] & MASK_XCVR_CDR_VCO_SPEED_FIX[7:0]);
            state <= FSM_SCAL_RD5;
          end
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CDR_VCO_SPEED_FIX;
            mgmt_read      <= 1'b1;  
          end
        end

      FSM_SCAL_RD5:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
          begin
            calib_res[rcnf_linkrate*CALIB_VALUES+rcnf_logical_ch*CALIB_RATES*CALIB_VALUES+2] <= (mgmt_readdata[7:0] & MASK_XCVR_CHGPMP_PD_UP[7:0]);
            state <= FSM_SCAL_RD6;
          end
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CHGPMP_PD_UP;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_SCAL_RD6:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
          begin
            calib_res[rcnf_linkrate*CALIB_VALUES+rcnf_logical_ch*CALIB_RATES*CALIB_VALUES+3] <= (mgmt_readdata[7:0] & MASK_XCVR_CHGPMP_PD_DN[7:0]);
            state <= FSM_SCAL_RD7;
          end
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CHGPMP_PD_DN;
            mgmt_read      <= 1'b1;  
          end
        end

      FSM_SCAL_RD7:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
          begin
            calib_res[rcnf_linkrate*CALIB_VALUES+rcnf_logical_ch*CALIB_RATES*CALIB_VALUES+4] <= (mgmt_readdata[7:0] & MASK_XCVR_LF_PD_PFD[7:0]);
            state <= FSM_SCAL_RD8;
          end
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_LF_PD_PFD;
            mgmt_read      <= 1'b1;  
          end
        end

      
      FSM_SCAL_RD8:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
          begin
            calib_res[rcnf_linkrate*CALIB_VALUES+rcnf_logical_ch*CALIB_RATES*CALIB_VALUES+5] <= (mgmt_readdata[7:0] & MASK_XCVR_CDR_VCO_SPEED_FIX_7_6[7:0]);
            state <= FSM_SCAL_RD9;
          end
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CDR_VCO_SPEED_FIX_7_6;
            mgmt_read      <= 1'b1;  
          end
        end

      FSM_SCAL_RD9:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
          begin
            calib_res[rcnf_linkrate*CALIB_VALUES+rcnf_logical_ch*CALIB_RATES*CALIB_VALUES+6] <= (mgmt_readdata[7:0] & MASK_XCVR_CDR_VCO_SPEED_FIX_4[7:0]);
            state <= FSM_IDLE;
          end
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CDR_VCO_SPEED_FIX_4;
            mgmt_read      <= 1'b1;  
          end
        end
        
      FSM_LCAL_RD1: // Load back TXPLL calibration results
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_LCAL_WR1;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_TXPLL_VCO_BAND1;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_LCAL_WR1:
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_LCAL_RD2;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~MASK_TXPLL_VCO_BAND1) | calib_res[rcnf_linkrate*CALIB_VALUES+0];
            mgmt_write      <= 1'b1;  
          end
        end

      FSM_LCAL_RD2:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_LCAL_WR2;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_TXPLL_VCO_BAND2;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_LCAL_WR2:
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_IDLE;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~MASK_TXPLL_VCO_BAND2) | calib_res[rcnf_linkrate*CALIB_VALUES+1];
            mgmt_write      <= 1'b1;  
          end
        end

      FSM_LCAL_RD3: // Load back GXB calibration results
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_LCAL_WR3;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CDR_VCO_SPEED;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_LCAL_WR3:
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_LCAL_RD4;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~MASK_XCVR_CDR_VCO_SPEED) | calib_res[rcnf_linkrate*CALIB_VALUES+0];
            mgmt_write      <= 1'b1;  
          end
        end

      FSM_LCAL_RD4:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_LCAL_WR4;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CDR_VCO_SPEED_FIX;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_LCAL_WR4:
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_LCAL_RD5;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~MASK_XCVR_CDR_VCO_SPEED_FIX) | calib_res[rcnf_linkrate*CALIB_VALUES+1];
            mgmt_write      <= 1'b1;  
          end
        end

      FSM_LCAL_RD5:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_LCAL_WR5;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CHGPMP_PD_UP;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_LCAL_WR5:
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_LCAL_RD6;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~MASK_XCVR_CHGPMP_PD_UP) | calib_res[rcnf_linkrate*CALIB_VALUES+2];
            mgmt_write      <= 1'b1;  
          end
        end

      FSM_LCAL_RD6:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_LCAL_WR6;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CHGPMP_PD_DN;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_LCAL_WR6:
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_LCAL_RD7;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~MASK_XCVR_CHGPMP_PD_DN) | calib_res[rcnf_linkrate*CALIB_VALUES+3];
            mgmt_write      <= 1'b1;  
          end
        end

      FSM_LCAL_RD7:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_LCAL_WR7;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_LF_PD_PFD;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_LCAL_WR7:
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_LCAL_RD8;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~MASK_XCVR_LF_PD_PFD) | calib_res[rcnf_linkrate*CALIB_VALUES+4];
            mgmt_write      <= 1'b1;  
          end
        end

      FSM_LCAL_RD8:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_LCAL_WR8;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CDR_VCO_SPEED_FIX_7_6;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_LCAL_WR8:
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_LCAL_RD9;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~MASK_XCVR_CDR_VCO_SPEED_FIX_7_6) | calib_res[rcnf_linkrate*CALIB_VALUES+5];
            mgmt_write      <= 1'b1;  
          end
        end

      FSM_LCAL_RD9:
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_LCAL_WR9;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= ADDR_XCVR_CDR_VCO_SPEED_FIX_4;
            mgmt_read      <= 1'b1;  
          end
        end
      
      FSM_LCAL_WR9:
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_IDLE;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~MASK_XCVR_CDR_VCO_SPEED_FIX_4) | calib_res[rcnf_linkrate*CALIB_VALUES+6];
            mgmt_write      <= 1'b1;  
          end
        end

      FSM_READ: // Single register read
        begin
          if(mgmt_read & !mgmt_waitrequest) 
            state <= FSM_WRITE;
          else
          begin
            mgmt_chnum     <= rcnf_logical_ch;
            mgmt_address   <= rcnf_address;
            mgmt_read      <= 1'b1;  
          end
        end

      FSM_WRITE: // Single register modify-write
        begin
          if(mgmt_write & !mgmt_waitrequest) 
            state <= FSM_IDLE;
          else
          begin
            mgmt_writedata  <= (mgmt_readdata & ~rcnf_mask) | rcnf_data;
            mgmt_write      <= 1'b1;  
          end
        end
      endcase
      
    end

assign rcnf_busy = (state != FSM_IDLE) | rcnf_req_cbus | rcnf_rel_cbus | rcnf_reconfig | rcnf_wcalib | rcnf_scalib | rcnf_lcalib;

endmodule",572,793
135,164,0,False,False,"module logshiftright(distance,
                     data,
                     result);

   parameter             lpm_type = ""LPM_CLSHIFT"";
   parameter             lpm_width = 32;
   parameter             lpm_widthdist = 5;
   
   input  wire [lpm_widthdist-1:0] distance;
   input  wire [lpm_width-1    :0] data;
   output wire [lpm_width-1    :0] result;

   assign result = data >> distance;
endmodule",14,794
2,1,0,False,False,"module bw_clk_gclk_inv_224x (
    clkout,
    clkin );

    output clkout;
    input  clkin;
 
    assign clkout = ~( clkin );

endmodule",10,796
35,38,0,False,False,"module hex_to_7seg
  (
   input       i_Clk,
   input [3:0] i_Value,
   output      o_Segment_A,
   output      o_Segment_B,
   output      o_Segment_C,
   output      o_Segment_D,
   output      o_Segment_E,
   output      o_Segment_F,
   output      o_Segment_G
   );

  reg [6:0]    out = 7'b0000000;

  always @(posedge i_Clk)
	begin
	  case (i_Value)
		4'b0000 : out <= 7'b0000001;
		4'b0001 : out <= 7'b1001111;
		4'b0010 : out <= 7'b0010010;
		4'b0011 : out <= 7'b0000110;
		4'b0100 : out <= 7'b1001100;
		4'b0101 : out <= 7'b0100100;
		4'b0110 : out <= 7'b0100000;
		4'b0111 : out <= 7'b0001111;
		4'b1000 : out <= 7'b0000000;
		4'b1001 : out <= 7'b0000100;
		4'b1010 : out <= 7'b0001000;
		4'b1011 : out <= 7'b1100000;
		4'b1100 : out <= 7'b0110001;
		4'b1101 : out <= 7'b1000010;
		4'b1110 : out <= 7'b0110000;
		4'b1111 : out <= 7'b0111000;
	  endcase
	end

  assign o_Segment_A = out[6];
  assign o_Segment_B = out[5];
  assign o_Segment_C = out[4];
  assign o_Segment_D = out[3];
  assign o_Segment_E = out[2];
  assign o_Segment_F = out[1];
  assign o_Segment_G = out[0];

endmodule",46,803
1199,1227,0,False,False,"module ALU(A, B, ZF, OF, F, ALU_OP);
    input [2:0] ALU_OP;
    input [31:0] A, B;
    output reg [31:0] F;
    output reg ZF, OF;
    reg C32;
    always @(*)
    begin
        case(ALU_OP)
            3'd0:begin //and
                F = A&B;
                OF = 0;
            end
            3'd1:begin //or
                F = A|B;
                OF = 0;
            end
            3'd2:begin //xor
                F = A^B;
                OF = 0;
            end
            3'd3:begin //nor
					 F = ~(A|B);
					 OF = 0;
				end
            3'd4:begin //add
                {C32, F} = A + B;
                OF = A[31]^B[31]^F[31]^C32;
            end
            3'd5:begin //sub
                {C32, F} = A - B;
                OF = A[31]^B[31]^F[31]^C32;
            end
            3'd6:begin //slt
                if (A<B)
                    begin
                        F = 32'd1;
                    end
                else 
                    begin
                        F = 32'd0;
                    end
                OF = 0;
            end
            3'd7:begin //sll
              F=B<<A;
              OF=0;
            end
            default:begin
              F=A;
              OF = 0;
            end
            
        endcase
        if (F == 32'd0)
            begin
                ZF = 1;
            end
        else 
            begin
                ZF = 0;
            end
    end
    
endmodule",65,809
82,256,0,False,False,"module   m_download(//input
                    clk,
                    rst,
                    IN_flit_mem,
                    v_IN_flit_mem,
                    In_flit_ctrl,
                    mem_done_access,
                    //output
                    v_m_download,
                    m_download_flits,
                    m_download_state
                    );
//input
input                    clk;
input                    rst;
input     [15:0]         IN_flit_mem;
input                    v_IN_flit_mem;
input     [1:0]          In_flit_ctrl;
input                    mem_done_access;

//output
output                    v_m_download;
output    [175:0]         m_download_flits;
output    [1:0]           m_download_state;

//
reg [1:0]    m_download_nstate;
reg [1:0]    m_download_cstate;
parameter    m_download_idle=2'b00;
parameter    m_download_busy=2'b01;
parameter    m_download_rdy=2'b10;

reg   [15:0] flit_reg1;
reg   [15:0] flit_reg2;
reg   [15:0] flit_reg3;
reg   [15:0] flit_reg4;
reg   [15:0] flit_reg5;
reg   [15:0] flit_reg6;
reg   [15:0] flit_reg7;
reg   [15:0] flit_reg8;
reg   [15:0] flit_reg9;
reg   [15:0] flit_reg10;
reg   [15:0] flit_reg11;  

assign m_download_state=m_download_cstate;
assign m_download_flits={flit_reg11,flit_reg10,flit_reg9,flit_reg8,flit_reg7,flit_reg6,flit_reg5,flit_reg4,flit_reg3,flit_reg2,flit_reg1};


reg             v_m_download;
reg             en_flit_m;
reg             inc_cnt;
reg             fsm_rst;

/// fsm of ic_download
always@(*)
begin
  //default values
  m_download_nstate=m_download_cstate;
  v_m_download=1'b0;
  en_flit_m=1'b0;
  inc_cnt=1'b0;
  fsm_rst=1'b0;
  case(m_download_cstate)
    m_download_idle:
      begin
        if(v_IN_flit_mem)
          begin
            m_download_nstate=m_download_busy;
            en_flit_m=1'b1;
          end
      end
    m_download_busy:
      begin
        if(v_IN_flit_mem)
          begin
            if(In_flit_ctrl==2'b11)
              begin
                en_flit_m=1'b1;
                m_download_nstate=m_download_rdy;
              end
              en_flit_m=1'b1;
              inc_cnt=1'b1;
          end
      end
    m_download_rdy:
      begin
        v_m_download=1'b1;
        if(mem_done_access)
          begin
             m_download_nstate=m_download_idle;
             fsm_rst=1'b1;
          end
      end
    endcase
end

reg  [3:0]  cnt;
reg  [10:0]  en_flits;
// select right inst_word_in 
always@(*)
begin
  case(cnt)
    4'b0000:en_flits=11'b00000000001;
    4'b0001:en_flits=11'b00000000010;
    4'b0010:en_flits=11'b00000000100;
    4'b0011:en_flits=11'b00000001000;
    4'b0100:en_flits=11'b00000010000;
    4'b0101:en_flits=11'b00000100000;
    4'b0110:en_flits=11'b00001000000;
    4'b0111:en_flits=11'b00010000000;
    4'b1000:en_flits=11'b00100000000;
    4'b1001:en_flits=11'b01000000000;
    4'b1010:en_flits=11'b10000000000;
    default:en_flits=11'b00000000000;
  endcase
 end
 
// 1st flit
always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg1<=16'h0000;
  else if(en_flits[0]&&en_flit_m)
    flit_reg1<=IN_flit_mem;
end

//2ed flit 
 always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg2<=16'h0000;
  else if(en_flits[1]&&en_flit_m)
    flit_reg2<=IN_flit_mem;
end

// 3rd flit
always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg3<=16'h0000;
  else if(en_flits[2]&&en_flit_m)
    flit_reg3<=IN_flit_mem;
end

//4th flit
always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg4<=16'h0000;
  else if(en_flits[3]&&en_flit_m)
    flit_reg4<=IN_flit_mem;
end

//5th flit
always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg5<=16'h0000;
  else if(en_flits[4]&&en_flit_m)
    flit_reg5<=IN_flit_mem;
end

//6th flit
always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg6<=16'h0000;
  else if(en_flits[5]&&en_flit_m)
    flit_reg6<=IN_flit_mem;
end

//7th flit 
always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg7<=16'h0000;
  else if(en_flits[6]&&en_flit_m)
    flit_reg7<=IN_flit_mem;
end

//8th flit
always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg8<=16'h0000;
  else if(en_flits[7]&&en_flit_m)
    flit_reg8<=IN_flit_mem;
end

//9th flit 
always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg9<=16'h0000;
  else if(en_flits[8]&&en_flit_m)
    flit_reg9<=IN_flit_mem;
end

//10th flit 
always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg10<=16'h0000;
  else if(en_flits[9]&&en_flit_m)
    flit_reg10<=IN_flit_mem;
end

//11th flit 
always@(posedge clk)
begin
  if(rst||fsm_rst)
    flit_reg11<=16'h0000;
  else if(en_flits[10]&&en_flit_m)
    flit_reg11<=IN_flit_mem;
end
// fsm regs
always@(posedge clk)
begin
  if(rst)
    m_download_cstate<=2'b00;
  else
    m_download_cstate<=m_download_nstate;
end
//counter reg
always@(posedge clk)
begin
  if(rst||fsm_rst)
    cnt<=3'b000;
  else if(inc_cnt)
    cnt<=cnt+3'b001;
end
endmodule",232,817
9968,18993,0,False,False,"module rw_manager_ram

(

 data,
 rdaddress, 
 wraddress,
 wren, clock,
 q

);

parameter DATA_WIDTH=36;
parameter ADDR_WIDTH=8;

input [(DATA_WIDTH-1):0] data;
input [(ADDR_WIDTH-1):0] rdaddress, wraddress;
input wren, clock;
output reg [(DATA_WIDTH-1):0] q;


	reg [DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];


	always @ (posedge clock)

	begin

		if (wren)

		ram[wraddress] <= data[DATA_WIDTH-1:0];

		q <= ram[rdaddress];

	end



endmodule",39,819
364,373,0,False,False,"module umult8(reg_A, reg_B, result);
	// INPUTS
	input [0:7] reg_A, reg_B;
	
	// OUTPUTS
	output [0:15] result;
	
	// REGISTERS
	reg [0:15] p8a_0;
	reg [0:15] p8b_0;
	reg [0:15] pt;
	reg [0:15] result;
	
	// INTEGERS (contols for loops)
	integer i;

	always @ (reg_A or reg_B)
		begin
		//   reg_B
		// x reg_A
		// -------
		// result
		
		p8a_0=16'b0;
		p8b_0=16'b0;
		pt=16'b0;
		
		
		// extend operand B
		p8b_0={{8{1'b0}},reg_B[0:7]};
		
		// extend operand A
		p8a_0={{8{1'b0}},reg_A[0:7]};

		// compute sum due to partial products
/*
		// not using for loop
		pt=pt+(p8a_0[15]?(p8b_0):16'b0);
		pt=pt+(p8a_0[14]?(p8b_0<<8'd1):16'b0);
		pt=pt+(p8a_0[13]?(p8b_0<<8'd2):16'b0);
		pt=pt+(p8a_0[12]?(p8b_0<<8'd3):16'b0);
		pt=pt+(p8a_0[11]?(p8b_0<<8'd4):16'b0);
		pt=pt+(p8a_0[10]?(p8b_0<<8'd5):16'b0);
		pt=pt+(p8a_0[9]?(p8b_0<<8'd6):16'b0);
		pt=pt+(p8a_0[8]?(p8b_0<<8'd7):16'b0);
*/
		// same computation as above, but using for loop
		for (i=15; i>7; i=i-1)
			begin
			pt=pt+(p8a_0[i]?(p8b_0<<(8'd15-i)):16'b0);
			end
		// store sum as result
		result<=pt;
		end
endmodule",55,829
7,24,0,True,False,"module FIFO_image_filter_img_4_data_stream_2_V_shiftReg (
    clk,
    data,
    ce,
    a,
    q);

parameter DATA_WIDTH = 32'd8;
parameter ADDR_WIDTH = 32'd1;
parameter DEPTH = 32'd2;

input clk;
input [DATA_WIDTH-1:0] data;
input ce;
input [ADDR_WIDTH-1:0] a;
output [DATA_WIDTH-1:0] q;

reg[DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];
integer i;

always @ (posedge clk)
    begin
        if (ce)
        begin
            for (i=0;i<DEPTH-1;i=i+1)
                SRL_SIG[i+1] <= SRL_SIG[i];
            SRL_SIG[0] <= data;
        end
    end

assign q = SRL_SIG[a];

endmodule",33,831
407,508,0,False,False,"module axi_ad9434_pnmon (

  // adc interface

  adc_clk,
  adc_data,

  // pn out of sync and error

  adc_pn_oos,
  adc_pn_err,

  // processor interface PN9 (0x0), PN23 (0x1)

  adc_pn_type);

  // adc interface

  input           adc_clk;
  input   [47:0]  adc_data;

  // pn out of sync and error

  output          adc_pn_oos;
  output          adc_pn_err;

  // processor interface PN9 (0x0), PN23 (0x1)

  input           adc_pn_type;

  // internal registers

  reg     [47:0]  adc_pn_data = 'd0;
  reg     [ 6:0]  adc_pn_oos_count = 'd0;
  reg             adc_pn_oos = 'd0;
  reg             adc_pn_err = 'd0;

  // internal signals

  wire    [47:0]  adc_pn_data_in_s;
  wire            adc_pn_match_d_s;
  wire            adc_pn_match_z_s;
  wire            adc_pn_match_s;
  wire    [47:0]  adc_pn_data_s;
  wire            adc_pn_update_s;
  wire            adc_pn_err_s;

  // PN23 function

  function [47:0] pn23;
    input [47:0] din;
    reg   [47:0] dout;
    begin
      dout[47] = din[22] ^ din[17];
      dout[46] = din[21] ^ din[16];
      dout[45] = din[20] ^ din[15];
      dout[44] = din[19] ^ din[14];
      dout[43] = din[18] ^ din[13];
      dout[42] = din[17] ^ din[12];
      dout[41] = din[16] ^ din[11];
      dout[40] = din[15] ^ din[10];
      dout[39] = din[14] ^ din[ 9];
      dout[38] = din[13] ^ din[ 8];
      dout[37] = din[12] ^ din[ 7];
      dout[36] = din[11] ^ din[ 6];
      dout[35] = din[10] ^ din[ 5];
      dout[34] = din[ 9] ^ din[ 4];
      dout[33] = din[ 8] ^ din[ 3];
      dout[32] = din[ 7] ^ din[ 2];
      dout[31] = din[ 6] ^ din[ 1];
      dout[30] = din[ 5] ^ din[ 0];
      dout[29] = din[ 4] ^ din[22] ^ din[17];
      dout[28] = din[ 3] ^ din[21] ^ din[16];
      dout[27] = din[ 2] ^ din[20] ^ din[15];
      dout[26] = din[ 1] ^ din[19] ^ din[14];
      dout[25] = din[ 0] ^ din[18] ^ din[13];
      dout[24] = din[22] ^ din[12];
      dout[23] = din[21] ^ din[11];
      dout[22] = din[20] ^ din[10];
      dout[21] = din[19] ^ din[ 9];
      dout[20] = din[18] ^ din[ 8];
      dout[19] = din[17] ^ din[ 7];
      dout[18] = din[16] ^ din[ 6];
      dout[17] = din[15] ^ din[ 5];
      dout[16] = din[14] ^ din[ 4];
      dout[15] = din[13] ^ din[ 3];
      dout[14] = din[12] ^ din[ 2];
      dout[13] = din[11] ^ din[ 1];
      dout[12] = din[10] ^ din[ 0];
      dout[11] = din[ 9] ^ din[22] ^ din[17];
      dout[10] = din[ 8] ^ din[21] ^ din[16];
      dout[ 9] = din[ 7] ^ din[20] ^ din[15];
      dout[ 8] = din[ 6] ^ din[19] ^ din[14];
      dout[ 7] = din[ 5] ^ din[18] ^ din[13];
      dout[ 6] = din[ 4] ^ din[17] ^ din[12];
      dout[ 5] = din[ 3] ^ din[16] ^ din[11];
      dout[ 4] = din[ 2] ^ din[15] ^ din[10];
      dout[ 3] = din[ 1] ^ din[14] ^ din[ 9];
      dout[ 2] = din[ 0] ^ din[13] ^ din[ 8];
      dout[ 1] = din[22] ^ din[12] ^ din[17] ^ din[ 7];
      dout[ 0] = din[21] ^ din[11] ^ din[16] ^ din[ 6];
      pn23 = dout;
    end
  endfunction

  // PN9 function

  function [47:0] pn9;
    input [47:0] din;
    reg   [47:0] dout;
    begin
      dout[47] = din[ 8] ^ din[ 4];
      dout[46] = din[ 7] ^ din[ 3];
      dout[45] = din[ 6] ^ din[ 2];
      dout[44] = din[ 5] ^ din[ 1];
      dout[43] = din[ 4] ^ din[ 0];
      dout[42] = din[ 3] ^ din[ 8] ^ din[ 4];
      dout[41] = din[ 2] ^ din[ 7] ^ din[ 3];
      dout[40] = din[ 1] ^ din[ 6] ^ din[ 2];
      dout[39] = din[ 0] ^ din[ 5] ^ din[ 1];
      dout[38] = din[ 8] ^ din[ 0];
      dout[37] = din[ 7] ^ din[ 8] ^ din[ 4];
      dout[36] = din[ 6] ^ din[ 7] ^ din[ 3];
      dout[35] = din[ 5] ^ din[ 6] ^ din[ 2];
      dout[34] = din[ 4] ^ din[ 5] ^ din[ 1];
      dout[33] = din[ 3] ^ din[ 4] ^ din[ 0];
      dout[32] = din[ 2] ^ din[ 3] ^ din[ 8] ^ din[ 4];
      dout[31] = din[ 1] ^ din[ 2] ^ din[ 7] ^ din[ 3];
      dout[30] = din[ 0] ^ din[ 1] ^ din[ 6] ^ din[ 2];
      dout[29] = din[ 8] ^ din[ 0] ^ din[ 4] ^ din[ 5] ^ din[ 1];
      dout[28] = din[ 7] ^ din[ 8] ^ din[ 3] ^ din[ 0];
      dout[27] = din[ 6] ^ din[ 7] ^ din[ 2] ^ din[ 8] ^ din[ 4];
      dout[26] = din[ 5] ^ din[ 6] ^ din[ 1] ^ din[ 7] ^ din[ 3];
      dout[25] = din[ 4] ^ din[ 5] ^ din[ 0] ^ din[ 6] ^ din[ 2];
      dout[24] = din[ 3] ^ din[ 8] ^ din[ 5] ^ din[ 1];
      dout[23] = din[ 2] ^ din[ 4] ^ din[ 7] ^ din[ 0];
      dout[22] = din[ 1] ^ din[ 3] ^ din[ 6] ^ din[ 8] ^ din[ 4];
      dout[21] = din[ 0] ^ din[ 2] ^ din[ 5] ^ din[ 7] ^ din[ 3];
      dout[20] = din[ 8] ^ din[ 1] ^ din[ 6] ^ din[ 2];
      dout[19] = din[ 7] ^ din[ 0] ^ din[ 5] ^ din[ 1];
      dout[18] = din[ 6] ^ din[ 8] ^ din[ 0];
      dout[17] = din[ 5] ^ din[ 7] ^ din[ 8] ^ din[ 4];
      dout[16] = din[ 4] ^ din[ 6] ^ din[ 7] ^ din[ 3];
      dout[15] = din[ 3] ^ din[ 5] ^ din[ 6] ^ din[ 2];
      dout[14] = din[ 2] ^ din[ 4] ^ din[ 5] ^ din[ 1];
      dout[13] = din[ 1] ^ din[ 3] ^ din[ 4] ^ din[ 0];
      dout[12] = din[ 0] ^ din[ 2] ^ din[ 3] ^ din[ 8] ^ din[ 4];
      dout[11] = din[ 8] ^ din[ 1] ^ din[ 2] ^ din[ 4] ^ din[ 7] ^ din[ 3];
      dout[10] = din[ 7] ^ din[ 0] ^ din[ 1] ^ din[ 3] ^ din[ 6] ^ din[ 2];
      dout[ 9] = din[ 6] ^ din[ 8] ^ din[ 0] ^ din[ 2] ^ din[ 4] ^ din[ 5] ^ din[ 1];
      dout[ 8] = din[ 5] ^ din[ 7] ^ din[ 8] ^ din[ 1] ^ din[ 3] ^ din[ 0];
      dout[ 7] = din[ 6] ^ din[ 7] ^ din[ 0] ^ din[ 2] ^ din[ 8];
      dout[ 6] = din[ 5] ^ din[ 6] ^ din[ 8] ^ din[ 1] ^ din[ 4] ^ din[ 7];
      dout[ 5] = din[ 4] ^ din[ 5] ^ din[ 7] ^ din[ 0] ^ din[ 3] ^ din[ 6];
      dout[ 4] = din[ 3] ^ din[ 6] ^ din[ 8] ^ din[ 2] ^ din[ 5];
      dout[ 3] = din[ 2] ^ din[ 4] ^ din[ 5] ^ din[ 7] ^ din[ 1];
      dout[ 2] = din[ 1] ^ din[ 4] ^ din[ 3] ^ din[ 6] ^ din[ 0];
      dout[ 1] = din[ 0] ^ din[ 3] ^ din[ 2] ^ din[ 5] ^ din[ 8] ^ din[ 4];
      dout[ 0] = din[ 8] ^ din[ 2] ^ din[ 1] ^ din[ 7] ^ din[ 3];
      pn9 = dout;
    end
  endfunction

  // pn sequence checking algorithm is commonly used in most applications.
  // if oos is asserted (pn is out of sync):
  //    the next sequence is generated from the incoming data.
  //    if 16 sequences match consecutively, oos is cleared (de-asserted).
  // if oos is de-asserted (pn is in sync)
  //    the next sequence is generated from the current sequence.
  //    if 64 sequences mismatch consecutively, oos is set (asserted).
  // if oos is de-asserted, any spurious mismatches sets the error register.
  // ideally, processor should make sure both oos == 0x0 and err == 0x0.

  assign adc_pn_data_in_s = {adc_data[11:0], adc_data[23:12], adc_data[35:24], adc_data[47:36]};
  assign adc_pn_match_d_s = (adc_pn_data_in_s == adc_pn_data) ? 1'b1 : 1'b0;
  assign adc_pn_match_z_s = (adc_pn_data_in_s == 48'd0) ? 1'b0 : 1'b1;
  assign adc_pn_match_s = adc_pn_match_d_s & adc_pn_match_z_s;
  assign adc_pn_data_s = (adc_pn_oos == 1'b1) ? adc_pn_data_in_s : adc_pn_data;
  assign adc_pn_update_s = ~(adc_pn_oos ^ adc_pn_match_s);
  assign adc_pn_err_s = ~(adc_pn_oos | adc_pn_match_s);

  // pn running sequence

  always @(posedge adc_clk) begin
    if (adc_pn_type == 1'b0) begin
      adc_pn_data <= pn9(adc_pn_data_s);
    end else begin
      adc_pn_data <= pn23(adc_pn_data_s);
    end
  end

  // pn oos and counters (64 to clear and set).

  always @(posedge adc_clk) begin
    if (adc_pn_update_s == 1'b1) begin
      if (adc_pn_oos_count >= 16) begin
        adc_pn_oos_count <= 'd0;
        adc_pn_oos <= ~adc_pn_oos;
      end else begin
        adc_pn_oos_count <= adc_pn_oos_count + 1'b1;
        adc_pn_oos <= adc_pn_oos;
      end
    end else begin
      adc_pn_oos_count <= 'd0;
      adc_pn_oos <= adc_pn_oos;
    end
    adc_pn_err <= adc_pn_err_s;
  end

endmodule",210,833
20,11,0,True,False,"module SD_CMD (
                // inputs:
                 address,
                 chipselect,
                 clk,
                 reset_n,
                 write_n,
                 writedata,

                // outputs:
                 bidir_port,
                 readdata
              )
;

  inout            bidir_port;
  output  [ 31: 0] readdata;
  input   [  1: 0] address;
  input            chipselect;
  input            clk;
  input            reset_n;
  input            write_n;
  input   [ 31: 0] writedata;

  wire             bidir_port;
  wire             clk_en;
  reg              data_dir;
  wire             data_in;
  reg              data_out;
  wire             read_mux_out;
  reg     [ 31: 0] readdata;
  assign clk_en = 1;
  //s1, which is an e_avalon_slave
  assign read_mux_out = ({1 {(address == 0)}} & data_in) |
    ({1 {(address == 1)}} & data_dir);

  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          readdata <= 0;
      else if (clk_en)
          readdata <= {{{32 - 1}{1'b0}},read_mux_out};
    end


  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          data_out <= 0;
      else if (chipselect && ~write_n && (address == 0))
          data_out <= writedata;
    end


  assign bidir_port = data_dir ? data_out : 1'bZ;
  assign data_in = bidir_port;
  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          data_dir <= 0;
      else if (chipselect && ~write_n && (address == 1))
          data_dir <= writedata;
    end



endmodule",67,840
10,2,0,False,False,"module sky130_fd_sc_ms__nor3b (
    Y  ,
    A  ,
    B  ,
    C_N
);

    // Module ports
    output Y  ;
    input  A  ;
    input  B  ;
    input  C_N;

    // Module supplies
    supply1 VPWR;
    supply0 VGND;
    supply1 VPB ;
    supply0 VNB ;

    // Local signals
    wire nor0_out  ;
    wire and0_out_Y;

    //  Name  Output      Other arguments
    nor nor0 (nor0_out  , A, B           );
    and and0 (and0_out_Y, C_N, nor0_out  );
    buf buf0 (Y         , and0_out_Y     );

endmodule",29,848
28,48,0,False,False,"module clk14khz(input wire inclk,
	output wire outclk);
	reg [11:0] cnt = 0;
	assign outclk = cnt == 3551;
	always @(posedge inclk)
		if(outclk)
			cnt <= 0;
		else
			cnt <= cnt + 12'b1;
endmodule",10,855
15,20,0,False,False,"module clk16div(input wire clk,
	input wire inclk,
	output wire outclk
);
	reg [4:0] cnt = 0;
	assign outclk = cnt == 16;
	always @(posedge clk)
		if(outclk)
			cnt <= 0;
		else if(inclk)
			cnt <= cnt + 5'b1;

endmodule",13,856
8,7,0,False,False,"module div8(
	input wire clk,
	input wire reset,
	input wire enable,
	output wire out
);
	reg [2:0] cnt = 4;
	always @(posedge clk)
		if(reset)
			cnt <= 0;
		else if(enable)
			cnt <= cnt + 3'b1;
	assign out = cnt[2];
endmodule",14,857
8,6,0,False,False,"module count4(
	input wire clk,
	input wire reset,
	input wire enable,
	output wire out
);
	reg [1:0] cnt = 0;
	always @(posedge clk)
		if(reset)
			cnt <= 0;
		else if(enable && cnt != 3)
			cnt <= cnt + 2'b1;
	assign out = cnt == 3;
endmodule",14,858
10,11,0,False,False,"module clk4div(input wire clk,
	input wire inclk,
	output wire outclk
);
	reg [2:0] cnt = 0;
	assign outclk = cnt == 4;
	always @(posedge clk)
		if(outclk)
			cnt <= 0;
		else if(inclk)
			cnt <= cnt + 3'b1;
endmodule",12,859
585,708,0,False,False,"module encode_ctl(/*AUTOARG*/
   // Outputs
   hraddr, cnt_output_enable, cnt_len, cnt_output,
   cnt_finish,
   // Inputs
   clk, rst, data_valid, data_empty, hash_data, hash_data1,
   data_d1, data_d2, hash_ref, iidx, hdata, data, hash_d1,
   hash_data_d1
   );
   parameter LZF_WIDTH = 20;

   input     clk, rst;
   input     data_valid;
   input     data_empty;
   
   input [7:0] hash_data, hash_data1, data_d1, data_d2;
   input [LZF_WIDTH-1:0] hash_ref, iidx;
   
   input [7:0] 		 hdata, data, hash_d1;
   output [10:0] 	 hraddr;
   input 		 hash_data_d1;
   
   /*AUTOREG*/

   reg 			off_valid;
   reg 			iidx_window;
   always @(posedge clk or posedge rst)
     begin
	if (rst)
	  iidx_window <= #1 0;
	else if (iidx[11]) /* 2048 */
	  iidx_window <= #1 1;
     end
   
   reg [LZF_WIDTH-1:0] 	min_off, max_off;
   always @(posedge clk or posedge rst)
     begin
	if (rst)
	  min_off <= #1 0;
	else if (data_valid && iidx_window)
	  min_off <= #1 min_off + 1;
     end

   always @(posedge clk)
     begin
	if (data_valid)
	  max_off <= #1 iidx;
     end
   
   always @(/*AS*/hash_ref or max_off or min_off)
     begin
	if (hash_ref > min_off && hash_ref < max_off)
	  off_valid = 1;
	else
	  off_valid = 0;
     end

   reg [10:0] off;
   always @(/*AS*/hash_ref or max_off)
     begin
	off = max_off - hash_ref;
     end
   
   parameter [2:0]
		S_IDLE   = 3'h0,
		S_SEARCH = 3'h1,
		S_TR     = 3'h2,
		S_MATCH  = 3'h3,
		S_DELAY  = 3'h4,
		S_END    = 3'h5,
		S_DONE   = 3'h6,
		S_STOP   = 3'h7;

   reg [2:0] 	  state, state_next;
   always @(posedge clk or posedge rst)
     begin
	if (rst)
	  state <= #1 S_IDLE;
	else
	  state <= #1 state_next;
     end

   reg [3:0] cnt, cnt_next;
   always @(posedge clk)
     begin
	  cnt <= #1 cnt_next;
     end

   reg cnt_count, cnt_load;
   reg rallow;
   reg [10:0] raddr_plus_one;
   reg [10:0] raddr_reg;
   
   assign hraddr = rallow ? raddr_plus_one : raddr_reg;
   
   always @(/*AS*/cnt_count or cnt_load)
     begin
	if (cnt_load || cnt_count)
	  rallow = 1;
	else
	  rallow = 0;
     end

   reg [LZF_WIDTH-1:0] hash_ref_plus_one;
   always @(/*AS*/hash_ref)
     hash_ref_plus_one = hash_ref + 1'b1;
   
   always @(posedge clk)
     begin
	if (cnt_load)
	  raddr_plus_one <= #1 hash_ref_plus_one + 1'b1;
	else if (cnt_count)
	  raddr_plus_one <= #1 raddr_plus_one + 1'b1;
     end

   always @(posedge clk)
     begin
	if (cnt_load)
	  raddr_reg <= #1 hash_ref_plus_one;
	else if (cnt_count)
	  raddr_reg <= #1 raddr_plus_one;
     end
   
   reg cnt_big7, cnt_big7_next;
   always @(posedge clk)
     begin
	  cnt_big7 <= #1 cnt_big7_next;
     end
   

   always @(/*AS*/cnt or cnt_big7 or cnt_count or cnt_load)
     begin
	cnt_next = 0;
	cnt_big7_next = 0;
	
	if (cnt_load) begin
	   cnt_next = 2;
	   cnt_big7_next = 0;
	end else if (cnt_count) begin
	   cnt_next = cnt + 1;
	   if (cnt_big7 == 0) begin
	      if (cnt == 4'h7) begin
		 cnt_big7_next = 1;
		 cnt_next = 0;
	      end else
		cnt_big7_next = 0;
	   end else begin
	      cnt_big7_next = 1;
	   end
	   if (cnt == 4'hf)
	     cnt_next = 1;
	end else begin
	   cnt_next = cnt;
	   cnt_big7_next = cnt_big7;
	end
     end // always @ (...

   output cnt_output_enable;
   output [3:0] cnt_len;
   output [12:0] cnt_output;
   output 	 cnt_finish;

   reg [2:0] 	 dummy_cnt;
   always @(posedge clk or posedge rst)
     begin
	if (rst)
	  dummy_cnt <= #1 0;
	else if (state == S_DONE)
	  dummy_cnt <= #1 dummy_cnt + 1'b1;
     end
   
   reg 		 cnt_finish;
   reg 		 cnt_output_enable, cnt_output_enable_next;
   reg [12:0] 	 cnt_output, cnt_output_next;
   reg [3:0] 	 cnt_len, cnt_len_next;
   
   always @(/*AS*/cnt or cnt_big7 or data_d1 or data_d2
	    or data_empty or data_valid or dummy_cnt
	    or hash_data or hash_data_d1 or hdata
	    or off_valid or state)
     begin
	state_next = S_IDLE;         // state
	cnt_output_enable_next = 0;  // will output the length data
	cnt_load = 0;
	cnt_count = 0;

	case (state)
	  S_IDLE: begin
	     if (data_valid) 
	       state_next = S_DELAY;
	     else
	       state_next = S_IDLE;
	  end

	  S_DELAY: begin
	     if (data_valid) 
	       state_next = S_SEARCH;
	     else
	       state_next = S_DELAY;
	  end
	  
	  S_SEARCH: begin /* cmp d2 with hash data */
	     if (data_valid) begin
		if (data_d2 == hash_data && off_valid) begin
		   state_next = S_TR;
		   cnt_load = 1;
		   cnt_output_enable_next = 1;
		end else begin
		   cnt_output_enable_next = 1;
		   state_next = S_SEARCH;
		end
	     end else if (data_empty) begin
		cnt_output_enable_next = 1;
		state_next = S_END;
	     end else
	       state_next = S_SEARCH;
	  end // case: S_SEARCH
	  
	  S_TR: begin // driver the history memory 
	     if (data_valid && hash_data_d1) begin
		cnt_count = 1;
		state_next = S_MATCH;
	     end else if (data_valid) begin
		state_next = S_SEARCH;
		cnt_output_enable_next = 1;
	     end else if (data_empty) begin
		cnt_output_enable_next = 1;
		state_next = S_END;
	     end else begin
		state_next = S_TR;
	     end
	  end
	  
	  S_MATCH: begin /* cmp d2 with history */
	     if (data_valid) begin
		if (data_d1 == hdata) begin
		   state_next = S_MATCH;
		   cnt_count = 1;
		   if (cnt == 4'h7 && cnt_big7 == 0)
		     cnt_output_enable_next = 1;
		   else if (cnt == 4'hf)
		     cnt_output_enable_next = 1;
		end else begin // if (prev_data == history_do)
		   state_next = S_SEARCH;
		   cnt_output_enable_next = 1;
		end
	     end else if (data_empty) begin // if (stream_valid)
		state_next = S_END;
		cnt_output_enable_next = 1;
	     end else 
		state_next = S_MATCH;
	  end // case: S_MATCH
	  
	  S_END: begin /* output end mark */
	     state_next = S_DONE;
	     cnt_output_enable_next = 1;
	  end

	  S_DONE: begin /* output fake data */
	     state_next = S_DONE;
	     cnt_output_enable_next = 1;
	     if (&dummy_cnt) /* 4 X F = 64 */
	       state_next = S_STOP;
	  end

	  S_STOP: begin
	     state_next = S_STOP;
	  end
	endcase // case(state)
     end // always @ (...

   always @(posedge clk)
     begin
	cnt_output <= #1 cnt_output_next;
	cnt_len    <= #1 cnt_len_next;
     end
   
   always @(posedge clk or posedge rst)
     begin
	if (rst)
	  cnt_output_enable <= #1 0;
	else
	  cnt_output_enable <= #1 cnt_output_enable_next;
     end

   always @(/*AS*/state)
     cnt_finish = state == S_STOP;
   
   /* state == S_SEARCH lit char with offset */
   reg [3:0] encode_len_s;
   reg [12:0] encode_data_s;
   /* state == S_MATCH */
   reg [3:0]  encode_len_m;
   reg [12:0] encode_data_m;
   /* length package */
   reg [3:0]  encode_len;
   reg [12:0] encode_data;
   
   always @(/*AS*/cnt_output_enable_next or encode_data_m
	    or encode_data_s or encode_len_m or encode_len_s
	    or state)
     begin
	cnt_output_next = 0;
	cnt_len_next= 0;
	
	if (cnt_output_enable_next && state == S_SEARCH) begin
	   /* output offset and liter data */
	   cnt_output_next = encode_data_s;
	   cnt_len_next = encode_len_s;
	end else if (cnt_output_enable_next && state == S_END) begin
	   /* output end marker */
	   cnt_output_next = 9'b110000000;
	   cnt_len_next    = 4'h9;
	end else if (cnt_output_enable_next && state == S_DONE) begin
	   /* output flush data */
	   cnt_output_next = 9'b000000000;
	   cnt_len_next    = 4'hf;
	end else begin
	   cnt_output_next = encode_data_m;
	   cnt_len_next = encode_len_m;
	end
     end // always @ (...
   
   always @(/*AS*/cnt or cnt_big7 or cnt_count
	    or encode_data or encode_len)
     begin
	if (cnt_big7 == 0) begin
	   if (cnt_count) begin
	      encode_data_m = 4'hf;
	      encode_len_m = 4'h4;
	   end else begin
	      encode_data_m = encode_data;
	      encode_len_m = encode_len;
	   end
	end else begin
	   if (cnt == 4'hf && cnt_count == 0) begin
	      encode_data_m = {4'hf, 4'h0};
	      encode_len_m = 4'h8;
	   end else begin
	      encode_data_m = cnt;
	      encode_len_m = 4'h4;
	   end
	end // else: !if(cnt_big7 == 0)
     end
   
   always @(/*AS*/cnt_load or data_d2 or off)
     begin
	encode_len_s = 0;
	encode_data_s = 0;

	if (cnt_load) begin /* offset */
	   if (off[10:07] == 0) begin /* < 128 */
	      encode_len_s = 4'h9;
	      encode_data_s = {2'b11, off[6:0]};
	   end else begin
	      encode_len_s = 4'hd;
	      encode_data_s = {2'b10, off[10:0]};
	   end
	end else begin
	   encode_len_s = 4'h9;
	   encode_data_s = data_d2;
	end // else: !if(cnt_load)
     end
   
   always @(/*AS*/cnt)
     begin
	encode_len = 0;
	encode_data = 0;
	
	case (cnt[2:0])
	  3'h2: {encode_data, encode_len} = {2'b00, 4'h2};
	  3'h3: {encode_data, encode_len} = {2'b01, 4'h2};
	  3'h4: {encode_data, encode_len} = {2'b10, 4'h2};
	  3'h5: {encode_data, encode_len} = {2'b11, 2'b00, 4'h4};
	  3'h6: {encode_data, encode_len} = {2'b11, 2'b01, 4'h4};
	  3'h7: {encode_data, encode_len} = {2'b11, 2'b10, 4'h4};
	endcase
     end // always @ (...
   
   /* 
    * cnt_output_enable
    * cnt_big7
    * cnt
    * 
    *   big7  finish 
    *    0     1      <= 7 output encode(data/_len)
    *    1     1      >  7 output 4 bit cnt
    *    1     0      if big7==0 && cnt==7+1 output 4'hf and set big7=1
    *                 then big7==1 && cnt=4'hf output 4'hf
    * 
    */
endmodule",392,863
146,233,0,True,False,"module DoubleRegisters(
        clk,
        bus_in, bus_out1, bus_out2,
        num1, num2,
        cs_h_in, cs_l_in, cs_16_in,
        cs_h_out1, cs_l_out1, cs_16_out1,
        cs_h_out2, cs_l_out2, cs_16_out2);
    input [15:0] bus_in;
    output reg [15:0] bus_out1, bus_out2;
    input [1:0] num1, num2;
    input cs_h_in, cs_l_in, cs_16_in;
    input cs_h_out1, cs_l_out1, cs_16_out1;
    input cs_h_out2, cs_l_out2, cs_16_out2;
    input clk;
    
    (* ram_style=""block"" *)
    reg [7:0] store_h[3:0] /* verilator public_flat */;
    (* ram_style=""block"" *)
    reg [7:0] store_l[3:0] /* verilator public_flat */;
        
    always @ (posedge clk)
        if (cs_h_out1)
            bus_out1 <= {8'h00, store_h[num1]};
        else if (cs_l_out1)
            bus_out1 <= {8'h00, store_l[num1]};
        else if (cs_16_out1)
            bus_out1 <= {store_h[num1], store_l[num1]};
        else
            bus_out1 <= 16'bz;
            
    always @ (posedge clk)
        if (cs_h_out2)
            bus_out2 <= {8'h00, store_h[num2]};
        else if (cs_l_out2)
            bus_out2 <= {8'h00, store_l[num2]};
        else if (cs_16_out2)
            bus_out2 <= {store_h[num2], store_l[num2]};
        else
            bus_out2 <= 16'bz;  
            
    always @(posedge clk)
        if (cs_h_in)
            store_h[num1] <= bus_in[7:0];
        else if (cs_16_in) begin
            store_h[num1] <= bus_in[15:8];
        end
        
    always @(posedge clk)
        if (cs_l_in)
            store_l[num1] <= bus_in[7:0];
        else if (cs_16_in) begin
            store_l[num1] <= bus_in[7:0];
        end
        
endmodule",55,864
80,83,0,False,False,"module arbiter
	(
		input wire 	clk,

	// -- inputs ------------------------------------------------- >>>>>
		input wire  [3:0]	port_request_din,
		input wire 			arbiter_strobe_din,
		input wire 			clear_arbiter_din,

	// -- output ------------------------------------------------- >>>>>
		output wire [3:0]	xbar_conf_vector_dout
    );



// -- Parametros locales ----------------------------------------- >>>>>
	localparam 	RQS0 =	4'b0001;
	localparam	RQS1 =	4'b0010;
	localparam	RQS2 =	4'b0100;
	localparam	RQS3 =	4'b1000;
	
	localparam	PTY_NEXT_RQS1 =	2'b01;
	localparam	PTY_NEXT_RQS2 =	2'b10;
	localparam	PTY_NEXT_RQS3 =	2'b11;
	localparam	PTY_NEXT_RQS0 =	2'b00;



// -- Declaracion Temprana de Seales ---------------------------- >>>>>
	reg [3:0] xbar_conf_vector_reg 	= 4'b0000;
	


/*
-- Priority Encoder 

-- Descripcion:	Codificador de prioridad para la siguiente ronda de 
				arbitraje. Dependiendo de la peticion ganadora
				(xbar_conf_vector_reg) se otorga prioridad para el 
				proximo proceso de arbitraje a la entrada inferior 
				inmediada en la jeraraquia. 

				Ej. jerarquia por default de puertos {PE, x+, y+, x-, 
					y-}. Si la ronda anterior la peticion de 'y+' 
					resulto ganadora, la siguiente ronda las peticiones
					de 'x-' tienen la maxima prioridad.

				La prioridad esta codificada en binario naturas
				rqs_priority_reg.

*/
	reg  [1:0] rqs_priority_reg = 2'b00;
	reg  [1:0] rqs_priority_next;


	// -- Elemento de memoria ------------------------------------ >>>>>
		always @(posedge clk)
			if (clear_arbiter_din)
				rqs_priority_reg <= rqs_priority_next;


	// -- Elemento de logica del siguiente estado ---------------- >>>>>
		always @(*)
			begin
				rqs_priority_next = 2'b00;
				
				case (xbar_conf_vector_reg)
					RQS0:	rqs_priority_next = PTY_NEXT_RQS1;
					RQS1:	rqs_priority_next = PTY_NEXT_RQS2;
					RQS2:	rqs_priority_next = PTY_NEXT_RQS3;
					RQS3:	rqs_priority_next = PTY_NEXT_RQS0;
				endcase

			end //(*)





/*
-- Round Robin

-- Descripcion:	Codificacion de algoritmo Round Robin por medio de 
				tabla de verdad. Cada bit de 'grant_vector'	es 
				mutuamente excluyente de sus vecinos.

*/
	wire [3:0]	grant_vector;



	// -- Combinational RR ----------------------------------------------- >>>>>
		assign grant_vector[0] = 	(port_request_din[0] & ~rqs_priority_reg[1] & ~rqs_priority_reg[0])																			|
									(port_request_din[0] & ~rqs_priority_reg[1] &  rqs_priority_reg[0] & ~port_request_din[3] & ~port_request_din[2] & ~port_request_din[1])	|
									(port_request_din[0] &  rqs_priority_reg[1] & ~rqs_priority_reg[0] & ~port_request_din[3] & ~port_request_din[2])							|
									(port_request_din[0] &  rqs_priority_reg[1] &  rqs_priority_reg[0] & ~port_request_din[3]);

		assign grant_vector[1] = 	(port_request_din[1] & ~rqs_priority_reg[1] & ~rqs_priority_reg[0] & ~port_request_din[0])													|
									(port_request_din[1] & ~rqs_priority_reg[1] &  rqs_priority_reg[0])																			|
									(port_request_din[1] &  rqs_priority_reg[1] & ~rqs_priority_reg[0] & ~port_request_din[3] & ~port_request_din[2] & ~port_request_din[0])	|
									(port_request_din[1] &  rqs_priority_reg[1] &  rqs_priority_reg[0] & ~port_request_din[3] & ~port_request_din[0]);

		assign grant_vector[2] = 	(port_request_din[2] & ~rqs_priority_reg[1] & ~rqs_priority_reg[0] & ~port_request_din[1] & ~port_request_din[0])							|
									(port_request_din[2] & ~rqs_priority_reg[1] &  rqs_priority_reg[0] & ~port_request_din[1])													|
									(port_request_din[2] &  rqs_priority_reg[1] & ~rqs_priority_reg[0] )																		|
									(port_request_din[2] &  rqs_priority_reg[1] &  rqs_priority_reg[0] & ~port_request_din[3] & ~port_request_din[1] & ~port_request_din[0]);

		assign grant_vector[3] = 	(port_request_din[3] & ~rqs_priority_reg[1] & ~rqs_priority_reg[0] & ~port_request_din[2] & ~port_request_din[1] & ~port_request_din[0])	|
									(port_request_din[3] & ~rqs_priority_reg[1] &  rqs_priority_reg[0] & ~port_request_din[2] & ~port_request_din[1])							|
									(port_request_din[3] &  rqs_priority_reg[1] & ~rqs_priority_reg[0] & ~port_request_din[2])													|
									(port_request_din[3] &  rqs_priority_reg[1] &  rqs_priority_reg[0]);






// -- Registro de control para Crossbar -------------------------- >>>>>
	always @(posedge clk)
		if (clear_arbiter_din)
			xbar_conf_vector_reg <= {4{1'b0}};
		else 
			if (arbiter_strobe_din)
				xbar_conf_vector_reg <= grant_vector;



// -- Salida de Modulo ------------------------------------------- >>>>>
	assign xbar_conf_vector_dout = xbar_conf_vector_reg;



endmodule",133,878
11,10,0,False,False,"module quadrature_decoder(
    CLOCK, 
    RESET,
    A, 
    B, 
    COUNT_ENABLE,
    DIRECTION, 
    SPEED
);
    input CLOCK, RESET, A, B;
    output COUNT_ENABLE;
    output DIRECTION;
    output [3:0] SPEED;

    reg [2:0] A_delayed;
    reg [2:0] B_delayed;
    
    always @(posedge CLOCK or posedge RESET) begin 
        if (RESET) begin 
            A_delayed <= 0;
        end else begin
            A_delayed <= {A_delayed[1:0], A};
        end
    end
    
    always @(posedge CLOCK or posedge RESET) begin 
        if (RESET) begin 
            B_delayed <= 0;
        end else begin
            B_delayed <= {B_delayed[1:0], B};
        end
    end
    
    assign COUNT_ENABLE = A_delayed[1] ^ A_delayed[2] ^ B_delayed[1] ^ B_delayed[2];
    assign DIRECTION =  A_delayed[1] ^ B_delayed[2];
    assign SPEED = 4'd0;

    /*
    wire count_enable = A_delayed[1] ^ A_delayed[2] ^ B_delayed[1] ^ B_delayed[2];
    wire count_direction = A_delayed[1] ^ B_delayed[2];

    
    reg [31:0] total;
    always @(posedge CLOCK or posedge RESET) begin
        if (RESET) begin 
            total <= 0;
        end 
        else if (count_enable) begin
            // only want a final count between 0 & 27 (x4 for the clicks)
            if (count_direction && total < 109) begin 
                total <= total+1; 
            end
            else if (total > 0) begin 
                total <= total-1;
            end
        end
    end
    
    
    wire [31:0] clicks;
    assign clicks = total >> 2; // divide by 4 as the encoder has 4 edges per ""click""
    assign COUNT = clicks[7:0];

    */
endmodule",65,880
10,32,0,False,False,"module Cfu (
  input               cmd_valid,
  output              cmd_ready,
  input      [9:0]    cmd_payload_function_id,
  input      [31:0]   cmd_payload_inputs_0,
  input      [31:0]   cmd_payload_inputs_1,
  output              rsp_valid,
  input               rsp_ready,
  output     [31:0]   rsp_payload_outputs_0,
  input               reset,
  input               clk
);

  // Trivial handshaking for a combinational CFU
  assign rsp_valid = cmd_valid;
  assign cmd_ready = rsp_ready;

  //
  // select output -- note that we're not fully decoding the 3 function_id bits
  //
  assign rsp_payload_outputs_0 = cmd_payload_function_id[0] ? 
                                           cmd_payload_inputs_1 :
                                           cmd_payload_inputs_0 ;


endmodule",26,890
12,3,0,False,False,"module sky130_fd_sc_hd__nor4 (
    Y,
    A,
    B,
    C,
    D
);

    // Module ports
    output Y;
    input  A;
    input  B;
    input  C;
    input  D;

    // Module supplies
    supply1 VPWR;
    supply0 VGND;
    supply1 VPB ;
    supply0 VNB ;

    // Local signals
    wire nor0_out_Y;

    //  Name  Output      Other arguments
    nor nor0 (nor0_out_Y, A, B, C, D     );
    buf buf0 (Y         , nor0_out_Y     );

endmodule",29,891
12,8,0,False,False,"module Interleaver(
    input clk,
    input trigger,
    input Interleave_b,
	 input FF_en,
	 `ifdef XILINX_ISIM
		output reg output_en = 1'b1
	 `else
		output reg output_en = 1'b0
	 `endif
    );

(* shreg_extract = ""no"" *) reg Interleave = 1'b0, Interleave_a = 1'b0;
(* shreg_extract = ""no"" *) reg FF_en_a = 1'b0, FF_en_b = 1'b0;

always @(posedge clk) begin
	Interleave <= Interleave_a;
	Interleave_a <= Interleave_b;
	FF_en_a <= FF_en;
	FF_en_b <= FF_en_a;
	
	//output_en <= (trigger && Interleave) ? ~output_en : 1'b0;
	
	//if (trigger && Interleave) output_en <= ~output_en;
	if (trigger && FF_en_b) output_en <= (Interleave) ? ~output_en : 1'b1;
	else if (trigger) output_en <= 1'b0;
	else output_en <= output_en;
	//else if (trigger) output_en <= 1'b1;
	//else output_en <= output_en;
end
	
endmodule",32,901
85,103,0,True,False,"module phy_dqs_found_cal #
  (
   parameter TCQ             = 100,    // clk->out delay (sim only)
   parameter nCK_PER_CLK     = 2,      // # of memory clocks per CLK
   parameter nCL             = 5,      // Read CAS latency
   parameter AL              = ""0"",
   parameter nCWL            = 5,      // Write CAS latency
   parameter RANKS           = 1,      // # of memory ranks in the system
   parameter DQS_CNT_WIDTH   = 3,      // = ceil(log2(DQS_WIDTH))
   parameter DQS_WIDTH       = 8,      // # of DQS (strobe)
   parameter DRAM_WIDTH      = 8,      // # of DQ per DQS
   parameter REG_CTRL         = ""ON"",   // ""ON"" for registered DIMM
   parameter NUM_DQSFOUND_CAL = 3       // Number of times to iterate
   )
  (
   input                        clk,
   input                        rst,
   input                        dqsfound_retry,
   // From phy_init
   input                        pi_dqs_found_start,
   input                        detect_pi_found_dqs,
   // From the selected byte lane Phaser_IN
   input                        pi_found_dqs,
   input                        pi_dqs_found_all,
   // Byte lane selection counter
//   output [DQS_CNT_WIDTH:0]     pi_stg1_dqs_found_cnt,
   // To All byte lane Phaser_INs simulataneously
   output reg                   pi_rst_stg1_cal,
   // To hard PHY
//   output                       stg2_done_r,
   // To phy_init
   output [5:0]                 rd_data_offset,
   output                       pi_dqs_found_rank_done,
   output                       pi_dqs_found_done,
   output reg                   pi_dqs_found_err,
   output [6*RANKS-1:0]         rd_data_offset_ranks,
   output reg                   dqsfound_retry_done,
   //To MC
   output [6*RANKS-1:0]         rd_data_offset_ranks_mc
  );
  

// For non-zero AL values
   localparam nAL = (AL == ""CL-1"") ? nCL - 1 : 0;   

// Adding the register dimm latency to write latency
   localparam CWL_M = (REG_CTRL == ""ON"") ? nCWL + nAL + 1 : nCWL + nAL;

  integer l;
  
  reg                     dqs_found_start_r;
  reg [5:0]               rd_byte_data_offset[0:RANKS-1];
//  reg [DQS_CNT_WIDTH:0]   dqs_cnt_r;
  reg                     rank_done_r;
  reg                     rank_done_r1;
  reg                     dqs_found_done_r;
  reg                     init_dqsfound_done_r;
  reg                     init_dqsfound_done_r1;
  reg                     init_dqsfound_done_r2;
  reg                     init_dqsfound_done_r3;
  reg [1:0]               rnk_cnt_r;
//  reg [5:0]               smallest_data_offset[0:RANKS-1];
  reg [5:0]               final_data_offset[0:RANKS-1];
  reg [5:0]               final_data_offset_mc[0:RANKS-1];
  reg                     reg_pi_found_dqs;
  reg                     reg_pi_found_dqs_all;
  reg                     reg_pi_found_dqs_all_r1;
  reg                     pi_rst_stg1_cal_r;
  reg [2:0]               calib_cnt;
  reg                     dqsfound_retry_r1;
  

  
  
//  assign stg2_done_r        = init_dqsfound_done_r;
  assign pi_dqs_found_rank_done    = rank_done_r;
  assign pi_dqs_found_done         = dqs_found_done_r;

  generate
  genvar rnk_cnt;
    for (rnk_cnt = 0; rnk_cnt < RANKS; rnk_cnt = rnk_cnt + 1) begin: rnk_loop
      assign rd_data_offset_ranks[6*rnk_cnt+:6] = final_data_offset[rnk_cnt];
      assign rd_data_offset_ranks_mc[6*rnk_cnt+:6] = final_data_offset_mc[rnk_cnt];
    end
  endgenerate
  
  // final_data_offset is used during write calibration and during
  // normal operation. One rd_data_offset value per rank for entire
  // interface
  assign rd_data_offset = (~init_dqsfound_done_r2) ? rd_byte_data_offset[rnk_cnt_r] :
                          final_data_offset[rnk_cnt_r];

  
   //**************************************************************************
   // DQS count to hard PHY during read data offset calibration using 
   // Phaser_IN Stage1 
   //**************************************************************************
//   assign pi_stg1_dqs_found_cnt = dqs_cnt_r;
  

  always @(posedge clk) begin
    if (rst || pi_rst_stg1_cal_r) begin
      reg_pi_found_dqs     <= #TCQ 'b0;
      reg_pi_found_dqs_all <= #TCQ 1'b0;
    end else if (pi_dqs_found_start) begin
      reg_pi_found_dqs     <= #TCQ pi_found_dqs;
      reg_pi_found_dqs_all <= #TCQ pi_dqs_found_all;
    end
  end
  
  
  always@(posedge clk)
    dqs_found_start_r <= #TCQ pi_dqs_found_start;

  always @(posedge clk) begin
    if (rst || rank_done_r)
      calib_cnt <= #TCQ 'b0;
    else if ((rd_byte_data_offset[rnk_cnt_r] < (nCL + nAL -1)) &&
             (calib_cnt < NUM_DQSFOUND_CAL))
      calib_cnt <= #TCQ calib_cnt + 1;
    else
      calib_cnt <= #TCQ calib_cnt;
  end      

  // Read data offset value calib all DQSs simulataneously
  always @(posedge clk) begin
    if (rst || dqsfound_retry) begin
      for (l = 0; l < RANKS; l = l + 1) begin: rst_rd_data_offset_loop
        rd_byte_data_offset[l] <= #TCQ nCL + nAL + 13;
      end
    end else if ((rank_done_r1 && ~init_dqsfound_done_r) ||
       (rd_byte_data_offset[rnk_cnt_r] < (nCL + nAL -1))) begin
          rd_byte_data_offset[rnk_cnt_r] <= #TCQ nCL + nAL + 13;
    end else if (dqs_found_start_r && ~reg_pi_found_dqs_all &&
             detect_pi_found_dqs && ~init_dqsfound_done_r)
      rd_byte_data_offset[rnk_cnt_r] 
      <= #TCQ rd_byte_data_offset[rnk_cnt_r] - 1;
  end
  

  always @(posedge clk) begin
    if (rst)
      rnk_cnt_r <= #TCQ 2'b00;
    else if (init_dqsfound_done_r)
      rnk_cnt_r <= #TCQ rnk_cnt_r;
    else if (rank_done_r)
      rnk_cnt_r <= #TCQ rnk_cnt_r + 1;
  end
  
  //*****************************************************************
  // Read data_offset calibration done signal
  //*****************************************************************
  
  always @(posedge clk) begin
    if (rst || pi_rst_stg1_cal_r)
      init_dqsfound_done_r  <= #TCQ 1'b0;
    else if (reg_pi_found_dqs_all && ~reg_pi_found_dqs_all_r1) begin
      if (rnk_cnt_r == RANKS-1)
        init_dqsfound_done_r  <= #TCQ 1'b1;
      else
        init_dqsfound_done_r  <= #TCQ 1'b0;
    end
  end
  
  always @(posedge clk) begin
    if (rst  || pi_rst_stg1_cal_r ||
       (init_dqsfound_done_r && (rnk_cnt_r == RANKS-1)))
      rank_done_r       <= #TCQ 1'b0;
    else if (reg_pi_found_dqs_all && ~reg_pi_found_dqs_all_r1)
      rank_done_r <= #TCQ 1'b1;
    else
      rank_done_r       <= #TCQ 1'b0;
  end
  
  always @(posedge clk) begin
    init_dqsfound_done_r1   <= #TCQ init_dqsfound_done_r;
    init_dqsfound_done_r2   <= #TCQ init_dqsfound_done_r1;
    init_dqsfound_done_r3   <= #TCQ init_dqsfound_done_r2;
    reg_pi_found_dqs_all_r1 <= #TCQ reg_pi_found_dqs_all;
    rank_done_r1            <= #TCQ rank_done_r;
    dqsfound_retry_r1       <= #TCQ dqsfound_retry;
  end

  always @(posedge clk) begin
    if (rst || dqsfound_retry || dqsfound_retry_r1 || pi_rst_stg1_cal_r)
      dqsfound_retry_done <= #TCQ 1'b0;
    else if (init_dqsfound_done_r)
      dqsfound_retry_done <= #TCQ 1'b1;
  end
  
  always @(posedge clk) begin
    if (rst)
      dqs_found_done_r <= #TCQ 1'b0;
    else if (reg_pi_found_dqs_all && (rnk_cnt_r == RANKS-1) && init_dqsfound_done_r1)
      dqs_found_done_r <= #TCQ 1'b1;
    else
      dqs_found_done_r <= #TCQ 1'b0;
  end
  

  
  // Reset read data offset calibration in all DQS Phaser_INs
  // after the read data offset value for a rank is determined
  // or if within a rank DQSFOUND is not asserted for all DQSs
  always @(posedge clk) begin
    if (rst || pi_rst_stg1_cal_r)
      pi_rst_stg1_cal <= #TCQ 1'b0;
    else if ((pi_dqs_found_start && ~dqs_found_start_r) ||
             (dqsfound_retry) ||
             (reg_pi_found_dqs && ~pi_dqs_found_all) ||
             (rd_byte_data_offset[rnk_cnt_r] < (nCL + nAL -1)))
      pi_rst_stg1_cal <= #TCQ 1'b1;
//    else
//      pi_rst_stg1_cal <= #TCQ 1'b0;
  end
  
  always @(posedge clk)
    pi_rst_stg1_cal_r     <= #TCQ pi_rst_stg1_cal;

  
  // Determine smallest rd_data_offset value per rank and assign it as the
  // Final read data offset value to be used during write calibration and
  // normal operation
  generate
  genvar i;
    for (i = 0; i < RANKS; i = i + 1) begin: smallest_final_loop
      always @(posedge clk) begin
        if (rst)
          final_data_offset[i]    <= #TCQ 'b0;
        else if (dqsfound_retry)
          final_data_offset[i] <= #TCQ rd_byte_data_offset[i];
        else if (init_dqsfound_done_r && ~init_dqsfound_done_r1) begin
          final_data_offset[i] <= #TCQ rd_byte_data_offset[i];
          if (CWL_M % 2) // odd latency CAS slot 1
            final_data_offset_mc[i] <= #TCQ rd_byte_data_offset[i] - 1;
          else // even latency CAS slot 0
            final_data_offset_mc[i] <= #TCQ rd_byte_data_offset[i];
        end
      end
    end
  endgenerate

  
  // Error generation in case pi_found_dqs signal from Phaser_IN
  // is not asserted when a common rddata_offset value is used
  always @(posedge clk) begin
    if (rst)
      pi_dqs_found_err <= #TCQ 1'b0;
    else if (!reg_pi_found_dqs_all && (calib_cnt == NUM_DQSFOUND_CAL) &&
            (rd_byte_data_offset[rnk_cnt_r] < (nCL + nAL -1)))
      pi_dqs_found_err <= #TCQ 1'b1;
  end
  
  
endmodule",255,908
12,3,0,False,False,"module sky130_fd_sc_hdll__and4bb (
    X  ,
    A_N,
    B_N,
    C  ,
    D
);

    // Module ports
    output X  ;
    input  A_N;
    input  B_N;
    input  C  ;
    input  D  ;

    // Module supplies
    supply1 VPWR;
    supply0 VGND;
    supply1 VPB ;
    supply0 VNB ;

    // Local signals
    wire nor0_out  ;
    wire and0_out_X;

    //  Name  Output      Other arguments
    nor nor0 (nor0_out  , A_N, B_N       );
    and and0 (and0_out_X, nor0_out, C, D );
    buf buf0 (X         , and0_out_X     );

endmodule",31,914
296,321,0,False,False,"module template_6x4_600x400(clk, hc, vc, matrix_x, matrix_y, lines);
	input clk;
	input [10:0] hc;
	input [10:0] vc;
	output reg[2:0]matrix_x = 3'd0;//desde 0 hasta 5
	output reg[1:0]matrix_y = 2'd0;//desde 0 hasta 3
	output reg lines;

	parameter d_col=8'b1_1001;		//25 ....agregar 2 ceros //25 * 6 = 150
	parameter d_row=7'b1_1001;		//25 ....agregar 2 ceros //25 * 4 = 100
	parameter zeros_col=2'd0;
	parameter zeros_row=2'd0;
	
	reg [7:0]col=d_col;	
	reg [6:0]row=d_row;		
	reg [7:0]col_next;
	reg [6:0]row_next;
	
	reg [2:0]matrix_x_next;
	reg [1:0]matrix_y_next;
	
	wire [10:0]hc_template, vc_template;
	
	
	parameter CUADRILLA_XI = 		212;
	parameter CUADRILLA_XF = 		812;
	
	parameter CUADRILLA_YI = 		184;
	parameter CUADRILLA_YF = 		584;
	
	assign hc_template = ( (hc > CUADRILLA_XI) && (hc <= CUADRILLA_XF) )?hc - CUADRILLA_XI: 11'd0;
	assign vc_template = ( (vc > CUADRILLA_YI) && (vc <= CUADRILLA_YF) )?vc - CUADRILLA_YI: 11'd0;
	
	
	
	always@(*)
		if(hc_template == 'd0)//fuera del rango visible
			{col_next, matrix_x_next} = {d_col, 3'd0};
		else if(hc_template > {col, zeros_col})
			{col_next, matrix_x_next} = {col + d_col, matrix_x + 3'd1};
		else
			{col_next,matrix_x_next} = {col, matrix_x};
	
	always@(*)
		if(vc_template == 'd0)
			{row_next,matrix_y_next} = {d_row, 2'd0};
		else if(vc_template > {row, zeros_row})
			{row_next, matrix_y_next} = {row + d_row, matrix_y + 2'd1};
		else
			{row_next, matrix_y_next} = {row, matrix_y};
	
	//para generar las lneas divisorias.
	reg lin_v, lin_v_next;
	reg lin_h, lin_h_next;
	
	always@(*)
	begin
		if(hc_template > {col, zeros_col})
			lin_v_next = 1'b1;
		else
			lin_v_next = 1'b0;
			
		if(vc_template > {row, zeros_row})
			lin_h_next = 1'b1;
		else if(hc == CUADRILLA_XF)
			lin_h_next = 1'b0;
		else
			lin_h_next = lin_h;
	end
	
	
	always@(posedge clk)
		{col, row, matrix_x, matrix_y} <= {col_next, row_next, matrix_x_next, matrix_y_next};
	
	always@(posedge clk)
		{lin_v, lin_h} <= {lin_v_next, lin_h_next};
		
	
	always@(*)
		if( (hc == (CUADRILLA_XI + 11'd1)) || (hc == CUADRILLA_XF) ||
		  (vc == (CUADRILLA_YI + 11'd1)) || (vc == CUADRILLA_YF) )
			lines = 1'b1;
		else if( (lin_v == 1'b1) || (lin_h == 1'b1))
			lines = 1'b1;
		else
			lines = 1'b0;

endmodule",88,928
7,1,0,False,False,"module sky130_fd_sc_lp__invlp (
    Y,
    A
);

    // Module ports
    output Y;
    input  A;

    // Module supplies
    supply1 VPWR;
    supply0 VGND;
    supply1 VPB ;
    supply0 VNB ;

    // Local signals
    wire not0_out_Y;

    //  Name  Output      Other arguments
    not not0 (not0_out_Y, A              );
    buf buf0 (Y         , not0_out_Y     );

endmodule",23,937
48,58,0,False,False,"module spi_slave(
	input clk,
	input rst,
	input ss,
	input mosi,
	output miso,
	input sck,
	output done,
	input [7:0] din,
	output [7:0] dout
    );

reg mosi_d, mosi_q;
reg ss_d, ss_q;
reg sck_d, sck_q;
reg sck_old_d, sck_old_q;
reg [7:0] data_d, data_q;
reg done_d, done_q;
reg [2:0] bit_ct_d, bit_ct_q;
reg [7:0] dout_d, dout_q;
reg miso_d, miso_q;

assign miso = miso_q;
assign done = done_q;
assign dout = dout_q;

always @(*) begin
	ss_d = ss;
	mosi_d = mosi;
	miso_d = miso_q;
	sck_d = sck;
	sck_old_d = sck_q;
	data_d = data_q;
	done_d = 1'b0;
	bit_ct_d = bit_ct_q;
	dout_d = dout_q;

	if (ss_q) begin
		bit_ct_d = 3'b0;
		data_d = din;
		miso_d = data_q[7];
	end else begin
		if (!sck_old_q && sck_q) begin // rising edge
			data_d = {data_q[6:0], mosi_q};
			bit_ct_d = bit_ct_q + 1'b1;
			if (bit_ct_q == 3'b111) begin
				dout_d = {data_q[6:0], mosi_q};
				done_d = 1'b1;
				data_d = din;
			end
		end else if (sck_old_q && !sck_q) begin // falling edge
			miso_d = data_q[7];
		end
	end
end

always @(posedge clk) begin
	if (rst) begin
		done_q <= 1'b0;
		bit_ct_q <= 3'b0;
		dout_q <= 8'b0;
		miso_q <= 1'b1;
	end else begin
		done_q <= done_d;
		bit_ct_q <= bit_ct_d;
		dout_q <= dout_d;
		miso_q <= miso_d;
	end

	sck_q <= sck_d;
	mosi_q <= mosi_d;
	ss_q <= ss_d;
	data_q <= data_d;
	sck_old_q <= sck_old_d;

end


endmodule",79,938
425,654,0,False,False,"module axis_gate_controller
(
  input  wire         aclk,
  input  wire         aresetn,

  // Slave side
  output wire         s_axis_tready,
  input  wire [127:0] s_axis_tdata,
  input  wire         s_axis_tvalid,

  output wire [31:0]  poff,
  output wire [15:0]  level,
  output wire         dout
);

  reg int_tready_reg, int_tready_next;
  reg int_dout_reg, int_dout_next;
  reg int_enbl_reg, int_enbl_next;
  reg [63:0] int_cntr_reg, int_cntr_next;
  reg [127:0] int_data_reg, int_data_next;

  always @(posedge aclk)
  begin
    if(~aresetn)
    begin
      int_tready_reg <= 1'b0;
      int_dout_reg <= 1'b0;
      int_enbl_reg <= 1'b0;
      int_cntr_reg <= 64'd0;
      int_data_reg <= 128'd0;
    end
    else
    begin
      int_tready_reg <= int_tready_next;
      int_dout_reg <= int_dout_next;
      int_enbl_reg <= int_enbl_next;
      int_cntr_reg <= int_cntr_next;
      int_data_reg <= int_data_next;
    end
  end

  always @*
  begin
    int_tready_next = int_tready_reg;
    int_dout_next = int_dout_reg;
    int_enbl_next = int_enbl_reg;
    int_cntr_next = int_cntr_reg;
    int_data_next = int_data_reg;

    if(~int_enbl_reg & s_axis_tvalid)
    begin
      int_tready_next = 1'b1;
      int_enbl_next = 1'b1;
      int_cntr_next = 64'd0;
      int_data_next = s_axis_tdata;
    end

    if(int_enbl_reg)
    begin
      int_cntr_next = int_cntr_reg + 1'b1;

      if(int_cntr_reg == 64'd0)
      begin
        int_dout_next = |int_data_reg[111:96];
      end

      if(int_cntr_reg == int_data_reg[63:0])
      begin
        int_dout_next = 1'b0;
        int_enbl_next = 1'b0;
      end
    end

    if(int_tready_reg)
    begin
      int_tready_next = 1'b0;
    end
  end

  assign s_axis_tready = int_tready_reg;
  assign poff = int_data_reg[95:64];
  assign level = int_data_reg[111:96];
  assign dout = int_dout_reg;

endmodule",85,945
8,3,0,False,False,"module sky130_fd_sc_hd__a2bb2o (
    X   ,
    A1_N,
    A2_N,
    B1  ,
    B2
);

    // Module ports
    output X   ;
    input  A1_N;
    input  A2_N;
    input  B1  ;
    input  B2  ;

    // Local signals
    wire and0_out ;
    wire nor0_out ;
    wire or0_out_X;

    //  Name  Output     Other arguments
    and and0 (and0_out , B1, B2            );
    nor nor0 (nor0_out , A1_N, A2_N        );
    or  or0  (or0_out_X, nor0_out, and0_out);
    buf buf0 (X        , or0_out_X         );

endmodule",27,952
8,3,0,False,False,"module sky130_fd_sc_lp__a2bb2o (
    X   ,
    A1_N,
    A2_N,
    B1  ,
    B2
);

    // Module ports
    output X   ;
    input  A1_N;
    input  A2_N;
    input  B1  ;
    input  B2  ;

    // Local signals
    wire and0_out ;
    wire nor0_out ;
    wire or0_out_X;

    //  Name  Output     Other arguments
    and and0 (and0_out , B1, B2            );
    nor nor0 (nor0_out , A1_N, A2_N        );
    or  or0  (or0_out_X, nor0_out, and0_out);
    buf buf0 (X        , or0_out_X         );

endmodule",27,957
21,32,0,False,False,"module clkdivider
(
  input wire clk,
  input wire reset,
  output reg clk_out
);

  reg [7:0] counter;

  always @(posedge clk)
  begin
    if (reset)
    begin
      counter <= 8'd0;
      clk_out <= 1'b0;
    end
    else if (counter == 8'hff)
    begin
      counter <= 8'd0;
      clk_out <= ~clk_out;
    end
    else
    begin
      counter <= counter+1;
    end
  end
endmodule",27,959
137,164,0,False,False,"module lcdc(
    input wire clk, // clk491520
    input wire rst,

    output wire [8:0] x_o,
    output wire [6:0] y_o,
    output wire in_vsync_o,
    output wire in_hsync_o,
    output wire pop_o,
    input wire [5:0] r_i,
    input wire [5:0] g_i,
    input wire [5:0] b_i,
    input wire ack_i,

    output wire [5:0] lcd_r,
    output wire [5:0] lcd_g,
    output wire [5:0] lcd_b,
    output wire lcd_vsync,
    output wire lcd_hsync,
    output wire lcd_nclk,
    output wire lcd_de);

reg [3:0] counter_ff;
always @(posedge clk) begin
    if (rst) begin
        counter_ff <= 4'h0;
    end else begin
        counter_ff <= counter_ff + 1;
    end
end

/*
case (counter_ff) begin
4'h0: // send req
4'h1:
4'h2:
4'h3:
4'h4:
4'h5:
4'h6:
4'h7:
4'h8:
4'h9:
4'ha:
4'hb:
4'hc:
4'hd: // update x
4'he: // update y
4'hf: // update data
endcase
*/
reg send_req_ff;
reg update_x_ff;
reg update_y_ff;
reg update_data_ff;
always @(posedge clk) begin
    if (rst) begin
        send_req_ff <= 1'b0;
        update_x_ff <= 1'b0;
        update_y_ff <= 1'b0;
        update_data_ff <= 1'b0;
    end else begin
        if (counter_ff == 4'hf)
            send_req_ff <= 1'b1;
        else
            send_req_ff <= 1'b0;

        if (counter_ff == 4'hc)
            update_x_ff <= 1'b1;
        else
            update_x_ff <= 1'b0;

        if (counter_ff == 4'hd)
            update_y_ff <= 1'b1;
        else
            update_y_ff <= 1'b0;

        if (counter_ff == 4'he)
            update_data_ff <= 1'b1;
        else
            update_data_ff <= 1'b0;
    end
end
wire send_req = send_req_ff;
wire update_x = update_x_ff;
wire update_y = update_y_ff;
wire update_data = update_data_ff;

reg lcd_nclk_ff;
always @(posedge clk) begin
    if (rst)
        lcd_nclk_ff <= 1'b0;
    else begin
        if (counter_ff < 4'h8)
            lcd_nclk_ff <= 1'b1;
        else
            lcd_nclk_ff <= 1'b0;
    end
end

reg [8:0] curr_x_ff;
reg in_hsync_ff;
always @(posedge clk) begin
    if (rst) begin
        curr_x_ff <= 9'd400;
        in_hsync_ff <= 1'b0;
    end else begin
        if (update_x) begin
            if (curr_x_ff == 9'd506) begin
                curr_x_ff <= 9'd000;
                in_hsync_ff <= 0;
            end else begin
                curr_x_ff <= curr_x_ff + 1;
                in_hsync_ff <= (curr_x_ff >= 9'd400) ? 1'b1 : 1'b0;
            end
        end
    end
end

reg lcd_hsync_ff;
always @(posedge clk) begin
    if (rst)
        lcd_hsync_ff <= 1'b1;
    else begin
        if (update_data) begin
            if (curr_x_ff == 9'd401)
                lcd_hsync_ff <= 1'b0;
            else
                lcd_hsync_ff <= 1'b1;
        end
    end
end

reg [6:0] curr_y_ff;
reg in_vsync_ff;
always @(posedge clk) begin
    if (rst) begin
        curr_y_ff <= 7'd96;
        in_vsync_ff <= 1'b0;
    end else begin
        if (update_y && curr_x_ff == 9'd400) begin
            if (curr_y_ff == 7'd111) begin
                curr_y_ff <= 7'd0;
                in_vsync_ff <= 1'b0;
            end else begin
                curr_y_ff <= curr_y_ff + 1;
                in_vsync_ff <= (curr_y_ff >= 7'd96) ? 1'b1 : 1'b0;
            end
        end
    end
end

reg lcd_vsync_ff;
always @(posedge clk) begin
    if (rst)
        lcd_vsync_ff <= 1'b1;
    else begin
        if (update_data) begin
            if (curr_y_ff == 7'd97)
                lcd_vsync_ff <= 1'b0;
            else
                lcd_vsync_ff <= 1'b1;
        end
    end
end

assign x_o = curr_x_ff;
assign y_o = curr_y_ff;
assign in_hsync_o = in_hsync_ff;
assign in_vsync_o = in_vsync_ff;
assign pop_o = send_req;

reg [5:0] lcd_r_pending_ff;
reg [5:0] lcd_g_pending_ff;
reg [5:0] lcd_b_pending_ff;
always @(posedge clk) begin
    if (rst) begin
        lcd_r_pending_ff <= 6'h00;
        lcd_g_pending_ff <= 6'h00;
        lcd_b_pending_ff <= 6'h00;
    end else if (ack_i) begin
        lcd_r_pending_ff <= r_i;
        lcd_g_pending_ff <= g_i;
        lcd_b_pending_ff <= b_i;
    end
end

reg [5:0] lcd_r_ff;
reg [5:0] lcd_g_ff;
reg [5:0] lcd_b_ff;
always @(posedge clk) begin
    if (rst) begin
        lcd_r_ff <= 6'h00;
        lcd_g_ff <= 6'h00;
        lcd_b_ff <= 6'h00;
    end else if (update_data) begin
        lcd_r_ff <= lcd_r_pending_ff;
        lcd_g_ff <= lcd_g_pending_ff;
        lcd_b_ff <= lcd_b_pending_ff;
    end
end

assign lcd_de = 1'b0;
assign lcd_vsync = lcd_vsync_ff;
assign lcd_hsync = lcd_hsync_ff;
assign lcd_nclk = lcd_nclk_ff;
assign lcd_r[5:0] = lcd_r_ff;
assign lcd_g[5:0] = lcd_g_ff;
assign lcd_b[5:0] = lcd_b_ff;

endmodule",211,960
28,19,0,False,False,"module patterngen(
    input wire clk, // clk491520
    input wire rst,

    input wire [8:0] x_i,
    input wire [6:0] y_i,
    input wire pop_i,
    output wire [5:0] r_o,
    output wire [5:0] g_o,
    output wire [5:0] b_o,
    output wire ack_o);

reg [5:0] r_ff;
reg [5:0] g_ff;
reg [5:0] b_ff;
reg ack_ff;

always @(posedge clk) begin
    if (rst) begin
        r_ff <= 6'h00;
        g_ff <= 6'h00;
        b_ff <= 6'h00;
        ack_ff <= 1'b0;
    end else if (pop_i) begin
        if (y_i == 7'd1)
            r_ff <= 6'h3f;
        else
            r_ff <= 6'h00;

        if (y_i == 7'd0)
            g_ff <= 6'h3f;
        else
            g_ff <= 6'h00;

        if (y_i == 7'd95)
            b_ff <= 6'h3f;
        else
            b_ff <= 6'h00;

        ack_ff <= 1'b1;
    end else
        ack_ff <= 1'b0;
end

assign r_o = r_ff;
assign g_o = g_ff;
assign b_o = b_ff;
assign ack_o = ack_ff;

endmodule",50,961
4,2,0,False,False,"module SyncToClock (clk_i, unsynced_i, synced_o);

   parameter   syncStages = 2;   //number of stages in syncing register

   input       clk_i;
   input       unsynced_i;
   output      synced_o;
   
   reg         [syncStages:1] sync_r;

   always @(posedge clk_i)
      sync_r <= {sync_r[syncStages-1:1], unsynced_i};

   assign synced_o = sync_r[syncStages];
   
endmodule",16,968
14,51,0,False,False,"module NIOS_SYSTEMV3_CH0_THRESH (
                                  // inputs:
                                   address,
                                   chipselect,
                                   clk,
                                   reset_n,
                                   write_n,
                                   writedata,

                                  // outputs:
                                   out_port,
                                   readdata
                                )
;

  output  [ 23: 0] out_port;
  output  [ 31: 0] readdata;
  input   [  1: 0] address;
  input            chipselect;
  input            clk;
  input            reset_n;
  input            write_n;
  input   [ 31: 0] writedata;

  wire             clk_en;
  reg     [ 23: 0] data_out;
  wire    [ 23: 0] out_port;
  wire    [ 23: 0] read_mux_out;
  wire    [ 31: 0] readdata;
  assign clk_en = 1;
  //s1, which is an e_avalon_slave
  assign read_mux_out = {24 {(address == 0)}} & data_out;
  always @(posedge clk or negedge reset_n)
    begin
      if (reset_n == 0)
          data_out <= 0;
      else if (chipselect && ~write_n && (address == 0))
          data_out <= writedata[23 : 0];
    end


  assign readdata = {32'b0 | read_mux_out};
  assign out_port = data_out;

endmodule",45,975
1413,2766,0,False,False,"module tag_manager # (
  parameter TCQ           = 1,
  parameter RAM_ADDR_BITS = 5
)(
  input                     clk,
  input                     reset_n,
  
  input                     tag_mang_write_en,
  
  input [2:0]               tag_mang_tc_wr,             //[15:0]
  input [2:0]               tag_mang_attr_wr,           //[15:0]
  input [15:0]              tag_mang_requester_id_wr,   //[15:0]
  input [6:0]               tag_mang_lower_addr_wr,     //[6:0]
  input                     tag_mang_completer_func_wr, //[0:0]
  input [7:0]               tag_mang_tag_wr,            //[7:0]
  input [3:0]               tag_mang_first_be_wr,       //[2:0]
     
  input                     tag_mang_read_en,         
       
  output [2:0]              tag_mang_tc_rd,   //[15:0]
  output [2:0]              tag_mang_attr_rd,   //[15:0]
  output [15:0]             tag_mang_requester_id_rd,   //[15:0]
  output [6:0]              tag_mang_lower_addr_rd,     //[6:0]
  output                    tag_mang_completer_func_rd, //[0:0]
  output [7:0]              tag_mang_tag_rd,            //[7:0]
  output [3:0]              tag_mang_first_be_rd      //[2:0]
    );

    
  reg [RAM_ADDR_BITS-1:0] tag_mang_write_id;      
  reg [RAM_ADDR_BITS-1:0] tag_mang_read_id;        

  always @( posedge clk )
    if  ( !reset_n ) 
      tag_mang_write_id <= #TCQ 1;
    else if ( tag_mang_write_en ) 
      tag_mang_write_id <= #TCQ tag_mang_write_id + 1;   
      
  always @( posedge clk )
    if  ( !reset_n ) 
      tag_mang_read_id <= #TCQ 0;
    else if ( tag_mang_read_en ) 
      tag_mang_read_id <= #TCQ tag_mang_read_id + 1;
            
            
   localparam RAM_WIDTH = 42;

   (* RAM_STYLE=""distributed"" *)
   reg [RAM_WIDTH-1:0] tag_storage [(2**RAM_ADDR_BITS)-1:0];

   wire [RAM_WIDTH-1:0] completion_data;

   always @(posedge clk)
      if (tag_mang_write_en)
         tag_storage[tag_mang_write_id] <= #TCQ { tag_mang_attr_wr, tag_mang_tc_wr, tag_mang_requester_id_wr, tag_mang_lower_addr_wr, tag_mang_completer_func_wr, tag_mang_tag_wr, tag_mang_first_be_wr};

   assign completion_data = tag_storage[tag_mang_read_id];
   
   assign tag_mang_attr_rd           = completion_data[41:39];
   assign tag_mang_tc_rd             = completion_data[38:36];
   assign tag_mang_requester_id_rd   = completion_data[35:20];     //[15:0]
   assign tag_mang_lower_addr_rd     = completion_data[19:13];     //[6:0]
   assign tag_mang_completer_func_rd = completion_data[12];        //[0:0]
   assign tag_mang_tag_rd            = completion_data[11:4];      //[7:0]
   assign tag_mang_first_be_rd       = completion_data[3:0];       //[2:0]        



    
endmodule",70,997
